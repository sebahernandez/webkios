{"ast":null,"code":"import { useContext, useCallback, useMemo } from 'react';\nimport { ModalContext } from './modal.context';\n/**\n * Callback types provided for descriptive type-hints\n */\n\n/**\n * Utility function to generate unique number per component instance\n */\nconst generateModalKey = (() => {\n  let count = 0;\n  return () => `${++count}`;\n})();\n/**\n * Check whether the argument is a stateless component.\n *\n * We take advantage of the stateless nature of functional components to be\n * inline the rendering of the modal component as part of another immutable\n * component.\n *\n * This is necessary for allowing the modal to update based on the inputs passed\n * as the second argument to useModal without unmounting the previous version of\n * the modal component.\n */\n\n\nconst isFunctionalComponent = Component => {\n  const prototype = Component.prototype;\n  return !prototype || !prototype.isReactComponent;\n};\n/**\n * React hook for showing modal windows\n */\n\n\nexport const useModal = (component, options = {}) => {\n  if (!isFunctionalComponent(component)) {\n    throw new Error('Only stateless components can be used as an argument to useModal. You have probably passed a class component where a function was expected.');\n  }\n\n  const key = useMemo(generateModalKey, []);\n  const modal = useMemo(() => component, options.inputs);\n  const context = useContext(ModalContext);\n  const showModal = useCallback(() => context.showModal(key, modal, options), [context.showModal]);\n  const hideModal = useCallback(() => context.hideModal(key), [context.hideModal, key]); // const [isShown, setShown] = useState<boolean>(false);\n  // const showModal = useCallback(() => setShown(true), []);\n  // const hideModal = useCallback(() => setShown(false), []);\n  // useEffect(() => {\n  //   if (isShown) {\n  //     context.showModal(key, modal);\n  //   } else {\n  //     context.hideModal(key);\n  //   }\n  //   // Hide modal when parent component unmounts\n  //   return () => context.hideModal(key);\n  // }, [modal, isShown]);\n\n  return [showModal, hideModal];\n}; // export default useModal;\n/// uses\n// import useModal from \"use-modal\";\n// import ModalProvider from \"modal.provider\";\n// import Modal from \"react-modal\"; // It can be any modal\n// const MyModal = memo(\n//   ({ isOpen, onClose, title, description, closeBtnLabel }) => (\n//     <Modal isOpen={isOpen} onRequestClose={onClose}>\n//       <h2>{title}</h2>\n//       <div>{description}</div>\n//       <button onClick={onClose}>{closeBtnLabel}</button>\n//     </Modal>\n//   )\n// );\n// const SomePage = memo(() => {\n//   const [showModal, hideModal] = useModal(MyModal, {\n//     title: \"My Test Modal\",\n//     description: \"I Like React Hooks\",\n//     closeBtnLabel: \"Close\"\n//   });\n//   return (\n//     <>\n//       <h1>Test Page</h1>\n//       <button onClick={showModal}>Show Modal</button>\n//     </>\n//   );\n// });\n// const App = () => (\n//   <ModalProvider>\n//     <SomePage />\n//   </ModalProvider>\n// );\n// useModal(<ModalComponent: Function|>, <modalProps: Object>, <onClose: Function>): [showModal: Function, hideModal: Function]\n// Param\tType\tDescription\n// ModalComponent\tFunction\tIt can be any react component that you want to use for show modal\n// modalProps\tObject\tProps that you want to pass to your modal component\n// showModal\tFunction\tIt is function for show your modal, you can pass any dynamic props to this function\n// hideModal\tFunction\tIt is function for hide your modal, you can pass any dynamic props to this function\n// onClose\tFunction\tIt callback will be triggered after modal window closes\n// showModal(dynamicModalProps: Object)\n// Param\tType\tDescription\n// dynamicModalProps\tObject\tDynamic props that you want to pass to your modal component","map":{"version":3,"sources":["/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/contexts/modal/use-modal.ts"],"names":["useContext","useCallback","useMemo","ModalContext","generateModalKey","count","isFunctionalComponent","Component","prototype","isReactComponent","useModal","component","options","Error","key","modal","inputs","context","showModal","hideModal"],"mappings":"AAAA,SAASA,UAAT,EAA0CC,WAA1C,EAAuDC,OAAvD,QAAsE,OAAtE;AACA,SAASC,YAAT,QAAwC,iBAAxC;AAEA;AACA;AACA;;AAIA;AACA;AACA;AACA,MAAMC,gBAAgB,GAAG,CAAC,MAAM;AAC9B,MAAIC,KAAK,GAAG,CAAZ;AAEA,SAAO,MAAO,GAAE,EAAEA,KAAM,EAAxB;AACD,CAJwB,GAAzB;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,qBAAqB,GAAIC,SAAD,IAAyB;AACrD,QAAMC,SAAS,GAAGD,SAAS,CAACC,SAA5B;AAEA,SAAO,CAACA,SAAD,IAAc,CAACA,SAAS,CAACC,gBAAhC;AACD,CAJD;AAMA;AACA;AACA;;;AACA,OAAO,MAAMC,QAAQ,GAAG,CACtBC,SADsB,EAEtBC,OAAY,GAAG,EAFO,KAGK;AAC3B,MAAI,CAACN,qBAAqB,CAACK,SAAD,CAA1B,EAAuC;AACrC,UAAM,IAAIE,KAAJ,CACJ,6IADI,CAAN;AAGD;;AAED,QAAMC,GAAG,GAAGZ,OAAO,CAACE,gBAAD,EAAmB,EAAnB,CAAnB;AACA,QAAMW,KAAK,GAAGb,OAAO,CAAC,MAAMS,SAAP,EAAkBC,OAAO,CAACI,MAA1B,CAArB;AACA,QAAMC,OAAO,GAAGjB,UAAU,CAACG,YAAD,CAA1B;AACA,QAAMe,SAAS,GAAGjB,WAAW,CAAC,MAAMgB,OAAO,CAACC,SAAR,CAAkBJ,GAAlB,EAAuBC,KAAvB,EAA8BH,OAA9B,CAAP,EAA+C,CAC1EK,OAAO,CAACC,SADkE,CAA/C,CAA7B;AAGA,QAAMC,SAAS,GAAGlB,WAAW,CAAC,MAAMgB,OAAO,CAACE,SAAR,CAAkBL,GAAlB,CAAP,EAA+B,CAC1DG,OAAO,CAACE,SADkD,EAE1DL,GAF0D,CAA/B,CAA7B,CAb2B,CAiB3B;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA,SAAO,CAACI,SAAD,EAAYC,SAAZ,CAAP;AACD,CApCM,C,CAsCP;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { useContext, useEffect, useState, useCallback, useMemo } from 'react';\nimport { ModalContext, ModalType } from './modal.context';\n\n/**\n * Callback types provided for descriptive type-hints\n */\ntype ShowModal = () => void;\ntype HideModal = () => void;\n\n/**\n * Utility function to generate unique number per component instance\n */\nconst generateModalKey = (() => {\n  let count = 0;\n\n  return () => `${++count}`;\n})();\n\n/**\n * Check whether the argument is a stateless component.\n *\n * We take advantage of the stateless nature of functional components to be\n * inline the rendering of the modal component as part of another immutable\n * component.\n *\n * This is necessary for allowing the modal to update based on the inputs passed\n * as the second argument to useModal without unmounting the previous version of\n * the modal component.\n */\nconst isFunctionalComponent = (Component: Function) => {\n  const prototype = Component.prototype;\n\n  return !prototype || !prototype.isReactComponent;\n};\n\n/**\n * React hook for showing modal windows\n */\nexport const useModal = (\n  component: ModalType,\n  options: any = {}\n): [ShowModal, HideModal] => {\n  if (!isFunctionalComponent(component)) {\n    throw new Error(\n      'Only stateless components can be used as an argument to useModal. You have probably passed a class component where a function was expected.'\n    );\n  }\n\n  const key = useMemo(generateModalKey, []);\n  const modal = useMemo(() => component, options.inputs);\n  const context = useContext(ModalContext);\n  const showModal = useCallback(() => context.showModal(key, modal, options), [\n    context.showModal,\n  ]);\n  const hideModal = useCallback(() => context.hideModal(key), [\n    context.hideModal,\n    key,\n  ]);\n  // const [isShown, setShown] = useState<boolean>(false);\n  // const showModal = useCallback(() => setShown(true), []);\n  // const hideModal = useCallback(() => setShown(false), []);\n\n  // useEffect(() => {\n  //   if (isShown) {\n  //     context.showModal(key, modal);\n  //   } else {\n  //     context.hideModal(key);\n  //   }\n\n  //   // Hide modal when parent component unmounts\n  //   return () => context.hideModal(key);\n  // }, [modal, isShown]);\n\n  return [showModal, hideModal];\n};\n\n// export default useModal;\n\n/// uses\n// import useModal from \"use-modal\";\n// import ModalProvider from \"modal.provider\";\n// import Modal from \"react-modal\"; // It can be any modal\n\n// const MyModal = memo(\n//   ({ isOpen, onClose, title, description, closeBtnLabel }) => (\n//     <Modal isOpen={isOpen} onRequestClose={onClose}>\n//       <h2>{title}</h2>\n//       <div>{description}</div>\n//       <button onClick={onClose}>{closeBtnLabel}</button>\n//     </Modal>\n//   )\n// );\n\n// const SomePage = memo(() => {\n//   const [showModal, hideModal] = useModal(MyModal, {\n//     title: \"My Test Modal\",\n//     description: \"I Like React Hooks\",\n//     closeBtnLabel: \"Close\"\n//   });\n\n//   return (\n//     <>\n//       <h1>Test Page</h1>\n//       <button onClick={showModal}>Show Modal</button>\n//     </>\n//   );\n// });\n\n// const App = () => (\n//   <ModalProvider>\n//     <SomePage />\n//   </ModalProvider>\n// );\n\n// useModal(<ModalComponent: Function|>, <modalProps: Object>, <onClose: Function>): [showModal: Function, hideModal: Function]\n// Param\tType\tDescription\n// ModalComponent\tFunction\tIt can be any react component that you want to use for show modal\n// modalProps\tObject\tProps that you want to pass to your modal component\n// showModal\tFunction\tIt is function for show your modal, you can pass any dynamic props to this function\n// hideModal\tFunction\tIt is function for hide your modal, you can pass any dynamic props to this function\n// onClose\tFunction\tIt callback will be triggered after modal window closes\n// showModal(dynamicModalProps: Object)\n// Param\tType\tDescription\n// dynamicModalProps\tObject\tDynamic props that you want to pass to your modal component\n"]},"metadata":{},"sourceType":"module"}