(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[6],{

/***/ "../../node_modules/localforage/dist/localforage.js":
/*!***************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/localforage/dist/localforage.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var require;var require;/*!\n    localForage -- Offline Storage, Improved\n    Version 1.9.0\n    https://localforage.github.io/localForage\n    (c) 2013-2017 Mozilla, Apache License 2.0\n*/\n(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw (f.code=\"MODULE_NOT_FOUND\", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(_dereq_,module,exports){\n'use strict';\nvar immediate = _dereq_(1);\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n},{\"1\":1}],3:[function(_dereq_,module,exports){\n(function (global){\n'use strict';\nif (typeof global.Promise !== 'function') {\n  global.Promise = _dereq_(2);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"2\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getIDB() {\n    /* global indexedDB,webkitIndexedDB,mozIndexedDB,OIndexedDB,msIndexedDB */\n    try {\n        if (typeof indexedDB !== 'undefined') {\n            return indexedDB;\n        }\n        if (typeof webkitIndexedDB !== 'undefined') {\n            return webkitIndexedDB;\n        }\n        if (typeof mozIndexedDB !== 'undefined') {\n            return mozIndexedDB;\n        }\n        if (typeof OIndexedDB !== 'undefined') {\n            return OIndexedDB;\n        }\n        if (typeof msIndexedDB !== 'undefined') {\n            return msIndexedDB;\n        }\n    } catch (e) {\n        return;\n    }\n}\n\nvar idb = getIDB();\n\nfunction isIndexedDBValid() {\n    try {\n        // Initialize IndexedDB; fall back to vendor-prefixed versions\n        // if needed.\n        if (!idb || !idb.open) {\n            return false;\n        }\n        // We mimic PouchDB here;\n        //\n        // We test for openDatabase because IE Mobile identifies itself\n        // as Safari. Oh the lulz...\n        var isSafari = typeof openDatabase !== 'undefined' && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform);\n\n        var hasFetch = typeof fetch === 'function' && fetch.toString().indexOf('[native code') !== -1;\n\n        // Safari <10.1 does not meet our requirements for IDB support\n        // (see: https://github.com/pouchdb/pouchdb/issues/5572).\n        // Safari 10.1 shipped with fetch, we can use that to detect it.\n        // Note: this creates issues with `window.fetch` polyfills and\n        // overrides; see:\n        // https://github.com/localForage/localForage/issues/856\n        return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n        // some outdated implementations of IDB that appear on Samsung\n        // and HTC Android devices <4.4 are missing IDBKeyRange\n        // See: https://github.com/mozilla/localForage/issues/128\n        // See: https://github.com/mozilla/localForage/issues/272\n        typeof IDBKeyRange !== 'undefined';\n    } catch (e) {\n        return false;\n    }\n}\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor. (i.e.\n// old QtWebKit versions, at least).\nfunction createBlob(parts, properties) {\n    /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n    parts = parts || [];\n    properties = properties || {};\n    try {\n        return new Blob(parts, properties);\n    } catch (e) {\n        if (e.name !== 'TypeError') {\n            throw e;\n        }\n        var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder : typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder : typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder : WebKitBlobBuilder;\n        var builder = new Builder();\n        for (var i = 0; i < parts.length; i += 1) {\n            builder.append(parts[i]);\n        }\n        return builder.getBlob(properties.type);\n    }\n}\n\n// This is CommonJS because lie is an external dependency, so Rollup\n// can just ignore it.\nif (typeof Promise === 'undefined') {\n    // In the \"nopromises\" build this will just throw if you don't have\n    // a global promise object, but it would throw anyway later.\n    _dereq_(3);\n}\nvar Promise$1 = Promise;\n\nfunction executeCallback(promise, callback) {\n    if (callback) {\n        promise.then(function (result) {\n            callback(null, result);\n        }, function (error) {\n            callback(error);\n        });\n    }\n}\n\nfunction executeTwoCallbacks(promise, callback, errorCallback) {\n    if (typeof callback === 'function') {\n        promise.then(callback);\n    }\n\n    if (typeof errorCallback === 'function') {\n        promise[\"catch\"](errorCallback);\n    }\n}\n\nfunction normalizeKey(key) {\n    // Cast the key to a string, as that's all we can set as a key.\n    if (typeof key !== 'string') {\n        console.warn(key + ' used as a key, but it is not a string.');\n        key = String(key);\n    }\n\n    return key;\n}\n\nfunction getCallback() {\n    if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n        return arguments[arguments.length - 1];\n    }\n}\n\n// Some code originally from async_storage.js in\n// [Gaia](https://github.com/mozilla-b2g/gaia).\n\nvar DETECT_BLOB_SUPPORT_STORE = 'local-forage-detect-blob-support';\nvar supportsBlobs = void 0;\nvar dbContexts = {};\nvar toString = Object.prototype.toString;\n\n// Transaction Modes\nvar READ_ONLY = 'readonly';\nvar READ_WRITE = 'readwrite';\n\n// Transform a binary string to an array buffer, because otherwise\n// weird stuff happens when you try to work with the binary string directly.\n// It is known.\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction _binStringToArrayBuffer(bin) {\n    var length = bin.length;\n    var buf = new ArrayBuffer(length);\n    var arr = new Uint8Array(buf);\n    for (var i = 0; i < length; i++) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return buf;\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\n// Code borrowed from PouchDB. See:\n// https://github.com/pouchdb/pouchdb/blob/master/packages/node_modules/pouchdb-adapter-idb/src/blobSupport.js\n//\nfunction _checkBlobSupportWithoutCaching(idb) {\n    return new Promise$1(function (resolve) {\n        var txn = idb.transaction(DETECT_BLOB_SUPPORT_STORE, READ_WRITE);\n        var blob = createBlob(['']);\n        txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n        txn.onabort = function (e) {\n            // If the transaction aborts now its due to not being able to\n            // write to the database, likely due to the disk being full\n            e.preventDefault();\n            e.stopPropagation();\n            resolve(false);\n        };\n\n        txn.oncomplete = function () {\n            var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n            var matchedEdge = navigator.userAgent.match(/Edge\\//);\n            // MS Edge pretends to be Chrome 42:\n            // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n            resolve(matchedEdge || !matchedChrome || parseInt(matchedChrome[1], 10) >= 43);\n        };\n    })[\"catch\"](function () {\n        return false; // error, so assume unsupported\n    });\n}\n\nfunction _checkBlobSupport(idb) {\n    if (typeof supportsBlobs === 'boolean') {\n        return Promise$1.resolve(supportsBlobs);\n    }\n    return _checkBlobSupportWithoutCaching(idb).then(function (value) {\n        supportsBlobs = value;\n        return supportsBlobs;\n    });\n}\n\nfunction _deferReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Create a deferred object representing the current database operation.\n    var deferredOperation = {};\n\n    deferredOperation.promise = new Promise$1(function (resolve, reject) {\n        deferredOperation.resolve = resolve;\n        deferredOperation.reject = reject;\n    });\n\n    // Enqueue the deferred operation.\n    dbContext.deferredOperations.push(deferredOperation);\n\n    // Chain its promise to the database readiness.\n    if (!dbContext.dbReady) {\n        dbContext.dbReady = deferredOperation.promise;\n    } else {\n        dbContext.dbReady = dbContext.dbReady.then(function () {\n            return deferredOperation.promise;\n        });\n    }\n}\n\nfunction _advanceReadiness(dbInfo) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Resolve its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.resolve();\n        return deferredOperation.promise;\n    }\n}\n\nfunction _rejectReadiness(dbInfo, err) {\n    var dbContext = dbContexts[dbInfo.name];\n\n    // Dequeue a deferred operation.\n    var deferredOperation = dbContext.deferredOperations.pop();\n\n    // Reject its promise (which is part of the database readiness\n    // chain of promises).\n    if (deferredOperation) {\n        deferredOperation.reject(err);\n        return deferredOperation.promise;\n    }\n}\n\nfunction _getConnection(dbInfo, upgradeNeeded) {\n    return new Promise$1(function (resolve, reject) {\n        dbContexts[dbInfo.name] = dbContexts[dbInfo.name] || createDbContext();\n\n        if (dbInfo.db) {\n            if (upgradeNeeded) {\n                _deferReadiness(dbInfo);\n                dbInfo.db.close();\n            } else {\n                return resolve(dbInfo.db);\n            }\n        }\n\n        var dbArgs = [dbInfo.name];\n\n        if (upgradeNeeded) {\n            dbArgs.push(dbInfo.version);\n        }\n\n        var openreq = idb.open.apply(idb, dbArgs);\n\n        if (upgradeNeeded) {\n            openreq.onupgradeneeded = function (e) {\n                var db = openreq.result;\n                try {\n                    db.createObjectStore(dbInfo.storeName);\n                    if (e.oldVersion <= 1) {\n                        // Added when support for blob shims was added\n                        db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n                    }\n                } catch (ex) {\n                    if (ex.name === 'ConstraintError') {\n                        console.warn('The database \"' + dbInfo.name + '\"' + ' has been upgraded from version ' + e.oldVersion + ' to version ' + e.newVersion + ', but the storage \"' + dbInfo.storeName + '\" already exists.');\n                    } else {\n                        throw ex;\n                    }\n                }\n            };\n        }\n\n        openreq.onerror = function (e) {\n            e.preventDefault();\n            reject(openreq.error);\n        };\n\n        openreq.onsuccess = function () {\n            resolve(openreq.result);\n            _advanceReadiness(dbInfo);\n        };\n    });\n}\n\nfunction _getOriginalConnection(dbInfo) {\n    return _getConnection(dbInfo, false);\n}\n\nfunction _getUpgradedConnection(dbInfo) {\n    return _getConnection(dbInfo, true);\n}\n\nfunction _isUpgradeNeeded(dbInfo, defaultVersion) {\n    if (!dbInfo.db) {\n        return true;\n    }\n\n    var isNewStore = !dbInfo.db.objectStoreNames.contains(dbInfo.storeName);\n    var isDowngrade = dbInfo.version < dbInfo.db.version;\n    var isUpgrade = dbInfo.version > dbInfo.db.version;\n\n    if (isDowngrade) {\n        // If the version is not the default one\n        // then warn for impossible downgrade.\n        if (dbInfo.version !== defaultVersion) {\n            console.warn('The database \"' + dbInfo.name + '\"' + \" can't be downgraded from version \" + dbInfo.db.version + ' to version ' + dbInfo.version + '.');\n        }\n        // Align the versions to prevent errors.\n        dbInfo.version = dbInfo.db.version;\n    }\n\n    if (isUpgrade || isNewStore) {\n        // If the store is new then increment the version (if needed).\n        // This will trigger an \"upgradeneeded\" event which is required\n        // for creating a store.\n        if (isNewStore) {\n            var incVersion = dbInfo.db.version + 1;\n            if (incVersion > dbInfo.version) {\n                dbInfo.version = incVersion;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n// encode a blob for indexeddb engines that don't support blobs\nfunction _encodeBlob(blob) {\n    return new Promise$1(function (resolve, reject) {\n        var reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = function (e) {\n            var base64 = btoa(e.target.result || '');\n            resolve({\n                __local_forage_encoded_blob: true,\n                data: base64,\n                type: blob.type\n            });\n        };\n        reader.readAsBinaryString(blob);\n    });\n}\n\n// decode an encoded blob\nfunction _decodeBlob(encodedBlob) {\n    var arrayBuff = _binStringToArrayBuffer(atob(encodedBlob.data));\n    return createBlob([arrayBuff], { type: encodedBlob.type });\n}\n\n// is this one of our fancy encoded blobs?\nfunction _isEncodedBlob(value) {\n    return value && value.__local_forage_encoded_blob;\n}\n\n// Specialize the default `ready()` function by making it dependent\n// on the current database operations. Thus, the driver will be actually\n// ready when it's been initialized (default) *and* there are no pending\n// operations on the database (initiated by some other instances).\nfunction _fullyReady(callback) {\n    var self = this;\n\n    var promise = self._initReady().then(function () {\n        var dbContext = dbContexts[self._dbInfo.name];\n\n        if (dbContext && dbContext.dbReady) {\n            return dbContext.dbReady;\n        }\n    });\n\n    executeTwoCallbacks(promise, callback, callback);\n    return promise;\n}\n\n// Try to establish a new db connection to replace the\n// current one which is broken (i.e. experiencing\n// InvalidStateError while creating a transaction).\nfunction _tryReconnect(dbInfo) {\n    _deferReadiness(dbInfo);\n\n    var dbContext = dbContexts[dbInfo.name];\n    var forages = dbContext.forages;\n\n    for (var i = 0; i < forages.length; i++) {\n        var forage = forages[i];\n        if (forage._dbInfo.db) {\n            forage._dbInfo.db.close();\n            forage._dbInfo.db = null;\n        }\n    }\n    dbInfo.db = null;\n\n    return _getOriginalConnection(dbInfo).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        // store the latest db reference\n        // in case the db was upgraded\n        dbInfo.db = dbContext.db = db;\n        for (var i = 0; i < forages.length; i++) {\n            forages[i]._dbInfo.db = db;\n        }\n    })[\"catch\"](function (err) {\n        _rejectReadiness(dbInfo, err);\n        throw err;\n    });\n}\n\n// FF doesn't like Promises (micro-tasks) and IDDB store operations,\n// so we have to do it with callbacks\nfunction createTransaction(dbInfo, mode, callback, retries) {\n    if (retries === undefined) {\n        retries = 1;\n    }\n\n    try {\n        var tx = dbInfo.db.transaction(dbInfo.storeName, mode);\n        callback(null, tx);\n    } catch (err) {\n        if (retries > 0 && (!dbInfo.db || err.name === 'InvalidStateError' || err.name === 'NotFoundError')) {\n            return Promise$1.resolve().then(function () {\n                if (!dbInfo.db || err.name === 'NotFoundError' && !dbInfo.db.objectStoreNames.contains(dbInfo.storeName) && dbInfo.version <= dbInfo.db.version) {\n                    // increase the db version, to create the new ObjectStore\n                    if (dbInfo.db) {\n                        dbInfo.version = dbInfo.db.version + 1;\n                    }\n                    // Reopen the database for upgrading.\n                    return _getUpgradedConnection(dbInfo);\n                }\n            }).then(function () {\n                return _tryReconnect(dbInfo).then(function () {\n                    createTransaction(dbInfo, mode, callback, retries - 1);\n                });\n            })[\"catch\"](callback);\n        }\n\n        callback(err);\n    }\n}\n\nfunction createDbContext() {\n    return {\n        // Running localForages sharing a database.\n        forages: [],\n        // Shared database.\n        db: null,\n        // Database readiness (promise).\n        dbReady: null,\n        // Deferred operations on the database.\n        deferredOperations: []\n    };\n}\n\n// Open the IndexedDB database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    // Get the current context of the database;\n    var dbContext = dbContexts[dbInfo.name];\n\n    // ...or create a new context.\n    if (!dbContext) {\n        dbContext = createDbContext();\n        // Register the new context in the global container.\n        dbContexts[dbInfo.name] = dbContext;\n    }\n\n    // Register itself as a running localForage in the current context.\n    dbContext.forages.push(self);\n\n    // Replace the default `ready()` function with the specialized one.\n    if (!self._initReady) {\n        self._initReady = self.ready;\n        self.ready = _fullyReady;\n    }\n\n    // Create an array of initialization states of the related localForages.\n    var initPromises = [];\n\n    function ignoreErrors() {\n        // Don't handle errors here,\n        // just makes sure related localForages aren't pending.\n        return Promise$1.resolve();\n    }\n\n    for (var j = 0; j < dbContext.forages.length; j++) {\n        var forage = dbContext.forages[j];\n        if (forage !== self) {\n            // Don't wait for itself...\n            initPromises.push(forage._initReady()[\"catch\"](ignoreErrors));\n        }\n    }\n\n    // Take a snapshot of the related localForages.\n    var forages = dbContext.forages.slice(0);\n\n    // Initialize the connection process only when\n    // all the related localForages aren't pending.\n    return Promise$1.all(initPromises).then(function () {\n        dbInfo.db = dbContext.db;\n        // Get the connection or open a new one without upgrade.\n        return _getOriginalConnection(dbInfo);\n    }).then(function (db) {\n        dbInfo.db = db;\n        if (_isUpgradeNeeded(dbInfo, self._defaultConfig.version)) {\n            // Reopen the database for upgrading.\n            return _getUpgradedConnection(dbInfo);\n        }\n        return db;\n    }).then(function (db) {\n        dbInfo.db = dbContext.db = db;\n        self._dbInfo = dbInfo;\n        // Share the final connection amongst related localForages.\n        for (var k = 0; k < forages.length; k++) {\n            var forage = forages[k];\n            if (forage !== self) {\n                // Self is already up-to-date.\n                forage._dbInfo.db = dbInfo.db;\n                forage._dbInfo.version = dbInfo.version;\n            }\n        }\n    });\n}\n\nfunction getItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.get(key);\n\n                    req.onsuccess = function () {\n                        var value = req.result;\n                        if (value === undefined) {\n                            value = null;\n                        }\n                        if (_isEncodedBlob(value)) {\n                            value = _decodeBlob(value);\n                        }\n                        resolve(value);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items stored in database.\nfunction iterate(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openCursor();\n                    var iterationNumber = 1;\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (cursor) {\n                            var value = cursor.value;\n                            if (_isEncodedBlob(value)) {\n                                value = _decodeBlob(value);\n                            }\n                            var result = iterator(value, cursor.key, iterationNumber++);\n\n                            // when the iterator callback returns any\n                            // (non-`undefined`) value, then we stop\n                            // the iteration immediately\n                            if (result !== void 0) {\n                                resolve(result);\n                            } else {\n                                cursor[\"continue\"]();\n                            }\n                        } else {\n                            resolve();\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n\n    return promise;\n}\n\nfunction setItem(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        var dbInfo;\n        self.ready().then(function () {\n            dbInfo = self._dbInfo;\n            if (toString.call(value) === '[object Blob]') {\n                return _checkBlobSupport(dbInfo.db).then(function (blobSupport) {\n                    if (blobSupport) {\n                        return value;\n                    }\n                    return _encodeBlob(value);\n                });\n            }\n            return value;\n        }).then(function (value) {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n\n                    // The reason we don't _save_ null is because IE 10 does\n                    // not support saving the `null` type in IndexedDB. How\n                    // ironic, given the bug below!\n                    // See: https://github.com/mozilla/localForage/issues/161\n                    if (value === null) {\n                        value = undefined;\n                    }\n\n                    var req = store.put(value, key);\n\n                    transaction.oncomplete = function () {\n                        // Cast to undefined so the value passed to\n                        // callback/promise is the same as what one would get out\n                        // of `getItem()` later. This leads to some weirdness\n                        // (setItem('foo', undefined) will return `null`), but\n                        // it's not my fault localStorage is our baseline and that\n                        // it's weird.\n                        if (value === undefined) {\n                            value = null;\n                        }\n\n                        resolve(value);\n                    };\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction removeItem(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    // We use a Grunt task to make this safe for IE and some\n                    // versions of Android (including those used by Cordova).\n                    // Normally IE won't like `.delete()` and will insist on\n                    // using `['delete']()`, but we have a build step that\n                    // fixes this for us now.\n                    var req = store[\"delete\"](key);\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onerror = function () {\n                        reject(req.error);\n                    };\n\n                    // The request will be also be aborted if we've exceeded our storage\n                    // space.\n                    transaction.onabort = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction clear(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_WRITE, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.clear();\n\n                    transaction.oncomplete = function () {\n                        resolve();\n                    };\n\n                    transaction.onabort = transaction.onerror = function () {\n                        var err = req.error ? req.error : req.transaction.error;\n                        reject(err);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction length(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.count();\n\n                    req.onsuccess = function () {\n                        resolve(req.result);\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction key(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        if (n < 0) {\n            resolve(null);\n\n            return;\n        }\n\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var advanced = false;\n                    var req = store.openKeyCursor();\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n                        if (!cursor) {\n                            // this means there weren't enough keys\n                            resolve(null);\n\n                            return;\n                        }\n\n                        if (n === 0) {\n                            // We have the first key, return it if that's what they\n                            // wanted.\n                            resolve(cursor.key);\n                        } else {\n                            if (!advanced) {\n                                // Otherwise, ask the cursor to skip ahead n\n                                // records.\n                                advanced = true;\n                                cursor.advance(n);\n                            } else {\n                                // When we get here, we've got the nth key.\n                                resolve(cursor.key);\n                            }\n                        }\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            createTransaction(self._dbInfo, READ_ONLY, function (err, transaction) {\n                if (err) {\n                    return reject(err);\n                }\n\n                try {\n                    var store = transaction.objectStore(self._dbInfo.storeName);\n                    var req = store.openKeyCursor();\n                    var keys = [];\n\n                    req.onsuccess = function () {\n                        var cursor = req.result;\n\n                        if (!cursor) {\n                            resolve(keys);\n                            return;\n                        }\n\n                        keys.push(cursor.key);\n                        cursor[\"continue\"]();\n                    };\n\n                    req.onerror = function () {\n                        reject(req.error);\n                    };\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        var isCurrentDb = options.name === currentConfig.name && self._dbInfo.db;\n\n        var dbPromise = isCurrentDb ? Promise$1.resolve(self._dbInfo.db) : _getOriginalConnection(options).then(function (db) {\n            var dbContext = dbContexts[options.name];\n            var forages = dbContext.forages;\n            dbContext.db = db;\n            for (var i = 0; i < forages.length; i++) {\n                forages[i]._dbInfo.db = db;\n            }\n            return db;\n        });\n\n        if (!options.storeName) {\n            promise = dbPromise.then(function (db) {\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                }\n\n                var dropDBPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.deleteDatabase(options.name);\n\n                    req.onerror = req.onblocked = function (err) {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        reject(err);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        if (db) {\n                            db.close();\n                        }\n                        resolve(db);\n                    };\n                });\n\n                return dropDBPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var i = 0; i < forages.length; i++) {\n                        var _forage = forages[i];\n                        _advanceReadiness(_forage._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        } else {\n            promise = dbPromise.then(function (db) {\n                if (!db.objectStoreNames.contains(options.storeName)) {\n                    return;\n                }\n\n                var newVersion = db.version + 1;\n\n                _deferReadiness(options);\n\n                var dbContext = dbContexts[options.name];\n                var forages = dbContext.forages;\n\n                db.close();\n                for (var i = 0; i < forages.length; i++) {\n                    var forage = forages[i];\n                    forage._dbInfo.db = null;\n                    forage._dbInfo.version = newVersion;\n                }\n\n                var dropObjectPromise = new Promise$1(function (resolve, reject) {\n                    var req = idb.open(options.name, newVersion);\n\n                    req.onerror = function (err) {\n                        var db = req.result;\n                        db.close();\n                        reject(err);\n                    };\n\n                    req.onupgradeneeded = function () {\n                        var db = req.result;\n                        db.deleteObjectStore(options.storeName);\n                    };\n\n                    req.onsuccess = function () {\n                        var db = req.result;\n                        db.close();\n                        resolve(db);\n                    };\n                });\n\n                return dropObjectPromise.then(function (db) {\n                    dbContext.db = db;\n                    for (var j = 0; j < forages.length; j++) {\n                        var _forage2 = forages[j];\n                        _forage2._dbInfo.db = db;\n                        _advanceReadiness(_forage2._dbInfo);\n                    }\n                })[\"catch\"](function (err) {\n                    (_rejectReadiness(options, err) || Promise$1.resolve())[\"catch\"](function () {});\n                    throw err;\n                });\n            });\n        }\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar asyncStorage = {\n    _driver: 'asyncStorage',\n    _initStorage: _initStorage,\n    _support: isIndexedDBValid(),\n    iterate: iterate,\n    getItem: getItem,\n    setItem: setItem,\n    removeItem: removeItem,\n    clear: clear,\n    length: length,\n    key: key,\n    keys: keys,\n    dropInstance: dropInstance\n};\n\nfunction isWebSQLValid() {\n    return typeof openDatabase === 'function';\n}\n\n// Sadly, the best way to save binary data in WebSQL/localStorage is serializing\n// it to Base64, so this is how we store it to prevent very strange errors with less\n// verbose ways of binary <-> string data storage.\nvar BASE_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nvar BLOB_TYPE_PREFIX = '~~local_forage_type~';\nvar BLOB_TYPE_PREFIX_REGEX = /^~~local_forage_type~([^~]+)~/;\n\nvar SERIALIZED_MARKER = '__lfsc__:';\nvar SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER.length;\n\n// OMG the serializations!\nvar TYPE_ARRAYBUFFER = 'arbf';\nvar TYPE_BLOB = 'blob';\nvar TYPE_INT8ARRAY = 'si08';\nvar TYPE_UINT8ARRAY = 'ui08';\nvar TYPE_UINT8CLAMPEDARRAY = 'uic8';\nvar TYPE_INT16ARRAY = 'si16';\nvar TYPE_INT32ARRAY = 'si32';\nvar TYPE_UINT16ARRAY = 'ur16';\nvar TYPE_UINT32ARRAY = 'ui32';\nvar TYPE_FLOAT32ARRAY = 'fl32';\nvar TYPE_FLOAT64ARRAY = 'fl64';\nvar TYPE_SERIALIZED_MARKER_LENGTH = SERIALIZED_MARKER_LENGTH + TYPE_ARRAYBUFFER.length;\n\nvar toString$1 = Object.prototype.toString;\n\nfunction stringToBuffer(serializedString) {\n    // Fill the string into a ArrayBuffer.\n    var bufferLength = serializedString.length * 0.75;\n    var len = serializedString.length;\n    var i;\n    var p = 0;\n    var encoded1, encoded2, encoded3, encoded4;\n\n    if (serializedString[serializedString.length - 1] === '=') {\n        bufferLength--;\n        if (serializedString[serializedString.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n\n    var buffer = new ArrayBuffer(bufferLength);\n    var bytes = new Uint8Array(buffer);\n\n    for (i = 0; i < len; i += 4) {\n        encoded1 = BASE_CHARS.indexOf(serializedString[i]);\n        encoded2 = BASE_CHARS.indexOf(serializedString[i + 1]);\n        encoded3 = BASE_CHARS.indexOf(serializedString[i + 2]);\n        encoded4 = BASE_CHARS.indexOf(serializedString[i + 3]);\n\n        /*jslint bitwise: true */\n        bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return buffer;\n}\n\n// Converts a buffer to a string to store, serialized, in the backend\n// storage library.\nfunction bufferToString(buffer) {\n    // base64-arraybuffer\n    var bytes = new Uint8Array(buffer);\n    var base64String = '';\n    var i;\n\n    for (i = 0; i < bytes.length; i += 3) {\n        /*jslint bitwise: true */\n        base64String += BASE_CHARS[bytes[i] >> 2];\n        base64String += BASE_CHARS[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n        base64String += BASE_CHARS[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n        base64String += BASE_CHARS[bytes[i + 2] & 63];\n    }\n\n    if (bytes.length % 3 === 2) {\n        base64String = base64String.substring(0, base64String.length - 1) + '=';\n    } else if (bytes.length % 3 === 1) {\n        base64String = base64String.substring(0, base64String.length - 2) + '==';\n    }\n\n    return base64String;\n}\n\n// Serialize a value, afterwards executing a callback (which usually\n// instructs the `setItem()` callback/promise to be executed). This is how\n// we store binary data with localStorage.\nfunction serialize(value, callback) {\n    var valueType = '';\n    if (value) {\n        valueType = toString$1.call(value);\n    }\n\n    // Cannot use `value instanceof ArrayBuffer` or such here, as these\n    // checks fail when running the tests using casper.js...\n    //\n    // TODO: See why those tests fail and use a better solution.\n    if (value && (valueType === '[object ArrayBuffer]' || value.buffer && toString$1.call(value.buffer) === '[object ArrayBuffer]')) {\n        // Convert binary arrays to a string and prefix the string with\n        // a special marker.\n        var buffer;\n        var marker = SERIALIZED_MARKER;\n\n        if (value instanceof ArrayBuffer) {\n            buffer = value;\n            marker += TYPE_ARRAYBUFFER;\n        } else {\n            buffer = value.buffer;\n\n            if (valueType === '[object Int8Array]') {\n                marker += TYPE_INT8ARRAY;\n            } else if (valueType === '[object Uint8Array]') {\n                marker += TYPE_UINT8ARRAY;\n            } else if (valueType === '[object Uint8ClampedArray]') {\n                marker += TYPE_UINT8CLAMPEDARRAY;\n            } else if (valueType === '[object Int16Array]') {\n                marker += TYPE_INT16ARRAY;\n            } else if (valueType === '[object Uint16Array]') {\n                marker += TYPE_UINT16ARRAY;\n            } else if (valueType === '[object Int32Array]') {\n                marker += TYPE_INT32ARRAY;\n            } else if (valueType === '[object Uint32Array]') {\n                marker += TYPE_UINT32ARRAY;\n            } else if (valueType === '[object Float32Array]') {\n                marker += TYPE_FLOAT32ARRAY;\n            } else if (valueType === '[object Float64Array]') {\n                marker += TYPE_FLOAT64ARRAY;\n            } else {\n                callback(new Error('Failed to get type for BinaryArray'));\n            }\n        }\n\n        callback(marker + bufferToString(buffer));\n    } else if (valueType === '[object Blob]') {\n        // Conver the blob to a binaryArray and then to a string.\n        var fileReader = new FileReader();\n\n        fileReader.onload = function () {\n            // Backwards-compatible prefix for the blob type.\n            var str = BLOB_TYPE_PREFIX + value.type + '~' + bufferToString(this.result);\n\n            callback(SERIALIZED_MARKER + TYPE_BLOB + str);\n        };\n\n        fileReader.readAsArrayBuffer(value);\n    } else {\n        try {\n            callback(JSON.stringify(value));\n        } catch (e) {\n            console.error(\"Couldn't convert value into a JSON string: \", value);\n\n            callback(null, e);\n        }\n    }\n}\n\n// Deserialize data we've inserted into a value column/field. We place\n// special markers into our strings to mark them as encoded; this isn't\n// as nice as a meta field, but it's the only sane thing we can do whilst\n// keeping localStorage support intact.\n//\n// Oftentimes this will just deserialize JSON content, but if we have a\n// special marker (SERIALIZED_MARKER, defined above), we will extract\n// some kind of arraybuffer/binary data/typed array out of the string.\nfunction deserialize(value) {\n    // If we haven't marked this string as being specially serialized (i.e.\n    // something other than serialized JSON), we can just return it and be\n    // done with it.\n    if (value.substring(0, SERIALIZED_MARKER_LENGTH) !== SERIALIZED_MARKER) {\n        return JSON.parse(value);\n    }\n\n    // The following code deals with deserializing some kind of Blob or\n    // TypedArray. First we separate out the type of data we're dealing\n    // with from the data itself.\n    var serializedString = value.substring(TYPE_SERIALIZED_MARKER_LENGTH);\n    var type = value.substring(SERIALIZED_MARKER_LENGTH, TYPE_SERIALIZED_MARKER_LENGTH);\n\n    var blobType;\n    // Backwards-compatible blob type serialization strategy.\n    // DBs created with older versions of localForage will simply not have the blob type.\n    if (type === TYPE_BLOB && BLOB_TYPE_PREFIX_REGEX.test(serializedString)) {\n        var matcher = serializedString.match(BLOB_TYPE_PREFIX_REGEX);\n        blobType = matcher[1];\n        serializedString = serializedString.substring(matcher[0].length);\n    }\n    var buffer = stringToBuffer(serializedString);\n\n    // Return the right type based on the code/type set during\n    // serialization.\n    switch (type) {\n        case TYPE_ARRAYBUFFER:\n            return buffer;\n        case TYPE_BLOB:\n            return createBlob([buffer], { type: blobType });\n        case TYPE_INT8ARRAY:\n            return new Int8Array(buffer);\n        case TYPE_UINT8ARRAY:\n            return new Uint8Array(buffer);\n        case TYPE_UINT8CLAMPEDARRAY:\n            return new Uint8ClampedArray(buffer);\n        case TYPE_INT16ARRAY:\n            return new Int16Array(buffer);\n        case TYPE_UINT16ARRAY:\n            return new Uint16Array(buffer);\n        case TYPE_INT32ARRAY:\n            return new Int32Array(buffer);\n        case TYPE_UINT32ARRAY:\n            return new Uint32Array(buffer);\n        case TYPE_FLOAT32ARRAY:\n            return new Float32Array(buffer);\n        case TYPE_FLOAT64ARRAY:\n            return new Float64Array(buffer);\n        default:\n            throw new Error('Unkown type: ' + type);\n    }\n}\n\nvar localforageSerializer = {\n    serialize: serialize,\n    deserialize: deserialize,\n    stringToBuffer: stringToBuffer,\n    bufferToString: bufferToString\n};\n\n/*\n * Includes code from:\n *\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n\nfunction createDbTable(t, dbInfo, callback, errorCallback) {\n    t.executeSql('CREATE TABLE IF NOT EXISTS ' + dbInfo.storeName + ' ' + '(id INTEGER PRIMARY KEY, key unique, value)', [], callback, errorCallback);\n}\n\n// Open the WebSQL database (automatically creates one if one didn't\n// previously exist), using any options set in the config.\nfunction _initStorage$1(options) {\n    var self = this;\n    var dbInfo = {\n        db: null\n    };\n\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = typeof options[i] !== 'string' ? options[i].toString() : options[i];\n        }\n    }\n\n    var dbInfoPromise = new Promise$1(function (resolve, reject) {\n        // Open the database; the openDatabase API will automatically\n        // create it for us if it doesn't exist.\n        try {\n            dbInfo.db = openDatabase(dbInfo.name, String(dbInfo.version), dbInfo.description, dbInfo.size);\n        } catch (e) {\n            return reject(e);\n        }\n\n        // Create our key/value table if it doesn't exist.\n        dbInfo.db.transaction(function (t) {\n            createDbTable(t, dbInfo, function () {\n                self._dbInfo = dbInfo;\n                resolve();\n            }, function (t, error) {\n                reject(error);\n            });\n        }, reject);\n    });\n\n    dbInfo.serializer = localforageSerializer;\n    return dbInfoPromise;\n}\n\nfunction tryExecuteSql(t, dbInfo, sqlStatement, args, callback, errorCallback) {\n    t.executeSql(sqlStatement, args, callback, function (t, error) {\n        if (error.code === error.SYNTAX_ERR) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name = ?\", [dbInfo.storeName], function (t, results) {\n                if (!results.rows.length) {\n                    // if the table is missing (was deleted)\n                    // re-create it table and retry\n                    createDbTable(t, dbInfo, function () {\n                        t.executeSql(sqlStatement, args, callback, errorCallback);\n                    }, errorCallback);\n                } else {\n                    errorCallback(t, error);\n                }\n            }, errorCallback);\n        } else {\n            errorCallback(t, error);\n        }\n    }, errorCallback);\n}\n\nfunction getItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName + ' WHERE key = ? LIMIT 1', [key], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).value : null;\n\n                    // Check to see if this is serialized content we need to\n                    // unpack.\n                    if (result) {\n                        result = dbInfo.serializer.deserialize(result);\n                    }\n\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction iterate$1(iterator, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT * FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var rows = results.rows;\n                    var length = rows.length;\n\n                    for (var i = 0; i < length; i++) {\n                        var item = rows.item(i);\n                        var result = item.value;\n\n                        // Check to see if this is serialized content\n                        // we need to unpack.\n                        if (result) {\n                            result = dbInfo.serializer.deserialize(result);\n                        }\n\n                        result = iterator(result, item.key, i + 1);\n\n                        // void(0) prevents problems with redefinition\n                        // of `undefined`.\n                        if (result !== void 0) {\n                            resolve(result);\n                            return;\n                        }\n                    }\n\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction _setItem(key, value, callback, retriesLeft) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            // The localStorage API doesn't return undefined values in an\n            // \"expected\" way, so undefined is always cast to null in all\n            // drivers. See: https://github.com/mozilla/localForage/pull/42\n            if (value === undefined) {\n                value = null;\n            }\n\n            // Save the original value to pass to the callback.\n            var originalValue = value;\n\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    dbInfo.db.transaction(function (t) {\n                        tryExecuteSql(t, dbInfo, 'INSERT OR REPLACE INTO ' + dbInfo.storeName + ' ' + '(key, value) VALUES (?, ?)', [key, value], function () {\n                            resolve(originalValue);\n                        }, function (t, error) {\n                            reject(error);\n                        });\n                    }, function (sqlError) {\n                        // The transaction failed; check\n                        // to see if it's a quota error.\n                        if (sqlError.code === sqlError.QUOTA_ERR) {\n                            // We reject the callback outright for now, but\n                            // it's worth trying to re-run the transaction.\n                            // Even if the user accepts the prompt to use\n                            // more storage on Safari, this error will\n                            // be called.\n                            //\n                            // Try to re-run the transaction.\n                            if (retriesLeft > 0) {\n                                resolve(_setItem.apply(self, [key, originalValue, callback, retriesLeft - 1]));\n                                return;\n                            }\n                            reject(sqlError);\n                        }\n                    });\n                }\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction setItem$1(key, value, callback) {\n    return _setItem.apply(this, [key, value, callback, 1]);\n}\n\nfunction removeItem$1(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName + ' WHERE key = ?', [key], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Deletes every item in the table.\n// TODO: Find out if this resets the AUTO_INCREMENT number.\nfunction clear$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'DELETE FROM ' + dbInfo.storeName, [], function () {\n                    resolve();\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Does a simple `COUNT(key)` to get the number of items stored in\n// localForage.\nfunction length$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                // Ahhh, SQL makes this one soooooo easy.\n                tryExecuteSql(t, dbInfo, 'SELECT COUNT(key) as c FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var result = results.rows.item(0).c;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Return the key located at key index X; essentially gets the key from a\n// `WHERE id = ?`. This is the most efficient way I can think to implement\n// this rarely-used (in my experience) part of the API, but it can seem\n// inconsistent, because we do `INSERT OR REPLACE INTO` on `setItem()`, so\n// the ID of each key will change every time it's updated. Perhaps a stored\n// procedure for the `setItem()` SQL would solve this problem?\n// TODO: Don't change ID on `setItem()`.\nfunction key$1(n, callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName + ' WHERE id = ? LIMIT 1', [n + 1], function (t, results) {\n                    var result = results.rows.length ? results.rows.item(0).key : null;\n                    resolve(result);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$1(callback) {\n    var self = this;\n\n    var promise = new Promise$1(function (resolve, reject) {\n        self.ready().then(function () {\n            var dbInfo = self._dbInfo;\n            dbInfo.db.transaction(function (t) {\n                tryExecuteSql(t, dbInfo, 'SELECT key FROM ' + dbInfo.storeName, [], function (t, results) {\n                    var keys = [];\n\n                    for (var i = 0; i < results.rows.length; i++) {\n                        keys.push(results.rows.item(i).key);\n                    }\n\n                    resolve(keys);\n                }, function (t, error) {\n                    reject(error);\n                });\n            });\n        })[\"catch\"](reject);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// https://www.w3.org/TR/webdatabase/#databases\n// > There is no way to enumerate or delete the databases available for an origin from this API.\nfunction getAllStoreNames(db) {\n    return new Promise$1(function (resolve, reject) {\n        db.transaction(function (t) {\n            t.executeSql('SELECT name FROM sqlite_master ' + \"WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'\", [], function (t, results) {\n                var storeNames = [];\n\n                for (var i = 0; i < results.rows.length; i++) {\n                    storeNames.push(results.rows.item(i).name);\n                }\n\n                resolve({\n                    db: db,\n                    storeNames: storeNames\n                });\n            }, function (t, error) {\n                reject(error);\n            });\n        }, function (sqlError) {\n            reject(sqlError);\n        });\n    });\n}\n\nfunction dropInstance$1(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    var currentConfig = this.config();\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            var db;\n            if (options.name === currentConfig.name) {\n                // use the db reference of the current instance\n                db = self._dbInfo.db;\n            } else {\n                db = openDatabase(options.name, '', '', 0);\n            }\n\n            if (!options.storeName) {\n                // drop all database tables\n                resolve(getAllStoreNames(db));\n            } else {\n                resolve({\n                    db: db,\n                    storeNames: [options.storeName]\n                });\n            }\n        }).then(function (operationInfo) {\n            return new Promise$1(function (resolve, reject) {\n                operationInfo.db.transaction(function (t) {\n                    function dropTable(storeName) {\n                        return new Promise$1(function (resolve, reject) {\n                            t.executeSql('DROP TABLE IF EXISTS ' + storeName, [], function () {\n                                resolve();\n                            }, function (t, error) {\n                                reject(error);\n                            });\n                        });\n                    }\n\n                    var operations = [];\n                    for (var i = 0, len = operationInfo.storeNames.length; i < len; i++) {\n                        operations.push(dropTable(operationInfo.storeNames[i]));\n                    }\n\n                    Promise$1.all(operations).then(function () {\n                        resolve();\n                    })[\"catch\"](function (e) {\n                        reject(e);\n                    });\n                }, function (sqlError) {\n                    reject(sqlError);\n                });\n            });\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar webSQLStorage = {\n    _driver: 'webSQLStorage',\n    _initStorage: _initStorage$1,\n    _support: isWebSQLValid(),\n    iterate: iterate$1,\n    getItem: getItem$1,\n    setItem: setItem$1,\n    removeItem: removeItem$1,\n    clear: clear$1,\n    length: length$1,\n    key: key$1,\n    keys: keys$1,\n    dropInstance: dropInstance$1\n};\n\nfunction isLocalStorageValid() {\n    try {\n        return typeof localStorage !== 'undefined' && 'setItem' in localStorage &&\n        // in IE8 typeof localStorage.setItem === 'object'\n        !!localStorage.setItem;\n    } catch (e) {\n        return false;\n    }\n}\n\nfunction _getKeyPrefix(options, defaultConfig) {\n    var keyPrefix = options.name + '/';\n\n    if (options.storeName !== defaultConfig.storeName) {\n        keyPrefix += options.storeName + '/';\n    }\n    return keyPrefix;\n}\n\n// Check if localStorage throws when saving an item\nfunction checkIfLocalStorageThrows() {\n    var localStorageTestKey = '_localforage_support_test';\n\n    try {\n        localStorage.setItem(localStorageTestKey, true);\n        localStorage.removeItem(localStorageTestKey);\n\n        return false;\n    } catch (e) {\n        return true;\n    }\n}\n\n// Check if localStorage is usable and allows to save an item\n// This method checks if localStorage is usable in Safari Private Browsing\n// mode, or in any other case where the available quota for localStorage\n// is 0 and there wasn't any saved items yet.\nfunction _isLocalStorageUsable() {\n    return !checkIfLocalStorageThrows() || localStorage.length > 0;\n}\n\n// Config the localStorage backend, using options set in the config.\nfunction _initStorage$2(options) {\n    var self = this;\n    var dbInfo = {};\n    if (options) {\n        for (var i in options) {\n            dbInfo[i] = options[i];\n        }\n    }\n\n    dbInfo.keyPrefix = _getKeyPrefix(options, self._defaultConfig);\n\n    if (!_isLocalStorageUsable()) {\n        return Promise$1.reject();\n    }\n\n    self._dbInfo = dbInfo;\n    dbInfo.serializer = localforageSerializer;\n\n    return Promise$1.resolve();\n}\n\n// Remove all keys from the datastore, effectively destroying all data in\n// the app's key/value store!\nfunction clear$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var keyPrefix = self._dbInfo.keyPrefix;\n\n        for (var i = localStorage.length - 1; i >= 0; i--) {\n            var key = localStorage.key(i);\n\n            if (key.indexOf(keyPrefix) === 0) {\n                localStorage.removeItem(key);\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Retrieve an item from the store. Unlike the original async_storage\n// library in Gaia, we don't modify return values at all. If a key's value\n// is `undefined`, we pass that value to the callback function.\nfunction getItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result = localStorage.getItem(dbInfo.keyPrefix + key);\n\n        // If a result was found, parse it from the serialized\n        // string into a JS object. If result isn't truthy, the key\n        // is likely undefined and we'll pass it straight to the\n        // callback.\n        if (result) {\n            result = dbInfo.serializer.deserialize(result);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Iterate over all items in the store.\nfunction iterate$2(iterator, callback) {\n    var self = this;\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var keyPrefix = dbInfo.keyPrefix;\n        var keyPrefixLength = keyPrefix.length;\n        var length = localStorage.length;\n\n        // We use a dedicated iterator instead of the `i` variable below\n        // so other keys we fetch in localStorage aren't counted in\n        // the `iterationNumber` argument passed to the `iterate()`\n        // callback.\n        //\n        // See: github.com/mozilla/localForage/pull/435#discussion_r38061530\n        var iterationNumber = 1;\n\n        for (var i = 0; i < length; i++) {\n            var key = localStorage.key(i);\n            if (key.indexOf(keyPrefix) !== 0) {\n                continue;\n            }\n            var value = localStorage.getItem(key);\n\n            // If a result was found, parse it from the serialized\n            // string into a JS object. If result isn't truthy, the\n            // key is likely undefined and we'll pass it straight\n            // to the iterator.\n            if (value) {\n                value = dbInfo.serializer.deserialize(value);\n            }\n\n            value = iterator(value, key.substring(keyPrefixLength), iterationNumber++);\n\n            if (value !== void 0) {\n                return value;\n            }\n        }\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Same as localStorage's key() method, except takes a callback.\nfunction key$2(n, callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var result;\n        try {\n            result = localStorage.key(n);\n        } catch (error) {\n            result = null;\n        }\n\n        // Remove the prefix from the key, if a key is found.\n        if (result) {\n            result = result.substring(dbInfo.keyPrefix.length);\n        }\n\n        return result;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction keys$2(callback) {\n    var self = this;\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        var length = localStorage.length;\n        var keys = [];\n\n        for (var i = 0; i < length; i++) {\n            var itemKey = localStorage.key(i);\n            if (itemKey.indexOf(dbInfo.keyPrefix) === 0) {\n                keys.push(itemKey.substring(dbInfo.keyPrefix.length));\n            }\n        }\n\n        return keys;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Supply the number of keys in the datastore to the callback function.\nfunction length$2(callback) {\n    var self = this;\n    var promise = self.keys().then(function (keys) {\n        return keys.length;\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Remove an item from the store, nice and simple.\nfunction removeItem$2(key, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        var dbInfo = self._dbInfo;\n        localStorage.removeItem(dbInfo.keyPrefix + key);\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\n// Set a key's value and run an optional callback once the value is set.\n// Unlike Gaia's implementation, the callback function is passed the value,\n// in case you want to operate on that value only after you're sure it\n// saved, or something like that.\nfunction setItem$2(key, value, callback) {\n    var self = this;\n\n    key = normalizeKey(key);\n\n    var promise = self.ready().then(function () {\n        // Convert undefined values to null.\n        // https://github.com/mozilla/localForage/pull/42\n        if (value === undefined) {\n            value = null;\n        }\n\n        // Save the original value to pass to the callback.\n        var originalValue = value;\n\n        return new Promise$1(function (resolve, reject) {\n            var dbInfo = self._dbInfo;\n            dbInfo.serializer.serialize(value, function (value, error) {\n                if (error) {\n                    reject(error);\n                } else {\n                    try {\n                        localStorage.setItem(dbInfo.keyPrefix + key, value);\n                        resolve(originalValue);\n                    } catch (e) {\n                        // localStorage capacity exceeded.\n                        // TODO: Make this a specific error/event.\n                        if (e.name === 'QuotaExceededError' || e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n                            reject(e);\n                        }\n                        reject(e);\n                    }\n                }\n            });\n        });\n    });\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nfunction dropInstance$2(options, callback) {\n    callback = getCallback.apply(this, arguments);\n\n    options = typeof options !== 'function' && options || {};\n    if (!options.name) {\n        var currentConfig = this.config();\n        options.name = options.name || currentConfig.name;\n        options.storeName = options.storeName || currentConfig.storeName;\n    }\n\n    var self = this;\n    var promise;\n    if (!options.name) {\n        promise = Promise$1.reject('Invalid arguments');\n    } else {\n        promise = new Promise$1(function (resolve) {\n            if (!options.storeName) {\n                resolve(options.name + '/');\n            } else {\n                resolve(_getKeyPrefix(options, self._defaultConfig));\n            }\n        }).then(function (keyPrefix) {\n            for (var i = localStorage.length - 1; i >= 0; i--) {\n                var key = localStorage.key(i);\n\n                if (key.indexOf(keyPrefix) === 0) {\n                    localStorage.removeItem(key);\n                }\n            }\n        });\n    }\n\n    executeCallback(promise, callback);\n    return promise;\n}\n\nvar localStorageWrapper = {\n    _driver: 'localStorageWrapper',\n    _initStorage: _initStorage$2,\n    _support: isLocalStorageValid(),\n    iterate: iterate$2,\n    getItem: getItem$2,\n    setItem: setItem$2,\n    removeItem: removeItem$2,\n    clear: clear$2,\n    length: length$2,\n    key: key$2,\n    keys: keys$2,\n    dropInstance: dropInstance$2\n};\n\nvar sameValue = function sameValue(x, y) {\n    return x === y || typeof x === 'number' && typeof y === 'number' && isNaN(x) && isNaN(y);\n};\n\nvar includes = function includes(array, searchElement) {\n    var len = array.length;\n    var i = 0;\n    while (i < len) {\n        if (sameValue(array[i], searchElement)) {\n            return true;\n        }\n        i++;\n    }\n\n    return false;\n};\n\nvar isArray = Array.isArray || function (arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]';\n};\n\n// Drivers are stored here when `defineDriver()` is called.\n// They are shared across all instances of localForage.\nvar DefinedDrivers = {};\n\nvar DriverSupport = {};\n\nvar DefaultDrivers = {\n    INDEXEDDB: asyncStorage,\n    WEBSQL: webSQLStorage,\n    LOCALSTORAGE: localStorageWrapper\n};\n\nvar DefaultDriverOrder = [DefaultDrivers.INDEXEDDB._driver, DefaultDrivers.WEBSQL._driver, DefaultDrivers.LOCALSTORAGE._driver];\n\nvar OptionalDriverMethods = ['dropInstance'];\n\nvar LibraryMethods = ['clear', 'getItem', 'iterate', 'key', 'keys', 'length', 'removeItem', 'setItem'].concat(OptionalDriverMethods);\n\nvar DefaultConfig = {\n    description: '',\n    driver: DefaultDriverOrder.slice(),\n    name: 'localforage',\n    // Default DB size is _JUST UNDER_ 5MB, as it's the highest size\n    // we can use without a prompt.\n    size: 4980736,\n    storeName: 'keyvaluepairs',\n    version: 1.0\n};\n\nfunction callWhenReady(localForageInstance, libraryMethod) {\n    localForageInstance[libraryMethod] = function () {\n        var _args = arguments;\n        return localForageInstance.ready().then(function () {\n            return localForageInstance[libraryMethod].apply(localForageInstance, _args);\n        });\n    };\n}\n\nfunction extend() {\n    for (var i = 1; i < arguments.length; i++) {\n        var arg = arguments[i];\n\n        if (arg) {\n            for (var _key in arg) {\n                if (arg.hasOwnProperty(_key)) {\n                    if (isArray(arg[_key])) {\n                        arguments[0][_key] = arg[_key].slice();\n                    } else {\n                        arguments[0][_key] = arg[_key];\n                    }\n                }\n            }\n        }\n    }\n\n    return arguments[0];\n}\n\nvar LocalForage = function () {\n    function LocalForage(options) {\n        _classCallCheck(this, LocalForage);\n\n        for (var driverTypeKey in DefaultDrivers) {\n            if (DefaultDrivers.hasOwnProperty(driverTypeKey)) {\n                var driver = DefaultDrivers[driverTypeKey];\n                var driverName = driver._driver;\n                this[driverTypeKey] = driverName;\n\n                if (!DefinedDrivers[driverName]) {\n                    // we don't need to wait for the promise,\n                    // since the default drivers can be defined\n                    // in a blocking manner\n                    this.defineDriver(driver);\n                }\n            }\n        }\n\n        this._defaultConfig = extend({}, DefaultConfig);\n        this._config = extend({}, this._defaultConfig, options);\n        this._driverSet = null;\n        this._initDriver = null;\n        this._ready = false;\n        this._dbInfo = null;\n\n        this._wrapLibraryMethodsWithReady();\n        this.setDriver(this._config.driver)[\"catch\"](function () {});\n    }\n\n    // Set any config values for localForage; can be called anytime before\n    // the first API call (e.g. `getItem`, `setItem`).\n    // We loop through options so we don't overwrite existing config\n    // values.\n\n\n    LocalForage.prototype.config = function config(options) {\n        // If the options argument is an object, we use it to set values.\n        // Otherwise, we return either a specified config value or all\n        // config values.\n        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object') {\n            // If localforage is ready and fully initialized, we can't set\n            // any new configuration values. Instead, we return an error.\n            if (this._ready) {\n                return new Error(\"Can't call config() after localforage \" + 'has been used.');\n            }\n\n            for (var i in options) {\n                if (i === 'storeName') {\n                    options[i] = options[i].replace(/\\W/g, '_');\n                }\n\n                if (i === 'version' && typeof options[i] !== 'number') {\n                    return new Error('Database version must be a number.');\n                }\n\n                this._config[i] = options[i];\n            }\n\n            // after all config options are set and\n            // the driver option is used, try setting it\n            if ('driver' in options && options.driver) {\n                return this.setDriver(this._config.driver);\n            }\n\n            return true;\n        } else if (typeof options === 'string') {\n            return this._config[options];\n        } else {\n            return this._config;\n        }\n    };\n\n    // Used to define a custom driver, shared across all instances of\n    // localForage.\n\n\n    LocalForage.prototype.defineDriver = function defineDriver(driverObject, callback, errorCallback) {\n        var promise = new Promise$1(function (resolve, reject) {\n            try {\n                var driverName = driverObject._driver;\n                var complianceError = new Error('Custom driver not compliant; see ' + 'https://mozilla.github.io/localForage/#definedriver');\n\n                // A driver name should be defined and not overlap with the\n                // library-defined, default drivers.\n                if (!driverObject._driver) {\n                    reject(complianceError);\n                    return;\n                }\n\n                var driverMethods = LibraryMethods.concat('_initStorage');\n                for (var i = 0, len = driverMethods.length; i < len; i++) {\n                    var driverMethodName = driverMethods[i];\n\n                    // when the property is there,\n                    // it should be a method even when optional\n                    var isRequired = !includes(OptionalDriverMethods, driverMethodName);\n                    if ((isRequired || driverObject[driverMethodName]) && typeof driverObject[driverMethodName] !== 'function') {\n                        reject(complianceError);\n                        return;\n                    }\n                }\n\n                var configureMissingMethods = function configureMissingMethods() {\n                    var methodNotImplementedFactory = function methodNotImplementedFactory(methodName) {\n                        return function () {\n                            var error = new Error('Method ' + methodName + ' is not implemented by the current driver');\n                            var promise = Promise$1.reject(error);\n                            executeCallback(promise, arguments[arguments.length - 1]);\n                            return promise;\n                        };\n                    };\n\n                    for (var _i = 0, _len = OptionalDriverMethods.length; _i < _len; _i++) {\n                        var optionalDriverMethod = OptionalDriverMethods[_i];\n                        if (!driverObject[optionalDriverMethod]) {\n                            driverObject[optionalDriverMethod] = methodNotImplementedFactory(optionalDriverMethod);\n                        }\n                    }\n                };\n\n                configureMissingMethods();\n\n                var setDriverSupport = function setDriverSupport(support) {\n                    if (DefinedDrivers[driverName]) {\n                        console.info('Redefining LocalForage driver: ' + driverName);\n                    }\n                    DefinedDrivers[driverName] = driverObject;\n                    DriverSupport[driverName] = support;\n                    // don't use a then, so that we can define\n                    // drivers that have simple _support methods\n                    // in a blocking manner\n                    resolve();\n                };\n\n                if ('_support' in driverObject) {\n                    if (driverObject._support && typeof driverObject._support === 'function') {\n                        driverObject._support().then(setDriverSupport, reject);\n                    } else {\n                        setDriverSupport(!!driverObject._support);\n                    }\n                } else {\n                    setDriverSupport(true);\n                }\n            } catch (e) {\n                reject(e);\n            }\n        });\n\n        executeTwoCallbacks(promise, callback, errorCallback);\n        return promise;\n    };\n\n    LocalForage.prototype.driver = function driver() {\n        return this._driver || null;\n    };\n\n    LocalForage.prototype.getDriver = function getDriver(driverName, callback, errorCallback) {\n        var getDriverPromise = DefinedDrivers[driverName] ? Promise$1.resolve(DefinedDrivers[driverName]) : Promise$1.reject(new Error('Driver not found.'));\n\n        executeTwoCallbacks(getDriverPromise, callback, errorCallback);\n        return getDriverPromise;\n    };\n\n    LocalForage.prototype.getSerializer = function getSerializer(callback) {\n        var serializerPromise = Promise$1.resolve(localforageSerializer);\n        executeTwoCallbacks(serializerPromise, callback);\n        return serializerPromise;\n    };\n\n    LocalForage.prototype.ready = function ready(callback) {\n        var self = this;\n\n        var promise = self._driverSet.then(function () {\n            if (self._ready === null) {\n                self._ready = self._initDriver();\n            }\n\n            return self._ready;\n        });\n\n        executeTwoCallbacks(promise, callback, callback);\n        return promise;\n    };\n\n    LocalForage.prototype.setDriver = function setDriver(drivers, callback, errorCallback) {\n        var self = this;\n\n        if (!isArray(drivers)) {\n            drivers = [drivers];\n        }\n\n        var supportedDrivers = this._getSupportedDrivers(drivers);\n\n        function setDriverToConfig() {\n            self._config.driver = self.driver();\n        }\n\n        function extendSelfWithDriver(driver) {\n            self._extend(driver);\n            setDriverToConfig();\n\n            self._ready = self._initStorage(self._config);\n            return self._ready;\n        }\n\n        function initDriver(supportedDrivers) {\n            return function () {\n                var currentDriverIndex = 0;\n\n                function driverPromiseLoop() {\n                    while (currentDriverIndex < supportedDrivers.length) {\n                        var driverName = supportedDrivers[currentDriverIndex];\n                        currentDriverIndex++;\n\n                        self._dbInfo = null;\n                        self._ready = null;\n\n                        return self.getDriver(driverName).then(extendSelfWithDriver)[\"catch\"](driverPromiseLoop);\n                    }\n\n                    setDriverToConfig();\n                    var error = new Error('No available storage method found.');\n                    self._driverSet = Promise$1.reject(error);\n                    return self._driverSet;\n                }\n\n                return driverPromiseLoop();\n            };\n        }\n\n        // There might be a driver initialization in progress\n        // so wait for it to finish in order to avoid a possible\n        // race condition to set _dbInfo\n        var oldDriverSetDone = this._driverSet !== null ? this._driverSet[\"catch\"](function () {\n            return Promise$1.resolve();\n        }) : Promise$1.resolve();\n\n        this._driverSet = oldDriverSetDone.then(function () {\n            var driverName = supportedDrivers[0];\n            self._dbInfo = null;\n            self._ready = null;\n\n            return self.getDriver(driverName).then(function (driver) {\n                self._driver = driver._driver;\n                setDriverToConfig();\n                self._wrapLibraryMethodsWithReady();\n                self._initDriver = initDriver(supportedDrivers);\n            });\n        })[\"catch\"](function () {\n            setDriverToConfig();\n            var error = new Error('No available storage method found.');\n            self._driverSet = Promise$1.reject(error);\n            return self._driverSet;\n        });\n\n        executeTwoCallbacks(this._driverSet, callback, errorCallback);\n        return this._driverSet;\n    };\n\n    LocalForage.prototype.supports = function supports(driverName) {\n        return !!DriverSupport[driverName];\n    };\n\n    LocalForage.prototype._extend = function _extend(libraryMethodsAndProperties) {\n        extend(this, libraryMethodsAndProperties);\n    };\n\n    LocalForage.prototype._getSupportedDrivers = function _getSupportedDrivers(drivers) {\n        var supportedDrivers = [];\n        for (var i = 0, len = drivers.length; i < len; i++) {\n            var driverName = drivers[i];\n            if (this.supports(driverName)) {\n                supportedDrivers.push(driverName);\n            }\n        }\n        return supportedDrivers;\n    };\n\n    LocalForage.prototype._wrapLibraryMethodsWithReady = function _wrapLibraryMethodsWithReady() {\n        // Add a stub for each driver API method that delays the call to the\n        // corresponding driver method until localForage is ready. These stubs\n        // will be replaced by the driver methods as soon as the driver is\n        // loaded, so there is no performance impact.\n        for (var i = 0, len = LibraryMethods.length; i < len; i++) {\n            callWhenReady(this, LibraryMethods[i]);\n        }\n    };\n\n    LocalForage.prototype.createInstance = function createInstance(options) {\n        return new LocalForage(options);\n    };\n\n    return LocalForage;\n}();\n\n// The actual localForage object that we expose as a module or via a\n// global. It's extended by pulling in one of our other libraries.\n\n\nvar localforage_js = new LocalForage();\n\nmodule.exports = localforage_js;\n\n},{\"3\":3}]},{},[4])(4)\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../next/dist/compiled/webpack/global.js */ \"../../node_modules/next/dist/compiled/webpack/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL2xvY2FsZm9yYWdlL2Rpc3QvbG9jYWxmb3JhZ2UuanM/NjUwYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUcsSUFBc0QsRUFBRSxtQkFBbUIsS0FBSyxVQUFvTyxDQUFDLGFBQWEsMEJBQTBCLDBCQUEwQixnQkFBZ0IsVUFBVSxVQUFVLDBDQUEwQyxnQkFBZ0IsT0FBQyxPQUFPLG9CQUFvQiw4Q0FBOEMscUNBQXFDLFlBQVksWUFBWSxtQ0FBbUMsaUJBQWlCLGdCQUFnQixzQkFBc0Isb0JBQW9CLDBDQUEwQyxZQUFZLFdBQVcsWUFBWSxTQUFTLEdBQUc7QUFDbHpCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTtBQUN0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLE1BQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJO0FBQ3RJLENBQUMsRUFBRSxNQUFNO0FBQ1Q7O0FBRUEsb0dBQW9HLG1CQUFtQixFQUFFLG1CQUFtQiw4SEFBOEg7O0FBRTFRLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCO0FBQ3JCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtB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QUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7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QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaURBQWlELFFBQVE7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUVBQW1FO0FBQ25FOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsU0FBUztBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUUsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOzs7QUFHQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsTUFBTSxFQUFFLEdBQUc7QUFDZCxDQUFDIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9sb2NhbGZvcmFnZS9kaXN0L2xvY2FsZm9yYWdlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICAgbG9jYWxGb3JhZ2UgLS0gT2ZmbGluZSBTdG9yYWdlLCBJbXByb3ZlZFxuICAgIFZlcnNpb24gMS45LjBcbiAgICBodHRwczovL2xvY2FsZm9yYWdlLmdpdGh1Yi5pby9sb2NhbEZvcmFnZVxuICAgIChjKSAyMDEzLTIwMTcgTW96aWxsYSwgQXBhY2hlIExpY2Vuc2UgMi4wXG4qL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcubG9jYWxmb3JhZ2UgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgKGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIiwgZil9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSBfZGVyZXFfKDEpO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gSU5URVJOQUwoKSB7fVxuXG52YXIgaGFuZGxlcnMgPSB7fTtcblxudmFyIFJFSkVDVEVEID0gWydSRUpFQ1RFRCddO1xudmFyIEZVTEZJTExFRCA9IFsnRlVMRklMTEVEJ107XG52YXIgUEVORElORyA9IFsnUEVORElORyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UocmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jlc29sdmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuc3RhdGUgPSBQRU5ESU5HO1xuICB0aGlzLnF1ZXVlID0gW107XG4gIHRoaXMub3V0Y29tZSA9IHZvaWQgMDtcbiAgaWYgKHJlc29sdmVyICE9PSBJTlRFUk5BTCkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZSh0aGlzLCByZXNvbHZlcik7XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGVbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IEZVTEZJTExFRCB8fFxuICAgIHR5cGVvZiBvblJlamVjdGVkICE9PSAnZnVuY3Rpb24nICYmIHRoaXMuc3RhdGUgPT09IFJFSkVDVEVEKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihJTlRFUk5BTCk7XG4gIGlmICh0aGlzLnN0YXRlICE9PSBQRU5ESU5HKSB7XG4gICAgdmFyIHJlc29sdmVyID0gdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuICAgIHVud3JhcChwcm9taXNlLCByZXNvbHZlciwgdGhpcy5vdXRjb21lKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuZnVuY3Rpb24gUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uRnVsZmlsbGVkID0gb25GdWxmaWxsZWQ7XG4gICAgdGhpcy5jYWxsRnVsZmlsbGVkID0gdGhpcy5vdGhlckNhbGxGdWxmaWxsZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5vblJlamVjdGVkID0gb25SZWplY3RlZDtcbiAgICB0aGlzLmNhbGxSZWplY3RlZCA9IHRoaXMub3RoZXJDYWxsUmVqZWN0ZWQ7XG4gIH1cbn1cblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbEZ1bGZpbGxlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZXNvbHZlKHRoaXMucHJvbWlzZSwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUub3RoZXJDYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25GdWxmaWxsZWQsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLmNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBoYW5kbGVycy5yZWplY3QodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxSZWplY3RlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB1bndyYXAodGhpcy5wcm9taXNlLCB0aGlzLm9uUmVqZWN0ZWQsIHZhbHVlKTtcbn07XG5cbmZ1bmN0aW9uIHVud3JhcChwcm9taXNlLCBmdW5jLCB2YWx1ZSkge1xuICBpbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXR1cm5WYWx1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuVmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIGUpO1xuICAgIH1cbiAgICBpZiAocmV0dXJuVmFsdWUgPT09IHByb21pc2UpIHtcbiAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdDYW5ub3QgcmVzb2x2ZSBwcm9taXNlIHdpdGggaXRzZWxmJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJldHVyblZhbHVlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5oYW5kbGVycy5yZXNvbHZlID0gZnVuY3Rpb24gKHNlbGYsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaChnZXRUaGVuLCB2YWx1ZSk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChzZWxmLCByZXN1bHQudmFsdWUpO1xuICB9XG4gIHZhciB0aGVuYWJsZSA9IHJlc3VsdC52YWx1ZTtcblxuICBpZiAodGhlbmFibGUpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUoc2VsZiwgdGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgc2VsZi5vdXRjb21lID0gdmFsdWU7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gc2VsZi5xdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgc2VsZi5xdWV1ZVtpXS5jYWxsRnVsZmlsbGVkKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59O1xuaGFuZGxlcnMucmVqZWN0ID0gZnVuY3Rpb24gKHNlbGYsIGVycm9yKSB7XG4gIHNlbGYuc3RhdGUgPSBSRUpFQ1RFRDtcbiAgc2VsZi5vdXRjb21lID0gZXJyb3I7XG4gIHZhciBpID0gLTE7XG4gIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNlbGYucXVldWVbaV0uY2FsbFJlamVjdGVkKGVycm9yKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIC8vIE1ha2Ugc3VyZSB3ZSBvbmx5IGFjY2VzcyB0aGUgYWNjZXNzb3Igb25jZSBhcyByZXF1aXJlZCBieSB0aGUgc3BlY1xuICB2YXIgdGhlbiA9IG9iaiAmJiBvYmoudGhlbjtcbiAgaWYgKG9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gYXBweVRoZW4oKSB7XG4gICAgICB0aGVuLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSkge1xuICAvLyBFaXRoZXIgZnVsZmlsbCwgcmVqZWN0IG9yIHJlamVjdCB3aXRoIGVycm9yXG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25FcnJvcih2YWx1ZSkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBoYW5kbGVycy5yZWplY3Qoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25TdWNjZXNzKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlc29sdmUoc2VsZiwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9VbndyYXAoKSB7XG4gICAgdGhlbmFibGUob25TdWNjZXNzLCBvbkVycm9yKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSB0cnlDYXRjaCh0cnlUb1Vud3JhcCk7XG4gIGlmIChyZXN1bHQuc3RhdHVzID09PSAnZXJyb3InKSB7XG4gICAgb25FcnJvcihyZXN1bHQudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhdGNoKGZ1bmMsIHZhbHVlKSB7XG4gIHZhciBvdXQgPSB7fTtcbiAgdHJ5IHtcbiAgICBvdXQudmFsdWUgPSBmdW5jKHZhbHVlKTtcbiAgICBvdXQuc3RhdHVzID0gJ3N1Y2Nlc3MnO1xuICB9IGNhdGNoIChlKSB7XG4gICAgb3V0LnN0YXR1cyA9ICdlcnJvcic7XG4gICAgb3V0LnZhbHVlID0gZTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG5Qcm9taXNlLnJlc29sdmUgPSByZXNvbHZlO1xuZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0aGlzKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBoYW5kbGVycy5yZXNvbHZlKG5ldyB0aGlzKElOVEVSTkFMKSwgdmFsdWUpO1xufVxuXG5Qcm9taXNlLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG4gIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbn1cblxuUHJvbWlzZS5hbGwgPSBhbGw7XG5mdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIHZhbHVlcyA9IG5ldyBBcnJheShsZW4pO1xuICB2YXIgcmVzb2x2ZWQgPSAwO1xuICB2YXIgaSA9IC0xO1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgYWxsUmVzb2x2ZXIoaXRlcmFibGVbaV0sIGkpO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuICBmdW5jdGlvbiBhbGxSZXNvbHZlcih2YWx1ZSwgaSkge1xuICAgIHNlbGYucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlRnJvbUFsbCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJlc29sdmVGcm9tQWxsKG91dFZhbHVlKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvdXRWYWx1ZTtcbiAgICAgIGlmICgrK3Jlc29sdmVkID09PSBsZW4gJiYgIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucmFjZSA9IHJhY2U7XG5mdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVyYWJsZSkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICByZXR1cm4gdGhpcy5yZWplY3QobmV3IFR5cGVFcnJvcignbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgfVxuXG4gIHZhciBsZW4gPSBpdGVyYWJsZS5sZW5ndGg7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgaWYgKCFsZW4pIHtcbiAgICByZXR1cm4gdGhpcy5yZXNvbHZlKFtdKTtcbiAgfVxuXG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICByZXNvbHZlcihpdGVyYWJsZVtpXSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIHJlc29sdmVyKHZhbHVlKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgaGFuZGxlcnMucmVzb2x2ZShwcm9taXNlLCByZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbn0se1wiMVwiOjF9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcbmlmICh0eXBlb2YgZ2xvYmFsLlByb21pc2UgIT09ICdmdW5jdGlvbicpIHtcbiAgZ2xvYmFsLlByb21pc2UgPSBfZGVyZXFfKDIpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiMlwiOjJ9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBnZXRJREIoKSB7XG4gICAgLyogZ2xvYmFsIGluZGV4ZWREQix3ZWJraXRJbmRleGVkREIsbW96SW5kZXhlZERCLE9JbmRleGVkREIsbXNJbmRleGVkREIgKi9cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ZWREQiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleGVkREI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3ZWJraXRJbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Via2l0SW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbW96SW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1vekluZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIE9JbmRleGVkREIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gT0luZGV4ZWREQjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1zSW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG1zSW5kZXhlZERCO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxufVxuXG52YXIgaWRiID0gZ2V0SURCKCk7XG5cbmZ1bmN0aW9uIGlzSW5kZXhlZERCVmFsaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBJbmRleGVkREI7IGZhbGwgYmFjayB0byB2ZW5kb3ItcHJlZml4ZWQgdmVyc2lvbnNcbiAgICAgICAgLy8gaWYgbmVlZGVkLlxuICAgICAgICBpZiAoIWlkYiB8fCAhaWRiLm9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtaW1pYyBQb3VjaERCIGhlcmU7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFdlIHRlc3QgZm9yIG9wZW5EYXRhYmFzZSBiZWNhdXNlIElFIE1vYmlsZSBpZGVudGlmaWVzIGl0c2VsZlxuICAgICAgICAvLyBhcyBTYWZhcmkuIE9oIHRoZSBsdWx6Li4uXG4gICAgICAgIHZhciBpc1NhZmFyaSA9IHR5cGVvZiBvcGVuRGF0YWJhc2UgIT09ICd1bmRlZmluZWQnICYmIC8oU2FmYXJpfGlQaG9uZXxpUGFkfGlQb2QpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvQ2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvQmxhY2tCZXJyeS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG4gICAgICAgIHZhciBoYXNGZXRjaCA9IHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiBmZXRjaC50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZScpICE9PSAtMTtcblxuICAgICAgICAvLyBTYWZhcmkgPDEwLjEgZG9lcyBub3QgbWVldCBvdXIgcmVxdWlyZW1lbnRzIGZvciBJREIgc3VwcG9ydFxuICAgICAgICAvLyAoc2VlOiBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2lzc3Vlcy81NTcyKS5cbiAgICAgICAgLy8gU2FmYXJpIDEwLjEgc2hpcHBlZCB3aXRoIGZldGNoLCB3ZSBjYW4gdXNlIHRoYXQgdG8gZGV0ZWN0IGl0LlxuICAgICAgICAvLyBOb3RlOiB0aGlzIGNyZWF0ZXMgaXNzdWVzIHdpdGggYHdpbmRvdy5mZXRjaGAgcG9seWZpbGxzIGFuZFxuICAgICAgICAvLyBvdmVycmlkZXM7IHNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xvY2FsRm9yYWdlL2xvY2FsRm9yYWdlL2lzc3Vlcy84NTZcbiAgICAgICAgcmV0dXJuICghaXNTYWZhcmkgfHwgaGFzRmV0Y2gpICYmIHR5cGVvZiBpbmRleGVkREIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC8vIHNvbWUgb3V0ZGF0ZWQgaW1wbGVtZW50YXRpb25zIG9mIElEQiB0aGF0IGFwcGVhciBvbiBTYW1zdW5nXG4gICAgICAgIC8vIGFuZCBIVEMgQW5kcm9pZCBkZXZpY2VzIDw0LjQgYXJlIG1pc3NpbmcgSURCS2V5UmFuZ2VcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9pc3N1ZXMvMTI4XG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvaXNzdWVzLzI3MlxuICAgICAgICB0eXBlb2YgSURCS2V5UmFuZ2UgIT09ICd1bmRlZmluZWQnO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gQWJzdHJhY3RzIGNvbnN0cnVjdGluZyBhIEJsb2Igb2JqZWN0LCBzbyBpdCBhbHNvIHdvcmtzIGluIG9sZGVyXG4vLyBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBCbG9iIGNvbnN0cnVjdG9yLiAoaS5lLlxuLy8gb2xkIFF0V2ViS2l0IHZlcnNpb25zLCBhdCBsZWFzdCkuXG4vLyBBYnN0cmFjdHMgY29uc3RydWN0aW5nIGEgQmxvYiBvYmplY3QsIHNvIGl0IGFsc28gd29ya3MgaW4gb2xkZXJcbi8vIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0aGUgbmF0aXZlIEJsb2IgY29uc3RydWN0b3IuIChpLmUuXG4vLyBvbGQgUXRXZWJLaXQgdmVyc2lvbnMsIGF0IGxlYXN0KS5cbmZ1bmN0aW9uIGNyZWF0ZUJsb2IocGFydHMsIHByb3BlcnRpZXMpIHtcbiAgICAvKiBnbG9iYWwgQmxvYkJ1aWxkZXIsTVNCbG9iQnVpbGRlcixNb3pCbG9iQnVpbGRlcixXZWJLaXRCbG9iQnVpbGRlciAqL1xuICAgIHBhcnRzID0gcGFydHMgfHwgW107XG4gICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKHBhcnRzLCBwcm9wZXJ0aWVzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm5hbWUgIT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBCdWlsZGVyID0gdHlwZW9mIEJsb2JCdWlsZGVyICE9PSAndW5kZWZpbmVkJyA/IEJsb2JCdWlsZGVyIDogdHlwZW9mIE1TQmxvYkJ1aWxkZXIgIT09ICd1bmRlZmluZWQnID8gTVNCbG9iQnVpbGRlciA6IHR5cGVvZiBNb3pCbG9iQnVpbGRlciAhPT0gJ3VuZGVmaW5lZCcgPyBNb3pCbG9iQnVpbGRlciA6IFdlYktpdEJsb2JCdWlsZGVyO1xuICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKHBhcnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5nZXRCbG9iKHByb3BlcnRpZXMudHlwZSk7XG4gICAgfVxufVxuXG4vLyBUaGlzIGlzIENvbW1vbkpTIGJlY2F1c2UgbGllIGlzIGFuIGV4dGVybmFsIGRlcGVuZGVuY3ksIHNvIFJvbGx1cFxuLy8gY2FuIGp1c3QgaWdub3JlIGl0LlxuaWYgKHR5cGVvZiBQcm9taXNlID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEluIHRoZSBcIm5vcHJvbWlzZXNcIiBidWlsZCB0aGlzIHdpbGwganVzdCB0aHJvdyBpZiB5b3UgZG9uJ3QgaGF2ZVxuICAgIC8vIGEgZ2xvYmFsIHByb21pc2Ugb2JqZWN0LCBidXQgaXQgd291bGQgdGhyb3cgYW55d2F5IGxhdGVyLlxuICAgIF9kZXJlcV8oMyk7XG59XG52YXIgUHJvbWlzZSQxID0gUHJvbWlzZTtcblxuZnVuY3Rpb24gZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBleGVjdXRlVHdvQ2FsbGJhY2tzKHByb21pc2UsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlLnRoZW4oY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9taXNlW1wiY2F0Y2hcIl0oZXJyb3JDYWxsYmFjayk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVLZXkoa2V5KSB7XG4gICAgLy8gQ2FzdCB0aGUga2V5IHRvIGEgc3RyaW5nLCBhcyB0aGF0J3MgYWxsIHdlIGNhbiBzZXQgYXMgYSBrZXkuXG4gICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihrZXkgKyAnIHVzZWQgYXMgYSBrZXksIGJ1dCBpdCBpcyBub3QgYSBzdHJpbmcuJyk7XG4gICAgICAgIGtleSA9IFN0cmluZyhrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXk7XG59XG5cbmZ1bmN0aW9uIGdldENhbGxiYWNrKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbn1cblxuLy8gU29tZSBjb2RlIG9yaWdpbmFsbHkgZnJvbSBhc3luY19zdG9yYWdlLmpzIGluXG4vLyBbR2FpYV0oaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEtYjJnL2dhaWEpLlxuXG52YXIgREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSA9ICdsb2NhbC1mb3JhZ2UtZGV0ZWN0LWJsb2Itc3VwcG9ydCc7XG52YXIgc3VwcG9ydHNCbG9icyA9IHZvaWQgMDtcbnZhciBkYkNvbnRleHRzID0ge307XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vLyBUcmFuc2FjdGlvbiBNb2Rlc1xudmFyIFJFQURfT05MWSA9ICdyZWFkb25seSc7XG52YXIgUkVBRF9XUklURSA9ICdyZWFkd3JpdGUnO1xuXG4vLyBUcmFuc2Zvcm0gYSBiaW5hcnkgc3RyaW5nIHRvIGFuIGFycmF5IGJ1ZmZlciwgYmVjYXVzZSBvdGhlcndpc2Vcbi8vIHdlaXJkIHN0dWZmIGhhcHBlbnMgd2hlbiB5b3UgdHJ5IHRvIHdvcmsgd2l0aCB0aGUgYmluYXJ5IHN0cmluZyBkaXJlY3RseS5cbi8vIEl0IGlzIGtub3duLlxuLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE0OTY3NjQ3LyAoY29udGludWVzIG9uIG5leHQgbGluZSlcbi8vIGVuY29kZS1kZWNvZGUtaW1hZ2Utd2l0aC1iYXNlNjQtYnJlYWtzLWltYWdlICgyMDEzLTA0LTIxKVxuZnVuY3Rpb24gX2JpblN0cmluZ1RvQXJyYXlCdWZmZXIoYmluKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJpbi5sZW5ndGg7XG4gICAgdmFyIGJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYmluLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG5cbi8vXG4vLyBCbG9icyBhcmUgbm90IHN1cHBvcnRlZCBpbiBhbGwgdmVyc2lvbnMgb2YgSW5kZXhlZERCLCBub3RhYmx5XG4vLyBDaHJvbWUgPDM3IGFuZCBBbmRyb2lkIDw1LiBJbiB0aG9zZSB2ZXJzaW9ucywgc3RvcmluZyBhIGJsb2Igd2lsbCB0aHJvdy5cbi8vXG4vLyBWYXJpb3VzIG90aGVyIGJsb2IgYnVncyBleGlzdCBpbiBDaHJvbWUgdjM3LTQyIChpbmNsdXNpdmUpLlxuLy8gRGV0ZWN0aW5nIHRoZW0gaXMgZXhwZW5zaXZlIGFuZCBjb25mdXNpbmcgdG8gdXNlcnMsIGFuZCBDaHJvbWUgMzctNDJcbi8vIGlzIGF0IHZlcnkgbG93IHVzYWdlIHdvcmxkd2lkZSwgc28gd2UgZG8gYSBoYWNreSB1c2VyQWdlbnQgY2hlY2sgaW5zdGVhZC5cbi8vXG4vLyBjb250ZW50LXR5cGUgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDA4MTIwXG4vLyA0MDQgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3OTE2XG4vLyBGaWxlUmVhZGVyIGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzgzNlxuLy9cbi8vIENvZGUgYm9ycm93ZWQgZnJvbSBQb3VjaERCLiBTZWU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcG91Y2hkYi9wb3VjaGRiL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL25vZGVfbW9kdWxlcy9wb3VjaGRiLWFkYXB0ZXItaWRiL3NyYy9ibG9iU3VwcG9ydC5qc1xuLy9cbmZ1bmN0aW9uIF9jaGVja0Jsb2JTdXBwb3J0V2l0aG91dENhY2hpbmcoaWRiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgdmFyIHR4biA9IGlkYi50cmFuc2FjdGlvbihERVRFQ1RfQkxPQl9TVVBQT1JUX1NUT1JFLCBSRUFEX1dSSVRFKTtcbiAgICAgICAgdmFyIGJsb2IgPSBjcmVhdGVCbG9iKFsnJ10pO1xuICAgICAgICB0eG4ub2JqZWN0U3RvcmUoREVURUNUX0JMT0JfU1VQUE9SVF9TVE9SRSkucHV0KGJsb2IsICdrZXknKTtcblxuICAgICAgICB0eG4ub25hYm9ydCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdHJhbnNhY3Rpb24gYWJvcnRzIG5vdyBpdHMgZHVlIHRvIG5vdCBiZWluZyBhYmxlIHRvXG4gICAgICAgICAgICAvLyB3cml0ZSB0byB0aGUgZGF0YWJhc2UsIGxpa2VseSBkdWUgdG8gdGhlIGRpc2sgYmVpbmcgZnVsbFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHR4bi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWRDaHJvbWUgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICAgICAgICAgIHZhciBtYXRjaGVkRWRnZSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8vKTtcbiAgICAgICAgICAgIC8vIE1TIEVkZ2UgcHJldGVuZHMgdG8gYmUgQ2hyb21lIDQyOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDg2OTMwMSUyOHY9dnMuODUlMjkuYXNweFxuICAgICAgICAgICAgcmVzb2x2ZShtYXRjaGVkRWRnZSB8fCAhbWF0Y2hlZENocm9tZSB8fCBwYXJzZUludChtYXRjaGVkQ2hyb21lWzFdLCAxMCkgPj0gNDMpO1xuICAgICAgICB9O1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGVycm9yLCBzbyBhc3N1bWUgdW5zdXBwb3J0ZWRcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrQmxvYlN1cHBvcnQoaWRiKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0Jsb2JzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKHN1cHBvcnRzQmxvYnMpO1xuICAgIH1cbiAgICByZXR1cm4gX2NoZWNrQmxvYlN1cHBvcnRXaXRob3V0Q2FjaGluZyhpZGIpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHN1cHBvcnRzQmxvYnMgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzQmxvYnM7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9kZWZlclJlYWRpbmVzcyhkYkluZm8pIHtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IGRhdGFiYXNlIG9wZXJhdGlvbi5cbiAgICB2YXIgZGVmZXJyZWRPcGVyYXRpb24gPSB7fTtcblxuICAgIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGVmZXJyZWRPcGVyYXRpb24ucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgIGRlZmVycmVkT3BlcmF0aW9uLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIC8vIEVucXVldWUgdGhlIGRlZmVycmVkIG9wZXJhdGlvbi5cbiAgICBkYkNvbnRleHQuZGVmZXJyZWRPcGVyYXRpb25zLnB1c2goZGVmZXJyZWRPcGVyYXRpb24pO1xuXG4gICAgLy8gQ2hhaW4gaXRzIHByb21pc2UgdG8gdGhlIGRhdGFiYXNlIHJlYWRpbmVzcy5cbiAgICBpZiAoIWRiQ29udGV4dC5kYlJlYWR5KSB7XG4gICAgICAgIGRiQ29udGV4dC5kYlJlYWR5ID0gZGVmZXJyZWRPcGVyYXRpb24ucHJvbWlzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkYkNvbnRleHQuZGJSZWFkeSA9IGRiQ29udGV4dC5kYlJlYWR5LnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2FkdmFuY2VSZWFkaW5lc3MoZGJJbmZvKSB7XG4gICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdO1xuXG4gICAgLy8gRGVxdWV1ZSBhIGRlZmVycmVkIG9wZXJhdGlvbi5cbiAgICB2YXIgZGVmZXJyZWRPcGVyYXRpb24gPSBkYkNvbnRleHQuZGVmZXJyZWRPcGVyYXRpb25zLnBvcCgpO1xuXG4gICAgLy8gUmVzb2x2ZSBpdHMgcHJvbWlzZSAod2hpY2ggaXMgcGFydCBvZiB0aGUgZGF0YWJhc2UgcmVhZGluZXNzXG4gICAgLy8gY2hhaW4gb2YgcHJvbWlzZXMpLlxuICAgIGlmIChkZWZlcnJlZE9wZXJhdGlvbikge1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZE9wZXJhdGlvbi5wcm9taXNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX3JlamVjdFJlYWRpbmVzcyhkYkluZm8sIGVycikge1xuICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW2RiSW5mby5uYW1lXTtcblxuICAgIC8vIERlcXVldWUgYSBkZWZlcnJlZCBvcGVyYXRpb24uXG4gICAgdmFyIGRlZmVycmVkT3BlcmF0aW9uID0gZGJDb250ZXh0LmRlZmVycmVkT3BlcmF0aW9ucy5wb3AoKTtcblxuICAgIC8vIFJlamVjdCBpdHMgcHJvbWlzZSAod2hpY2ggaXMgcGFydCBvZiB0aGUgZGF0YWJhc2UgcmVhZGluZXNzXG4gICAgLy8gY2hhaW4gb2YgcHJvbWlzZXMpLlxuICAgIGlmIChkZWZlcnJlZE9wZXJhdGlvbikge1xuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbi5yZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkT3BlcmF0aW9uLnByb21pc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0Q29ubmVjdGlvbihkYkluZm8sIHVwZ3JhZGVOZWVkZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGRiQ29udGV4dHNbZGJJbmZvLm5hbWVdID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV0gfHwgY3JlYXRlRGJDb250ZXh0KCk7XG5cbiAgICAgICAgaWYgKGRiSW5mby5kYikge1xuICAgICAgICAgICAgaWYgKHVwZ3JhZGVOZWVkZWQpIHtcbiAgICAgICAgICAgICAgICBfZGVmZXJSZWFkaW5lc3MoZGJJbmZvKTtcbiAgICAgICAgICAgICAgICBkYkluZm8uZGIuY2xvc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoZGJJbmZvLmRiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYkFyZ3MgPSBbZGJJbmZvLm5hbWVdO1xuXG4gICAgICAgIGlmICh1cGdyYWRlTmVlZGVkKSB7XG4gICAgICAgICAgICBkYkFyZ3MucHVzaChkYkluZm8udmVyc2lvbik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3BlbnJlcSA9IGlkYi5vcGVuLmFwcGx5KGlkYiwgZGJBcmdzKTtcblxuICAgICAgICBpZiAodXBncmFkZU5lZWRlZCkge1xuICAgICAgICAgICAgb3BlbnJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciBkYiA9IG9wZW5yZXEucmVzdWx0O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKGRiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5vbGRWZXJzaW9uIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZGVkIHdoZW4gc3VwcG9ydCBmb3IgYmxvYiBzaGltcyB3YXMgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKERFVEVDVF9CTE9CX1NVUFBPUlRfU1RPUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Lm5hbWUgPT09ICdDb25zdHJhaW50RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBkYXRhYmFzZSBcIicgKyBkYkluZm8ubmFtZSArICdcIicgKyAnIGhhcyBiZWVuIHVwZ3JhZGVkIGZyb20gdmVyc2lvbiAnICsgZS5vbGRWZXJzaW9uICsgJyB0byB2ZXJzaW9uICcgKyBlLm5ld1ZlcnNpb24gKyAnLCBidXQgdGhlIHN0b3JhZ2UgXCInICsgZGJJbmZvLnN0b3JlTmFtZSArICdcIiBhbHJlYWR5IGV4aXN0cy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wZW5yZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICByZWplY3Qob3BlbnJlcS5lcnJvcik7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlbnJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKG9wZW5yZXEucmVzdWx0KTtcbiAgICAgICAgICAgIF9hZHZhbmNlUmVhZGluZXNzKGRiSW5mbyk7XG4gICAgICAgIH07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRPcmlnaW5hbENvbm5lY3Rpb24oZGJJbmZvKSB7XG4gICAgcmV0dXJuIF9nZXRDb25uZWN0aW9uKGRiSW5mbywgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbykge1xuICAgIHJldHVybiBfZ2V0Q29ubmVjdGlvbihkYkluZm8sIHRydWUpO1xufVxuXG5mdW5jdGlvbiBfaXNVcGdyYWRlTmVlZGVkKGRiSW5mbywgZGVmYXVsdFZlcnNpb24pIHtcbiAgICBpZiAoIWRiSW5mby5kYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNOZXdTdG9yZSA9ICFkYkluZm8uZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhkYkluZm8uc3RvcmVOYW1lKTtcbiAgICB2YXIgaXNEb3duZ3JhZGUgPSBkYkluZm8udmVyc2lvbiA8IGRiSW5mby5kYi52ZXJzaW9uO1xuICAgIHZhciBpc1VwZ3JhZGUgPSBkYkluZm8udmVyc2lvbiA+IGRiSW5mby5kYi52ZXJzaW9uO1xuXG4gICAgaWYgKGlzRG93bmdyYWRlKSB7XG4gICAgICAgIC8vIElmIHRoZSB2ZXJzaW9uIGlzIG5vdCB0aGUgZGVmYXVsdCBvbmVcbiAgICAgICAgLy8gdGhlbiB3YXJuIGZvciBpbXBvc3NpYmxlIGRvd25ncmFkZS5cbiAgICAgICAgaWYgKGRiSW5mby52ZXJzaW9uICE9PSBkZWZhdWx0VmVyc2lvbikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZGF0YWJhc2UgXCInICsgZGJJbmZvLm5hbWUgKyAnXCInICsgXCIgY2FuJ3QgYmUgZG93bmdyYWRlZCBmcm9tIHZlcnNpb24gXCIgKyBkYkluZm8uZGIudmVyc2lvbiArICcgdG8gdmVyc2lvbiAnICsgZGJJbmZvLnZlcnNpb24gKyAnLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsaWduIHRoZSB2ZXJzaW9ucyB0byBwcmV2ZW50IGVycm9ycy5cbiAgICAgICAgZGJJbmZvLnZlcnNpb24gPSBkYkluZm8uZGIudmVyc2lvbjtcbiAgICB9XG5cbiAgICBpZiAoaXNVcGdyYWRlIHx8IGlzTmV3U3RvcmUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0b3JlIGlzIG5ldyB0aGVuIGluY3JlbWVudCB0aGUgdmVyc2lvbiAoaWYgbmVlZGVkKS5cbiAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYW4gXCJ1cGdyYWRlbmVlZGVkXCIgZXZlbnQgd2hpY2ggaXMgcmVxdWlyZWRcbiAgICAgICAgLy8gZm9yIGNyZWF0aW5nIGEgc3RvcmUuXG4gICAgICAgIGlmIChpc05ld1N0b3JlKSB7XG4gICAgICAgICAgICB2YXIgaW5jVmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgIGlmIChpbmNWZXJzaW9uID4gZGJJbmZvLnZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBkYkluZm8udmVyc2lvbiA9IGluY1ZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGVuY29kZSBhIGJsb2IgZm9yIGluZGV4ZWRkYiBlbmdpbmVzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBibG9ic1xuZnVuY3Rpb24gX2VuY29kZUJsb2IoYmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBiYXNlNjQgPSBidG9hKGUudGFyZ2V0LnJlc3VsdCB8fCAnJyk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBfX2xvY2FsX2ZvcmFnZV9lbmNvZGVkX2Jsb2I6IHRydWUsXG4gICAgICAgICAgICAgICAgZGF0YTogYmFzZTY0LFxuICAgICAgICAgICAgICAgIHR5cGU6IGJsb2IudHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNCaW5hcnlTdHJpbmcoYmxvYik7XG4gICAgfSk7XG59XG5cbi8vIGRlY29kZSBhbiBlbmNvZGVkIGJsb2JcbmZ1bmN0aW9uIF9kZWNvZGVCbG9iKGVuY29kZWRCbG9iKSB7XG4gICAgdmFyIGFycmF5QnVmZiA9IF9iaW5TdHJpbmdUb0FycmF5QnVmZmVyKGF0b2IoZW5jb2RlZEJsb2IuZGF0YSkpO1xuICAgIHJldHVybiBjcmVhdGVCbG9iKFthcnJheUJ1ZmZdLCB7IHR5cGU6IGVuY29kZWRCbG9iLnR5cGUgfSk7XG59XG5cbi8vIGlzIHRoaXMgb25lIG9mIG91ciBmYW5jeSBlbmNvZGVkIGJsb2JzP1xuZnVuY3Rpb24gX2lzRW5jb2RlZEJsb2IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19sb2NhbF9mb3JhZ2VfZW5jb2RlZF9ibG9iO1xufVxuXG4vLyBTcGVjaWFsaXplIHRoZSBkZWZhdWx0IGByZWFkeSgpYCBmdW5jdGlvbiBieSBtYWtpbmcgaXQgZGVwZW5kZW50XG4vLyBvbiB0aGUgY3VycmVudCBkYXRhYmFzZSBvcGVyYXRpb25zLiBUaHVzLCB0aGUgZHJpdmVyIHdpbGwgYmUgYWN0dWFsbHlcbi8vIHJlYWR5IHdoZW4gaXQncyBiZWVuIGluaXRpYWxpemVkIChkZWZhdWx0KSAqYW5kKiB0aGVyZSBhcmUgbm8gcGVuZGluZ1xuLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGF0YWJhc2UgKGluaXRpYXRlZCBieSBzb21lIG90aGVyIGluc3RhbmNlcykuXG5mdW5jdGlvbiBfZnVsbHlSZWFkeShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5faW5pdFJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW3NlbGYuX2RiSW5mby5uYW1lXTtcblxuICAgICAgICBpZiAoZGJDb250ZXh0ICYmIGRiQ29udGV4dC5kYlJlYWR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZGJDb250ZXh0LmRiUmVhZHk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGV4ZWN1dGVUd29DYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gVHJ5IHRvIGVzdGFibGlzaCBhIG5ldyBkYiBjb25uZWN0aW9uIHRvIHJlcGxhY2UgdGhlXG4vLyBjdXJyZW50IG9uZSB3aGljaCBpcyBicm9rZW4gKGkuZS4gZXhwZXJpZW5jaW5nXG4vLyBJbnZhbGlkU3RhdGVFcnJvciB3aGlsZSBjcmVhdGluZyBhIHRyYW5zYWN0aW9uKS5cbmZ1bmN0aW9uIF90cnlSZWNvbm5lY3QoZGJJbmZvKSB7XG4gICAgX2RlZmVyUmVhZGluZXNzKGRiSW5mbyk7XG5cbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG4gICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgaWYgKGZvcmFnZS5fZGJJbmZvLmRiKSB7XG4gICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYi5jbG9zZSgpO1xuICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRiSW5mby5kYiA9IG51bGw7XG5cbiAgICByZXR1cm4gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiO1xuICAgICAgICBpZiAoX2lzVXBncmFkZU5lZWRlZChkYkluZm8pKSB7XG4gICAgICAgICAgICAvLyBSZW9wZW4gdGhlIGRhdGFiYXNlIGZvciB1cGdyYWRpbmcuXG4gICAgICAgICAgICByZXR1cm4gX2dldFVwZ3JhZGVkQ29ubmVjdGlvbihkYkluZm8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYjtcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAvLyBzdG9yZSB0aGUgbGF0ZXN0IGRiIHJlZmVyZW5jZVxuICAgICAgICAvLyBpbiBjYXNlIHRoZSBkYiB3YXMgdXBncmFkZWRcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yYWdlc1tpXS5fZGJJbmZvLmRiID0gZGI7XG4gICAgICAgIH1cbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3JlamVjdFJlYWRpbmVzcyhkYkluZm8sIGVycik7XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbn1cblxuLy8gRkYgZG9lc24ndCBsaWtlIFByb21pc2VzIChtaWNyby10YXNrcykgYW5kIElEREIgc3RvcmUgb3BlcmF0aW9ucyxcbi8vIHNvIHdlIGhhdmUgdG8gZG8gaXQgd2l0aCBjYWxsYmFja3NcbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zYWN0aW9uKGRiSW5mbywgbW9kZSwgY2FsbGJhY2ssIHJldHJpZXMpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHJpZXMgPSAxO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIHZhciB0eCA9IGRiSW5mby5kYi50cmFuc2FjdGlvbihkYkluZm8uc3RvcmVOYW1lLCBtb2RlKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgdHgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAocmV0cmllcyA+IDAgJiYgKCFkYkluZm8uZGIgfHwgZXJyLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicgfHwgZXJyLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghZGJJbmZvLmRiIHx8IGVyci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgJiYgIWRiSW5mby5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKGRiSW5mby5zdG9yZU5hbWUpICYmIGRiSW5mby52ZXJzaW9uIDw9IGRiSW5mby5kYi52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBkYiB2ZXJzaW9uLCB0byBjcmVhdGUgdGhlIG5ldyBPYmplY3RTdG9yZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGJJbmZvLmRiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYkluZm8udmVyc2lvbiA9IGRiSW5mby5kYi52ZXJzaW9uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBSZW9wZW4gdGhlIGRhdGFiYXNlIGZvciB1cGdyYWRpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90cnlSZWNvbm5lY3QoZGJJbmZvKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oZGJJbmZvLCBtb2RlLCBjYWxsYmFjaywgcmV0cmllcyAtIDEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShjYWxsYmFjayk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGJDb250ZXh0KCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFJ1bm5pbmcgbG9jYWxGb3JhZ2VzIHNoYXJpbmcgYSBkYXRhYmFzZS5cbiAgICAgICAgZm9yYWdlczogW10sXG4gICAgICAgIC8vIFNoYXJlZCBkYXRhYmFzZS5cbiAgICAgICAgZGI6IG51bGwsXG4gICAgICAgIC8vIERhdGFiYXNlIHJlYWRpbmVzcyAocHJvbWlzZSkuXG4gICAgICAgIGRiUmVhZHk6IG51bGwsXG4gICAgICAgIC8vIERlZmVycmVkIG9wZXJhdGlvbnMgb24gdGhlIGRhdGFiYXNlLlxuICAgICAgICBkZWZlcnJlZE9wZXJhdGlvbnM6IFtdXG4gICAgfTtcbn1cblxuLy8gT3BlbiB0aGUgSW5kZXhlZERCIGRhdGFiYXNlIChhdXRvbWF0aWNhbGx5IGNyZWF0ZXMgb25lIGlmIG9uZSBkaWRuJ3Rcbi8vIHByZXZpb3VzbHkgZXhpc3QpLCB1c2luZyBhbnkgb3B0aW9ucyBzZXQgaW4gdGhlIGNvbmZpZy5cbmZ1bmN0aW9uIF9pbml0U3RvcmFnZShvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkYkluZm8gPSB7XG4gICAgICAgIGRiOiBudWxsXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgZGJJbmZvW2ldID0gb3B0aW9uc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldCB0aGUgY3VycmVudCBjb250ZXh0IG9mIHRoZSBkYXRhYmFzZTtcbiAgICB2YXIgZGJDb250ZXh0ID0gZGJDb250ZXh0c1tkYkluZm8ubmFtZV07XG5cbiAgICAvLyAuLi5vciBjcmVhdGUgYSBuZXcgY29udGV4dC5cbiAgICBpZiAoIWRiQ29udGV4dCkge1xuICAgICAgICBkYkNvbnRleHQgPSBjcmVhdGVEYkNvbnRleHQoKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIG5ldyBjb250ZXh0IGluIHRoZSBnbG9iYWwgY29udGFpbmVyLlxuICAgICAgICBkYkNvbnRleHRzW2RiSW5mby5uYW1lXSA9IGRiQ29udGV4dDtcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciBpdHNlbGYgYXMgYSBydW5uaW5nIGxvY2FsRm9yYWdlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgZGJDb250ZXh0LmZvcmFnZXMucHVzaChzZWxmKTtcblxuICAgIC8vIFJlcGxhY2UgdGhlIGRlZmF1bHQgYHJlYWR5KClgIGZ1bmN0aW9uIHdpdGggdGhlIHNwZWNpYWxpemVkIG9uZS5cbiAgICBpZiAoIXNlbGYuX2luaXRSZWFkeSkge1xuICAgICAgICBzZWxmLl9pbml0UmVhZHkgPSBzZWxmLnJlYWR5O1xuICAgICAgICBzZWxmLnJlYWR5ID0gX2Z1bGx5UmVhZHk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIGluaXRpYWxpemF0aW9uIHN0YXRlcyBvZiB0aGUgcmVsYXRlZCBsb2NhbEZvcmFnZXMuXG4gICAgdmFyIGluaXRQcm9taXNlcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gaWdub3JlRXJyb3JzKCkge1xuICAgICAgICAvLyBEb24ndCBoYW5kbGUgZXJyb3JzIGhlcmUsXG4gICAgICAgIC8vIGp1c3QgbWFrZXMgc3VyZSByZWxhdGVkIGxvY2FsRm9yYWdlcyBhcmVuJ3QgcGVuZGluZy5cbiAgICAgICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBkYkNvbnRleHQuZm9yYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgZm9yYWdlID0gZGJDb250ZXh0LmZvcmFnZXNbal07XG4gICAgICAgIGlmIChmb3JhZ2UgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHdhaXQgZm9yIGl0c2VsZi4uLlxuICAgICAgICAgICAgaW5pdFByb21pc2VzLnB1c2goZm9yYWdlLl9pbml0UmVhZHkoKVtcImNhdGNoXCJdKGlnbm9yZUVycm9ycykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFrZSBhIHNuYXBzaG90IG9mIHRoZSByZWxhdGVkIGxvY2FsRm9yYWdlcy5cbiAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzLnNsaWNlKDApO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIG9ubHkgd2hlblxuICAgIC8vIGFsbCB0aGUgcmVsYXRlZCBsb2NhbEZvcmFnZXMgYXJlbid0IHBlbmRpbmcuXG4gICAgcmV0dXJuIFByb21pc2UkMS5hbGwoaW5pdFByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGJJbmZvLmRiID0gZGJDb250ZXh0LmRiO1xuICAgICAgICAvLyBHZXQgdGhlIGNvbm5lY3Rpb24gb3Igb3BlbiBhIG5ldyBvbmUgd2l0aG91dCB1cGdyYWRlLlxuICAgICAgICByZXR1cm4gX2dldE9yaWdpbmFsQ29ubmVjdGlvbihkYkluZm8pO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiO1xuICAgICAgICBpZiAoX2lzVXBncmFkZU5lZWRlZChkYkluZm8sIHNlbGYuX2RlZmF1bHRDb25maWcudmVyc2lvbikpIHtcbiAgICAgICAgICAgIC8vIFJlb3BlbiB0aGUgZGF0YWJhc2UgZm9yIHVwZ3JhZGluZy5cbiAgICAgICAgICAgIHJldHVybiBfZ2V0VXBncmFkZWRDb25uZWN0aW9uKGRiSW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRiO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIGRiSW5mby5kYiA9IGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICBzZWxmLl9kYkluZm8gPSBkYkluZm87XG4gICAgICAgIC8vIFNoYXJlIHRoZSBmaW5hbCBjb25uZWN0aW9uIGFtb25nc3QgcmVsYXRlZCBsb2NhbEZvcmFnZXMuXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgZm9yYWdlcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNba107XG4gICAgICAgICAgICBpZiAoZm9yYWdlICE9PSBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gU2VsZiBpcyBhbHJlYWR5IHVwLXRvLWRhdGUuXG4gICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8uZGIgPSBkYkluZm8uZGI7XG4gICAgICAgICAgICAgICAgZm9yYWdlLl9kYkluZm8udmVyc2lvbiA9IGRiSW5mby52ZXJzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQoa2V5KTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0VuY29kZWRCbG9iKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX2RlY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gSXRlcmF0ZSBvdmVyIGFsbCBpdGVtcyBzdG9yZWQgaW4gZGF0YWJhc2UuXG5mdW5jdGlvbiBpdGVyYXRlKGl0ZXJhdG9yLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9PTkxZLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbkN1cnNvcigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9uTnVtYmVyID0gMTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0VuY29kZWRCbG9iKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9kZWNvZGVCbG9iKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZXJhdG9yKHZhbHVlLCBjdXJzb3Iua2V5LCBpdGVyYXRpb25OdW1iZXIrKyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBpdGVyYXRvciBjYWxsYmFjayByZXR1cm5zIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIChub24tYHVuZGVmaW5lZGApIHZhbHVlLCB0aGVuIHdlIHN0b3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgaXRlcmF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JbXCJjb250aW51ZVwiXSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gc2V0SXRlbShrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGRiSW5mbztcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBCbG9iXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NoZWNrQmxvYlN1cHBvcnQoZGJJbmZvLmRiKS50aGVuKGZ1bmN0aW9uIChibG9iU3VwcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvYlN1cHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2VuY29kZUJsb2IodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2UgZG9uJ3QgX3NhdmVfIG51bGwgaXMgYmVjYXVzZSBJRSAxMCBkb2VzXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBzdXBwb3J0IHNhdmluZyB0aGUgYG51bGxgIHR5cGUgaW4gSW5kZXhlZERCLiBIb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gaXJvbmljLCBnaXZlbiB0aGUgYnVnIGJlbG93IVxuICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL2lzc3Vlcy8xNjFcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5wdXQodmFsdWUsIGtleSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc3QgdG8gdW5kZWZpbmVkIHNvIHRoZSB2YWx1ZSBwYXNzZWQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrL3Byb21pc2UgaXMgdGhlIHNhbWUgYXMgd2hhdCBvbmUgd291bGQgZ2V0IG91dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYGdldEl0ZW0oKWAgbGF0ZXIuIFRoaXMgbGVhZHMgdG8gc29tZSB3ZWlyZG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChzZXRJdGVtKCdmb28nLCB1bmRlZmluZWQpIHdpbGwgcmV0dXJuIGBudWxsYCksIGJ1dFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBub3QgbXkgZmF1bHQgbG9jYWxTdG9yYWdlIGlzIG91ciBiYXNlbGluZSBhbmQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyB3ZWlyZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyID0gcmVxLmVycm9yID8gcmVxLmVycm9yIDogcmVxLnRyYW5zYWN0aW9uLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX1dSSVRFLCBmdW5jdGlvbiAoZXJyLCB0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHNlbGYuX2RiSW5mby5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSB1c2UgYSBHcnVudCB0YXNrIHRvIG1ha2UgdGhpcyBzYWZlIGZvciBJRSBhbmQgc29tZVxuICAgICAgICAgICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBBbmRyb2lkIChpbmNsdWRpbmcgdGhvc2UgdXNlZCBieSBDb3Jkb3ZhKS5cbiAgICAgICAgICAgICAgICAgICAgLy8gTm9ybWFsbHkgSUUgd29uJ3QgbGlrZSBgLmRlbGV0ZSgpYCBhbmQgd2lsbCBpbnNpc3Qgb25cbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgYFsnZGVsZXRlJ10oKWAsIGJ1dCB3ZSBoYXZlIGEgYnVpbGQgc3RlcCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpeGVzIHRoaXMgZm9yIHVzIG5vdy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChyZXEuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0IHdpbGwgYmUgYWxzbyBiZSBhYm9ydGVkIGlmIHdlJ3ZlIGV4Y2VlZGVkIG91ciBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwYWNlLlxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlcS5lcnJvciA/IHJlcS5lcnJvciA6IHJlcS50cmFuc2FjdGlvbi5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBjbGVhcihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNyZWF0ZVRyYW5zYWN0aW9uKHNlbGYuX2RiSW5mbywgUkVBRF9XUklURSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmFib3J0ID0gdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnIgPSByZXEuZXJyb3IgPyByZXEuZXJyb3IgOiByZXEudHJhbnNhY3Rpb24uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXEgPSBzdG9yZS5jb3VudCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlcS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleShuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmIChuIDwgMCkge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY3JlYXRlVHJhbnNhY3Rpb24oc2VsZi5fZGJJbmZvLCBSRUFEX09OTFksIGZ1bmN0aW9uIChlcnIsIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gdHJhbnNhY3Rpb24ub2JqZWN0U3RvcmUoc2VsZi5fZGJJbmZvLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZHZhbmNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUub3BlbktleUN1cnNvcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGVyZSB3ZXJlbid0IGVub3VnaCBrZXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIHRoZSBmaXJzdCBrZXksIHJldHVybiBpdCBpZiB0aGF0J3Mgd2hhdCB0aGV5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2FudGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWR2YW5jZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBhc2sgdGhlIGN1cnNvciB0byBza2lwIGFoZWFkIG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3Jkcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWR2YW5jZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCBoZXJlLCB3ZSd2ZSBnb3QgdGhlIG50aCBrZXkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHJlcS5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGtleXMoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjcmVhdGVUcmFuc2FjdGlvbihzZWxmLl9kYkluZm8sIFJFQURfT05MWSwgZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShzZWxmLl9kYkluZm8uc3RvcmVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IHN0b3JlLm9wZW5LZXlDdXJzb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IHJlcS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShrZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChjdXJzb3Iua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcltcImNvbnRpbnVlXCJdKCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QocmVxLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBjdXJyZW50Q29uZmlnLm5hbWU7XG4gICAgICAgIG9wdGlvbnMuc3RvcmVOYW1lID0gb3B0aW9ucy5zdG9yZU5hbWUgfHwgY3VycmVudENvbmZpZy5zdG9yZU5hbWU7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlO1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHByb21pc2UgPSBQcm9taXNlJDEucmVqZWN0KCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpc0N1cnJlbnREYiA9IG9wdGlvbnMubmFtZSA9PT0gY3VycmVudENvbmZpZy5uYW1lICYmIHNlbGYuX2RiSW5mby5kYjtcblxuICAgICAgICB2YXIgZGJQcm9taXNlID0gaXNDdXJyZW50RGIgPyBQcm9taXNlJDEucmVzb2x2ZShzZWxmLl9kYkluZm8uZGIpIDogX2dldE9yaWdpbmFsQ29ubmVjdGlvbihvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChkYikge1xuICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgIHZhciBmb3JhZ2VzID0gZGJDb250ZXh0LmZvcmFnZXM7XG4gICAgICAgICAgICBkYkNvbnRleHQuZGIgPSBkYjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9yYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvcmFnZXNbaV0uX2RiSW5mby5kYiA9IGRiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RvcmVOYW1lKSB7XG4gICAgICAgICAgICBwcm9taXNlID0gZGJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgX2RlZmVyUmVhZGluZXNzKG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRiQ29udGV4dCA9IGRiQ29udGV4dHNbb3B0aW9ucy5uYW1lXTtcbiAgICAgICAgICAgICAgICB2YXIgZm9yYWdlcyA9IGRiQ29udGV4dC5mb3JhZ2VzO1xuXG4gICAgICAgICAgICAgICAgZGIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmFnZSA9IGZvcmFnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLmRiID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZHJvcERCUHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiLmRlbGV0ZURhdGFiYXNlKG9wdGlvbnMubmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZXEub25ibG9ja2VkID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRiID0gcmVxLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRiKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBkcm9wREJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRiQ29udGV4dC5kYiA9IGRiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcmFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZm9yYWdlID0gZm9yYWdlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hZHZhbmNlUmVhZGluZXNzKF9mb3JhZ2UuX2RiSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9yZWplY3RSZWFkaW5lc3Mob3B0aW9ucywgZXJyKSB8fCBQcm9taXNlJDEucmVzb2x2ZSgpKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlID0gZGJQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKG9wdGlvbnMuc3RvcmVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZlcnNpb24gPSBkYi52ZXJzaW9uICsgMTtcblxuICAgICAgICAgICAgICAgIF9kZWZlclJlYWRpbmVzcyhvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIHZhciBkYkNvbnRleHQgPSBkYkNvbnRleHRzW29wdGlvbnMubmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGZvcmFnZXMgPSBkYkNvbnRleHQuZm9yYWdlcztcblxuICAgICAgICAgICAgICAgIGRiLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb3JhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3JhZ2UgPSBmb3JhZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3JhZ2UuX2RiSW5mby5kYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvcmFnZS5fZGJJbmZvLnZlcnNpb24gPSBuZXdWZXJzaW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBkcm9wT2JqZWN0UHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0gaWRiLm9wZW4ob3B0aW9ucy5uYW1lLCBuZXdWZXJzaW9uKTtcblxuICAgICAgICAgICAgICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5kZWxldGVPYmplY3RTdG9yZShvcHRpb25zLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYiA9IHJlcS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkYik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZHJvcE9iamVjdFByb21pc2UudGhlbihmdW5jdGlvbiAoZGIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGJDb250ZXh0LmRiID0gZGI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZm9yYWdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9mb3JhZ2UyID0gZm9yYWdlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mb3JhZ2UyLl9kYkluZm8uZGIgPSBkYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hZHZhbmNlUmVhZGluZXNzKF9mb3JhZ2UyLl9kYkluZm8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIChfcmVqZWN0UmVhZGluZXNzKG9wdGlvbnMsIGVycikgfHwgUHJvbWlzZSQxLnJlc29sdmUoKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIGFzeW5jU3RvcmFnZSA9IHtcbiAgICBfZHJpdmVyOiAnYXN5bmNTdG9yYWdlJyxcbiAgICBfaW5pdFN0b3JhZ2U6IF9pbml0U3RvcmFnZSxcbiAgICBfc3VwcG9ydDogaXNJbmRleGVkREJWYWxpZCgpLFxuICAgIGl0ZXJhdGU6IGl0ZXJhdGUsXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSxcbiAgICBzZXRJdGVtOiBzZXRJdGVtLFxuICAgIHJlbW92ZUl0ZW06IHJlbW92ZUl0ZW0sXG4gICAgY2xlYXI6IGNsZWFyLFxuICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgIGtleToga2V5LFxuICAgIGtleXM6IGtleXMsXG4gICAgZHJvcEluc3RhbmNlOiBkcm9wSW5zdGFuY2Vcbn07XG5cbmZ1bmN0aW9uIGlzV2ViU1FMVmFsaWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvcGVuRGF0YWJhc2UgPT09ICdmdW5jdGlvbic7XG59XG5cbi8vIFNhZGx5LCB0aGUgYmVzdCB3YXkgdG8gc2F2ZSBiaW5hcnkgZGF0YSBpbiBXZWJTUUwvbG9jYWxTdG9yYWdlIGlzIHNlcmlhbGl6aW5nXG4vLyBpdCB0byBCYXNlNjQsIHNvIHRoaXMgaXMgaG93IHdlIHN0b3JlIGl0IHRvIHByZXZlbnQgdmVyeSBzdHJhbmdlIGVycm9ycyB3aXRoIGxlc3Ncbi8vIHZlcmJvc2Ugd2F5cyBvZiBiaW5hcnkgPC0+IHN0cmluZyBkYXRhIHN0b3JhZ2UuXG52YXIgQkFTRV9DSEFSUyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxudmFyIEJMT0JfVFlQRV9QUkVGSVggPSAnfn5sb2NhbF9mb3JhZ2VfdHlwZX4nO1xudmFyIEJMT0JfVFlQRV9QUkVGSVhfUkVHRVggPSAvXn5+bG9jYWxfZm9yYWdlX3R5cGV+KFtefl0rKX4vO1xuXG52YXIgU0VSSUFMSVpFRF9NQVJLRVIgPSAnX19sZnNjX186JztcbnZhciBTRVJJQUxJWkVEX01BUktFUl9MRU5HVEggPSBTRVJJQUxJWkVEX01BUktFUi5sZW5ndGg7XG5cbi8vIE9NRyB0aGUgc2VyaWFsaXphdGlvbnMhXG52YXIgVFlQRV9BUlJBWUJVRkZFUiA9ICdhcmJmJztcbnZhciBUWVBFX0JMT0IgPSAnYmxvYic7XG52YXIgVFlQRV9JTlQ4QVJSQVkgPSAnc2kwOCc7XG52YXIgVFlQRV9VSU5UOEFSUkFZID0gJ3VpMDgnO1xudmFyIFRZUEVfVUlOVDhDTEFNUEVEQVJSQVkgPSAndWljOCc7XG52YXIgVFlQRV9JTlQxNkFSUkFZID0gJ3NpMTYnO1xudmFyIFRZUEVfSU5UMzJBUlJBWSA9ICdzaTMyJztcbnZhciBUWVBFX1VJTlQxNkFSUkFZID0gJ3VyMTYnO1xudmFyIFRZUEVfVUlOVDMyQVJSQVkgPSAndWkzMic7XG52YXIgVFlQRV9GTE9BVDMyQVJSQVkgPSAnZmwzMic7XG52YXIgVFlQRV9GTE9BVDY0QVJSQVkgPSAnZmw2NCc7XG52YXIgVFlQRV9TRVJJQUxJWkVEX01BUktFUl9MRU5HVEggPSBTRVJJQUxJWkVEX01BUktFUl9MRU5HVEggKyBUWVBFX0FSUkFZQlVGRkVSLmxlbmd0aDtcblxudmFyIHRvU3RyaW5nJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J1ZmZlcihzZXJpYWxpemVkU3RyaW5nKSB7XG4gICAgLy8gRmlsbCB0aGUgc3RyaW5nIGludG8gYSBBcnJheUJ1ZmZlci5cbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gc2VyaWFsaXplZFN0cmluZy5sZW5ndGggKiAwLjc1O1xuICAgIHZhciBsZW4gPSBzZXJpYWxpemVkU3RyaW5nLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICB2YXIgcCA9IDA7XG4gICAgdmFyIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKHNlcmlhbGl6ZWRTdHJpbmdbc2VyaWFsaXplZFN0cmluZy5sZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICBpZiAoc2VyaWFsaXplZFN0cmluZ1tzZXJpYWxpemVkU3RyaW5nLmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpO1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgZW5jb2RlZDEgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpXSk7XG4gICAgICAgIGVuY29kZWQyID0gQkFTRV9DSEFSUy5pbmRleE9mKHNlcmlhbGl6ZWRTdHJpbmdbaSArIDFdKTtcbiAgICAgICAgZW5jb2RlZDMgPSBCQVNFX0NIQVJTLmluZGV4T2Yoc2VyaWFsaXplZFN0cmluZ1tpICsgMl0pO1xuICAgICAgICBlbmNvZGVkNCA9IEJBU0VfQ0hBUlMuaW5kZXhPZihzZXJpYWxpemVkU3RyaW5nW2kgKyAzXSk7XG5cbiAgICAgICAgLypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xuICAgICAgICBieXRlc1twKytdID0gZW5jb2RlZDEgPDwgMiB8IGVuY29kZWQyID4+IDQ7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDIgJiAxNSkgPDwgNCB8IGVuY29kZWQzID4+IDI7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDMgJiAzKSA8PCA2IHwgZW5jb2RlZDQgJiA2MztcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuLy8gQ29udmVydHMgYSBidWZmZXIgdG8gYSBzdHJpbmcgdG8gc3RvcmUsIHNlcmlhbGl6ZWQsIGluIHRoZSBiYWNrZW5kXG4vLyBzdG9yYWdlIGxpYnJhcnkuXG5mdW5jdGlvbiBidWZmZXJUb1N0cmluZyhidWZmZXIpIHtcbiAgICAvLyBiYXNlNjQtYXJyYXlidWZmZXJcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIHZhciBiYXNlNjRTdHJpbmcgPSAnJztcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAvKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTW2J5dGVzW2ldID4+IDJdO1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1soYnl0ZXNbaV0gJiAzKSA8PCA0IHwgYnl0ZXNbaSArIDFdID4+IDRdO1xuICAgICAgICBiYXNlNjRTdHJpbmcgKz0gQkFTRV9DSEFSU1soYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpICsgMl0gPj4gNl07XG4gICAgICAgIGJhc2U2NFN0cmluZyArPSBCQVNFX0NIQVJTW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZXMubGVuZ3RoICUgMyA9PT0gMikge1xuICAgICAgICBiYXNlNjRTdHJpbmcgPSBiYXNlNjRTdHJpbmcuc3Vic3RyaW5nKDAsIGJhc2U2NFN0cmluZy5sZW5ndGggLSAxKSArICc9JztcbiAgICB9IGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCAlIDMgPT09IDEpIHtcbiAgICAgICAgYmFzZTY0U3RyaW5nID0gYmFzZTY0U3RyaW5nLnN1YnN0cmluZygwLCBiYXNlNjRTdHJpbmcubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjRTdHJpbmc7XG59XG5cbi8vIFNlcmlhbGl6ZSBhIHZhbHVlLCBhZnRlcndhcmRzIGV4ZWN1dGluZyBhIGNhbGxiYWNrICh3aGljaCB1c3VhbGx5XG4vLyBpbnN0cnVjdHMgdGhlIGBzZXRJdGVtKClgIGNhbGxiYWNrL3Byb21pc2UgdG8gYmUgZXhlY3V0ZWQpLiBUaGlzIGlzIGhvd1xuLy8gd2Ugc3RvcmUgYmluYXJ5IGRhdGEgd2l0aCBsb2NhbFN0b3JhZ2UuXG5mdW5jdGlvbiBzZXJpYWxpemUodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHZhbHVlVHlwZSA9ICcnO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZVR5cGUgPSB0b1N0cmluZyQxLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8vIENhbm5vdCB1c2UgYHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJgIG9yIHN1Y2ggaGVyZSwgYXMgdGhlc2VcbiAgICAvLyBjaGVja3MgZmFpbCB3aGVuIHJ1bm5pbmcgdGhlIHRlc3RzIHVzaW5nIGNhc3Blci5qcy4uLlxuICAgIC8vXG4gICAgLy8gVE9ETzogU2VlIHdoeSB0aG9zZSB0ZXN0cyBmYWlsIGFuZCB1c2UgYSBiZXR0ZXIgc29sdXRpb24uXG4gICAgaWYgKHZhbHVlICYmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScgfHwgdmFsdWUuYnVmZmVyICYmIHRvU3RyaW5nJDEuY2FsbCh2YWx1ZS5idWZmZXIpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSkge1xuICAgICAgICAvLyBDb252ZXJ0IGJpbmFyeSBhcnJheXMgdG8gYSBzdHJpbmcgYW5kIHByZWZpeCB0aGUgc3RyaW5nIHdpdGhcbiAgICAgICAgLy8gYSBzcGVjaWFsIG1hcmtlci5cbiAgICAgICAgdmFyIGJ1ZmZlcjtcbiAgICAgICAgdmFyIG1hcmtlciA9IFNFUklBTElaRURfTUFSS0VSO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICBidWZmZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0FSUkFZQlVGRkVSO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyID0gdmFsdWUuYnVmZmVyO1xuXG4gICAgICAgICAgICBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0lOVDhBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBVaW50OEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UOEFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UOENMQU1QRURBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9JTlQxNkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQxNkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UMTZBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBJbnQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9JTlQzMkFSUkFZO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgKz0gVFlQRV9VSU5UMzJBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBGbG9hdDMyQXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0ZMT0FUMzJBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSAnW29iamVjdCBGbG9hdDY0QXJyYXldJykge1xuICAgICAgICAgICAgICAgIG1hcmtlciArPSBUWVBFX0ZMT0FUNjRBUlJBWTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IHR5cGUgZm9yIEJpbmFyeUFycmF5JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobWFya2VyICsgYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09ICdbb2JqZWN0IEJsb2JdJykge1xuICAgICAgICAvLyBDb252ZXIgdGhlIGJsb2IgdG8gYSBiaW5hcnlBcnJheSBhbmQgdGhlbiB0byBhIHN0cmluZy5cbiAgICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQmFja3dhcmRzLWNvbXBhdGlibGUgcHJlZml4IGZvciB0aGUgYmxvYiB0eXBlLlxuICAgICAgICAgICAgdmFyIHN0ciA9IEJMT0JfVFlQRV9QUkVGSVggKyB2YWx1ZS50eXBlICsgJ34nICsgYnVmZmVyVG9TdHJpbmcodGhpcy5yZXN1bHQpO1xuXG4gICAgICAgICAgICBjYWxsYmFjayhTRVJJQUxJWkVEX01BUktFUiArIFRZUEVfQkxPQiArIHN0cik7XG4gICAgICAgIH07XG5cbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcih2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDb3VsZG4ndCBjb252ZXJ0IHZhbHVlIGludG8gYSBKU09OIHN0cmluZzogXCIsIHZhbHVlKTtcblxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIERlc2VyaWFsaXplIGRhdGEgd2UndmUgaW5zZXJ0ZWQgaW50byBhIHZhbHVlIGNvbHVtbi9maWVsZC4gV2UgcGxhY2Vcbi8vIHNwZWNpYWwgbWFya2VycyBpbnRvIG91ciBzdHJpbmdzIHRvIG1hcmsgdGhlbSBhcyBlbmNvZGVkOyB0aGlzIGlzbid0XG4vLyBhcyBuaWNlIGFzIGEgbWV0YSBmaWVsZCwgYnV0IGl0J3MgdGhlIG9ubHkgc2FuZSB0aGluZyB3ZSBjYW4gZG8gd2hpbHN0XG4vLyBrZWVwaW5nIGxvY2FsU3RvcmFnZSBzdXBwb3J0IGludGFjdC5cbi8vXG4vLyBPZnRlbnRpbWVzIHRoaXMgd2lsbCBqdXN0IGRlc2VyaWFsaXplIEpTT04gY29udGVudCwgYnV0IGlmIHdlIGhhdmUgYVxuLy8gc3BlY2lhbCBtYXJrZXIgKFNFUklBTElaRURfTUFSS0VSLCBkZWZpbmVkIGFib3ZlKSwgd2Ugd2lsbCBleHRyYWN0XG4vLyBzb21lIGtpbmQgb2YgYXJyYXlidWZmZXIvYmluYXJ5IGRhdGEvdHlwZWQgYXJyYXkgb3V0IG9mIHRoZSBzdHJpbmcuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIC8vIElmIHdlIGhhdmVuJ3QgbWFya2VkIHRoaXMgc3RyaW5nIGFzIGJlaW5nIHNwZWNpYWxseSBzZXJpYWxpemVkIChpLmUuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gc2VyaWFsaXplZCBKU09OKSwgd2UgY2FuIGp1c3QgcmV0dXJuIGl0IGFuZCBiZVxuICAgIC8vIGRvbmUgd2l0aCBpdC5cbiAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCkgIT09IFNFUklBTElaRURfTUFSS0VSKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgZGVhbHMgd2l0aCBkZXNlcmlhbGl6aW5nIHNvbWUga2luZCBvZiBCbG9iIG9yXG4gICAgLy8gVHlwZWRBcnJheS4gRmlyc3Qgd2Ugc2VwYXJhdGUgb3V0IHRoZSB0eXBlIG9mIGRhdGEgd2UncmUgZGVhbGluZ1xuICAgIC8vIHdpdGggZnJvbSB0aGUgZGF0YSBpdHNlbGYuXG4gICAgdmFyIHNlcmlhbGl6ZWRTdHJpbmcgPSB2YWx1ZS5zdWJzdHJpbmcoVFlQRV9TRVJJQUxJWkVEX01BUktFUl9MRU5HVEgpO1xuICAgIHZhciB0eXBlID0gdmFsdWUuc3Vic3RyaW5nKFNFUklBTElaRURfTUFSS0VSX0xFTkdUSCwgVFlQRV9TRVJJQUxJWkVEX01BUktFUl9MRU5HVEgpO1xuXG4gICAgdmFyIGJsb2JUeXBlO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmxlIGJsb2IgdHlwZSBzZXJpYWxpemF0aW9uIHN0cmF0ZWd5LlxuICAgIC8vIERCcyBjcmVhdGVkIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgbG9jYWxGb3JhZ2Ugd2lsbCBzaW1wbHkgbm90IGhhdmUgdGhlIGJsb2IgdHlwZS5cbiAgICBpZiAodHlwZSA9PT0gVFlQRV9CTE9CICYmIEJMT0JfVFlQRV9QUkVGSVhfUkVHRVgudGVzdChzZXJpYWxpemVkU3RyaW5nKSkge1xuICAgICAgICB2YXIgbWF0Y2hlciA9IHNlcmlhbGl6ZWRTdHJpbmcubWF0Y2goQkxPQl9UWVBFX1BSRUZJWF9SRUdFWCk7XG4gICAgICAgIGJsb2JUeXBlID0gbWF0Y2hlclsxXTtcbiAgICAgICAgc2VyaWFsaXplZFN0cmluZyA9IHNlcmlhbGl6ZWRTdHJpbmcuc3Vic3RyaW5nKG1hdGNoZXJbMF0ubGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGJ1ZmZlciA9IHN0cmluZ1RvQnVmZmVyKHNlcmlhbGl6ZWRTdHJpbmcpO1xuXG4gICAgLy8gUmV0dXJuIHRoZSByaWdodCB0eXBlIGJhc2VkIG9uIHRoZSBjb2RlL3R5cGUgc2V0IGR1cmluZ1xuICAgIC8vIHNlcmlhbGl6YXRpb24uXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgVFlQRV9BUlJBWUJVRkZFUjpcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIGNhc2UgVFlQRV9CTE9COlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogYmxvYlR5cGUgfSk7XG4gICAgICAgIGNhc2UgVFlQRV9JTlQ4QVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDhBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDhBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfVUlOVDhDTEFNUEVEQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9JTlQxNkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQxNkFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGNhc2UgVFlQRV9VSU5UMTZBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0lOVDMyQVJSQVk6XG4gICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX1VJTlQzMkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShidWZmZXIpO1xuICAgICAgICBjYXNlIFRZUEVfRkxPQVQzMkFSUkFZOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcbiAgICAgICAgY2FzZSBUWVBFX0ZMT0FUNjRBUlJBWTpcbiAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua293biB0eXBlOiAnICsgdHlwZSk7XG4gICAgfVxufVxuXG52YXIgbG9jYWxmb3JhZ2VTZXJpYWxpemVyID0ge1xuICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgIGRlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICBzdHJpbmdUb0J1ZmZlcjogc3RyaW5nVG9CdWZmZXIsXG4gICAgYnVmZmVyVG9TdHJpbmc6IGJ1ZmZlclRvU3RyaW5nXG59O1xuXG4vKlxuICogSW5jbHVkZXMgY29kZSBmcm9tOlxuICpcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVEYlRhYmxlKHQsIGRiSW5mbywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICB0LmV4ZWN1dGVTcWwoJ0NSRUFURSBUQUJMRSBJRiBOT1QgRVhJU1RTICcgKyBkYkluZm8uc3RvcmVOYW1lICsgJyAnICsgJyhpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBrZXkgdW5pcXVlLCB2YWx1ZSknLCBbXSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuXG4vLyBPcGVuIHRoZSBXZWJTUUwgZGF0YWJhc2UgKGF1dG9tYXRpY2FsbHkgY3JlYXRlcyBvbmUgaWYgb25lIGRpZG4ndFxuLy8gcHJldmlvdXNseSBleGlzdCksIHVzaW5nIGFueSBvcHRpb25zIHNldCBpbiB0aGUgY29uZmlnLlxuZnVuY3Rpb24gX2luaXRTdG9yYWdlJDEob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGJJbmZvID0ge1xuICAgICAgICBkYjogbnVsbFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBmb3IgKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGRiSW5mb1tpXSA9IHR5cGVvZiBvcHRpb25zW2ldICE9PSAnc3RyaW5nJyA/IG9wdGlvbnNbaV0udG9TdHJpbmcoKSA6IG9wdGlvbnNbaV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGJJbmZvUHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBPcGVuIHRoZSBkYXRhYmFzZTsgdGhlIG9wZW5EYXRhYmFzZSBBUEkgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIGNyZWF0ZSBpdCBmb3IgdXMgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRiSW5mby5kYiA9IG9wZW5EYXRhYmFzZShkYkluZm8ubmFtZSwgU3RyaW5nKGRiSW5mby52ZXJzaW9uKSwgZGJJbmZvLmRlc2NyaXB0aW9uLCBkYkluZm8uc2l6ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgb3VyIGtleS92YWx1ZSB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGNyZWF0ZURiVGFibGUodCwgZGJJbmZvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fZGJJbmZvID0gZGJJbmZvO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGRiSW5mby5zZXJpYWxpemVyID0gbG9jYWxmb3JhZ2VTZXJpYWxpemVyO1xuICAgIHJldHVybiBkYkluZm9Qcm9taXNlO1xufVxuXG5mdW5jdGlvbiB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgc3FsU3RhdGVtZW50LCBhcmdzLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICAgIHQuZXhlY3V0ZVNxbChzcWxTdGF0ZW1lbnQsIGFyZ3MsIGNhbGxiYWNrLCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGVycm9yLlNZTlRBWF9FUlIpIHtcbiAgICAgICAgICAgIHQuZXhlY3V0ZVNxbCgnU0VMRUNUIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyICcgKyBcIldIRVJFIHR5cGU9J3RhYmxlJyBBTkQgbmFtZSA9ID9cIiwgW2RiSW5mby5zdG9yZU5hbWVdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cy5yb3dzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGFibGUgaXMgbWlzc2luZyAod2FzIGRlbGV0ZWQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlLWNyZWF0ZSBpdCB0YWJsZSBhbmQgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlRGJUYWJsZSh0LCBkYkluZm8sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuZXhlY3V0ZVNxbChzcWxTdGF0ZW1lbnQsIGFyZ3MsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDYWxsYmFjayh0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrKHQsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH0sIGVycm9yQ2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRJdGVtJDEoa2V5LCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5kYi50cmFuc2FjdGlvbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUICogRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgV0hFUkUga2V5ID0gPyBMSU1JVCAxJywgW2tleV0sIGZ1bmN0aW9uICh0LCByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzLnJvd3MubGVuZ3RoID8gcmVzdWx0cy5yb3dzLml0ZW0oMCkudmFsdWUgOiBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIGlzIHNlcmlhbGl6ZWQgY29udGVudCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHVucGFjay5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBpdGVyYXRlJDEoaXRlcmF0b3IsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcblxuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1QgKiBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd3MgPSByZXN1bHRzLnJvd3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSByb3dzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHJvd3MuaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVtLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgdGhpcyBpcyBzZXJpYWxpemVkIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gdW5wYWNrLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yKHJlc3VsdCwgaXRlbS5rZXksIGkgKyAxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdm9pZCgwKSBwcmV2ZW50cyBwcm9ibGVtcyB3aXRoIHJlZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYHVuZGVmaW5lZGAuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIF9zZXRJdGVtKGtleSwgdmFsdWUsIGNhbGxiYWNrLCByZXRyaWVzTGVmdCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVGhlIGxvY2FsU3RvcmFnZSBBUEkgZG9lc24ndCByZXR1cm4gdW5kZWZpbmVkIHZhbHVlcyBpbiBhblxuICAgICAgICAgICAgLy8gXCJleHBlY3RlZFwiIHdheSwgc28gdW5kZWZpbmVkIGlzIGFsd2F5cyBjYXN0IHRvIG51bGwgaW4gYWxsXG4gICAgICAgICAgICAvLyBkcml2ZXJzLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2xvY2FsRm9yYWdlL3B1bGwvNDJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBwYXNzIHRvIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uc2VyaWFsaXplci5zZXJpYWxpemUodmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnSU5TRVJUIE9SIFJFUExBQ0UgSU5UTyAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgJyArICcoa2V5LCB2YWx1ZSkgVkFMVUVTICg/LCA/KScsIFtrZXksIHZhbHVlXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUob3JpZ2luYWxWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChzcWxFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRyYW5zYWN0aW9uIGZhaWxlZDsgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIHNlZSBpZiBpdCdzIGEgcXVvdGEgZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3FsRXJyb3IuY29kZSA9PT0gc3FsRXJyb3IuUVVPVEFfRVJSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmVqZWN0IHRoZSBjYWxsYmFjayBvdXRyaWdodCBmb3Igbm93LCBidXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHdvcnRoIHRyeWluZyB0byByZS1ydW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHVzZXIgYWNjZXB0cyB0aGUgcHJvbXB0IHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vcmUgc3RvcmFnZSBvbiBTYWZhcmksIHRoaXMgZXJyb3Igd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZS1ydW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXRyaWVzTGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShfc2V0SXRlbS5hcHBseShzZWxmLCBba2V5LCBvcmlnaW5hbFZhbHVlLCBjYWxsYmFjaywgcmV0cmllc0xlZnQgLSAxXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChzcWxFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBzZXRJdGVtJDEoa2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gX3NldEl0ZW0uYXBwbHkodGhpcywgW2tleSwgdmFsdWUsIGNhbGxiYWNrLCAxXSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0kMShrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdERUxFVEUgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgV0hFUkUga2V5ID0gPycsIFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBEZWxldGVzIGV2ZXJ5IGl0ZW0gaW4gdGhlIHRhYmxlLlxuLy8gVE9ETzogRmluZCBvdXQgaWYgdGhpcyByZXNldHMgdGhlIEFVVE9fSU5DUkVNRU5UIG51bWJlci5cbmZ1bmN0aW9uIGNsZWFyJDEoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdERUxFVEUgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSwgW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0ocmVqZWN0KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIERvZXMgYSBzaW1wbGUgYENPVU5UKGtleSlgIHRvIGdldCB0aGUgbnVtYmVyIG9mIGl0ZW1zIHN0b3JlZCBpblxuLy8gbG9jYWxGb3JhZ2UuXG5mdW5jdGlvbiBsZW5ndGgkMShjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICAvLyBBaGhoLCBTUUwgbWFrZXMgdGhpcyBvbmUgc29vb29vbyBlYXN5LlxuICAgICAgICAgICAgICAgIHRyeUV4ZWN1dGVTcWwodCwgZGJJbmZvLCAnU0VMRUNUIENPVU5UKGtleSkgYXMgYyBGUk9NICcgKyBkYkluZm8uc3RvcmVOYW1lLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHMucm93cy5pdGVtKDApLmM7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBSZXR1cm4gdGhlIGtleSBsb2NhdGVkIGF0IGtleSBpbmRleCBYOyBlc3NlbnRpYWxseSBnZXRzIHRoZSBrZXkgZnJvbSBhXG4vLyBgV0hFUkUgaWQgPSA/YC4gVGhpcyBpcyB0aGUgbW9zdCBlZmZpY2llbnQgd2F5IEkgY2FuIHRoaW5rIHRvIGltcGxlbWVudFxuLy8gdGhpcyByYXJlbHktdXNlZCAoaW4gbXkgZXhwZXJpZW5jZSkgcGFydCBvZiB0aGUgQVBJLCBidXQgaXQgY2FuIHNlZW1cbi8vIGluY29uc2lzdGVudCwgYmVjYXVzZSB3ZSBkbyBgSU5TRVJUIE9SIFJFUExBQ0UgSU5UT2Agb24gYHNldEl0ZW0oKWAsIHNvXG4vLyB0aGUgSUQgb2YgZWFjaCBrZXkgd2lsbCBjaGFuZ2UgZXZlcnkgdGltZSBpdCdzIHVwZGF0ZWQuIFBlcmhhcHMgYSBzdG9yZWRcbi8vIHByb2NlZHVyZSBmb3IgdGhlIGBzZXRJdGVtKClgIFNRTCB3b3VsZCBzb2x2ZSB0aGlzIHByb2JsZW0/XG4vLyBUT0RPOiBEb24ndCBjaGFuZ2UgSUQgb24gYHNldEl0ZW0oKWAuXG5mdW5jdGlvbiBrZXkkMShuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkYkluZm8gPSBzZWxmLl9kYkluZm87XG4gICAgICAgICAgICBkYkluZm8uZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgICAgICB0cnlFeGVjdXRlU3FsKHQsIGRiSW5mbywgJ1NFTEVDVCBrZXkgRlJPTSAnICsgZGJJbmZvLnN0b3JlTmFtZSArICcgV0hFUkUgaWQgPSA/IExJTUlUIDEnLCBbbiArIDFdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0cy5yb3dzLmxlbmd0aCA/IHJlc3VsdHMucm93cy5pdGVtKDApLmtleSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KVtcImNhdGNoXCJdKHJlamVjdCk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG5mdW5jdGlvbiBrZXlzJDEoY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBzZWxmLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICAgICAgZGJJbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgdHJ5RXhlY3V0ZVNxbCh0LCBkYkluZm8sICdTRUxFQ1Qga2V5IEZST00gJyArIGRiSW5mby5zdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAodCwgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2gocmVzdWx0cy5yb3dzLml0ZW0oaSkua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoa2V5cyk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHQsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmRhdGFiYXNlLyNkYXRhYmFzZXNcbi8vID4gVGhlcmUgaXMgbm8gd2F5IHRvIGVudW1lcmF0ZSBvciBkZWxldGUgdGhlIGRhdGFiYXNlcyBhdmFpbGFibGUgZm9yIGFuIG9yaWdpbiBmcm9tIHRoaXMgQVBJLlxuZnVuY3Rpb24gZ2V0QWxsU3RvcmVOYW1lcyhkYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZGIudHJhbnNhY3Rpb24oZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHQuZXhlY3V0ZVNxbCgnU0VMRUNUIG5hbWUgRlJPTSBzcWxpdGVfbWFzdGVyICcgKyBcIldIRVJFIHR5cGU9J3RhYmxlJyBBTkQgbmFtZSA8PiAnX19XZWJLaXREYXRhYmFzZUluZm9UYWJsZV9fJ1wiLCBbXSwgZnVuY3Rpb24gKHQsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcmVOYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLnJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lcy5wdXNoKHJlc3VsdHMucm93cy5pdGVtKGkpLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBkYjogZGIsXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZXM6IHN0b3JlTmFtZXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0LCBlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHNxbEVycm9yKSB7XG4gICAgICAgICAgICByZWplY3Qoc3FsRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZHJvcEluc3RhbmNlJDEob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9IGdldENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgY3VycmVudENvbmZpZyA9IHRoaXMuY29uZmlnKCk7XG4gICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgb3B0aW9ucy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IGN1cnJlbnRDb25maWcubmFtZTtcbiAgICAgICAgb3B0aW9ucy5zdG9yZU5hbWUgPSBvcHRpb25zLnN0b3JlTmFtZSB8fCBjdXJyZW50Q29uZmlnLnN0b3JlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHZhciBkYjtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm5hbWUgPT09IGN1cnJlbnRDb25maWcubmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZGIgcmVmZXJlbmNlIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgZGIgPSBzZWxmLl9kYkluZm8uZGI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRiID0gb3BlbkRhdGFiYXNlKG9wdGlvbnMubmFtZSwgJycsICcnLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIGRyb3AgYWxsIGRhdGFiYXNlIHRhYmxlc1xuICAgICAgICAgICAgICAgIHJlc29sdmUoZ2V0QWxsU3RvcmVOYW1lcyhkYikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgZGI6IGRiLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZU5hbWVzOiBbb3B0aW9ucy5zdG9yZU5hbWVdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG9wZXJhdGlvbkluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25JbmZvLmRiLnRyYW5zYWN0aW9uKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRyb3BUYWJsZShzdG9yZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LmV4ZWN1dGVTcWwoJ0RST1AgVEFCTEUgSUYgRVhJU1RTICcgKyBzdG9yZU5hbWUsIFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAodCwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9wZXJhdGlvbkluZm8uc3RvcmVOYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGRyb3BUYWJsZShvcGVyYXRpb25JbmZvLnN0b3JlTmFtZXNbaV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UkMS5hbGwob3BlcmF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHNxbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChzcWxFcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIHdlYlNRTFN0b3JhZ2UgPSB7XG4gICAgX2RyaXZlcjogJ3dlYlNRTFN0b3JhZ2UnLFxuICAgIF9pbml0U3RvcmFnZTogX2luaXRTdG9yYWdlJDEsXG4gICAgX3N1cHBvcnQ6IGlzV2ViU1FMVmFsaWQoKSxcbiAgICBpdGVyYXRlOiBpdGVyYXRlJDEsXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSQxLFxuICAgIHNldEl0ZW06IHNldEl0ZW0kMSxcbiAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtJDEsXG4gICAgY2xlYXI6IGNsZWFyJDEsXG4gICAgbGVuZ3RoOiBsZW5ndGgkMSxcbiAgICBrZXk6IGtleSQxLFxuICAgIGtleXM6IGtleXMkMSxcbiAgICBkcm9wSW5zdGFuY2U6IGRyb3BJbnN0YW5jZSQxXG59O1xuXG5mdW5jdGlvbiBpc0xvY2FsU3RvcmFnZVZhbGlkKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiAnc2V0SXRlbScgaW4gbG9jYWxTdG9yYWdlICYmXG4gICAgICAgIC8vIGluIElFOCB0eXBlb2YgbG9jYWxTdG9yYWdlLnNldEl0ZW0gPT09ICdvYmplY3QnXG4gICAgICAgICEhbG9jYWxTdG9yYWdlLnNldEl0ZW07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0S2V5UHJlZml4KG9wdGlvbnMsIGRlZmF1bHRDb25maWcpIHtcbiAgICB2YXIga2V5UHJlZml4ID0gb3B0aW9ucy5uYW1lICsgJy8nO1xuXG4gICAgaWYgKG9wdGlvbnMuc3RvcmVOYW1lICE9PSBkZWZhdWx0Q29uZmlnLnN0b3JlTmFtZSkge1xuICAgICAgICBrZXlQcmVmaXggKz0gb3B0aW9ucy5zdG9yZU5hbWUgKyAnLyc7XG4gICAgfVxuICAgIHJldHVybiBrZXlQcmVmaXg7XG59XG5cbi8vIENoZWNrIGlmIGxvY2FsU3RvcmFnZSB0aHJvd3Mgd2hlbiBzYXZpbmcgYW4gaXRlbVxuZnVuY3Rpb24gY2hlY2tJZkxvY2FsU3RvcmFnZVRocm93cygpIHtcbiAgICB2YXIgbG9jYWxTdG9yYWdlVGVzdEtleSA9ICdfbG9jYWxmb3JhZ2Vfc3VwcG9ydF90ZXN0JztcblxuICAgIHRyeSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGxvY2FsU3RvcmFnZVRlc3RLZXksIHRydWUpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShsb2NhbFN0b3JhZ2VUZXN0S2V5KTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8vIENoZWNrIGlmIGxvY2FsU3RvcmFnZSBpcyB1c2FibGUgYW5kIGFsbG93cyB0byBzYXZlIGFuIGl0ZW1cbi8vIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiBsb2NhbFN0b3JhZ2UgaXMgdXNhYmxlIGluIFNhZmFyaSBQcml2YXRlIEJyb3dzaW5nXG4vLyBtb2RlLCBvciBpbiBhbnkgb3RoZXIgY2FzZSB3aGVyZSB0aGUgYXZhaWxhYmxlIHF1b3RhIGZvciBsb2NhbFN0b3JhZ2Vcbi8vIGlzIDAgYW5kIHRoZXJlIHdhc24ndCBhbnkgc2F2ZWQgaXRlbXMgeWV0LlxuZnVuY3Rpb24gX2lzTG9jYWxTdG9yYWdlVXNhYmxlKCkge1xuICAgIHJldHVybiAhY2hlY2tJZkxvY2FsU3RvcmFnZVRocm93cygpIHx8IGxvY2FsU3RvcmFnZS5sZW5ndGggPiAwO1xufVxuXG4vLyBDb25maWcgdGhlIGxvY2FsU3RvcmFnZSBiYWNrZW5kLCB1c2luZyBvcHRpb25zIHNldCBpbiB0aGUgY29uZmlnLlxuZnVuY3Rpb24gX2luaXRTdG9yYWdlJDIob3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGJJbmZvID0ge307XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICBkYkluZm9baV0gPSBvcHRpb25zW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGJJbmZvLmtleVByZWZpeCA9IF9nZXRLZXlQcmVmaXgob3B0aW9ucywgc2VsZi5fZGVmYXVsdENvbmZpZyk7XG5cbiAgICBpZiAoIV9pc0xvY2FsU3RvcmFnZVVzYWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlJDEucmVqZWN0KCk7XG4gICAgfVxuXG4gICAgc2VsZi5fZGJJbmZvID0gZGJJbmZvO1xuICAgIGRiSW5mby5zZXJpYWxpemVyID0gbG9jYWxmb3JhZ2VTZXJpYWxpemVyO1xuXG4gICAgcmV0dXJuIFByb21pc2UkMS5yZXNvbHZlKCk7XG59XG5cbi8vIFJlbW92ZSBhbGwga2V5cyBmcm9tIHRoZSBkYXRhc3RvcmUsIGVmZmVjdGl2ZWx5IGRlc3Ryb3lpbmcgYWxsIGRhdGEgaW5cbi8vIHRoZSBhcHAncyBrZXkvdmFsdWUgc3RvcmUhXG5mdW5jdGlvbiBjbGVhciQyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2V5UHJlZml4ID0gc2VsZi5fZGJJbmZvLmtleVByZWZpeDtcblxuICAgICAgICBmb3IgKHZhciBpID0gbG9jYWxTdG9yYWdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICAgICAgaWYgKGtleS5pbmRleE9mKGtleVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiBpdGVtIGZyb20gdGhlIHN0b3JlLiBVbmxpa2UgdGhlIG9yaWdpbmFsIGFzeW5jX3N0b3JhZ2Vcbi8vIGxpYnJhcnkgaW4gR2FpYSwgd2UgZG9uJ3QgbW9kaWZ5IHJldHVybiB2YWx1ZXMgYXQgYWxsLiBJZiBhIGtleSdzIHZhbHVlXG4vLyBpcyBgdW5kZWZpbmVkYCwgd2UgcGFzcyB0aGF0IHZhbHVlIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbmZ1bmN0aW9uIGdldEl0ZW0kMihrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGRiSW5mby5rZXlQcmVmaXggKyBrZXkpO1xuXG4gICAgICAgIC8vIElmIGEgcmVzdWx0IHdhcyBmb3VuZCwgcGFyc2UgaXQgZnJvbSB0aGUgc2VyaWFsaXplZFxuICAgICAgICAvLyBzdHJpbmcgaW50byBhIEpTIG9iamVjdC4gSWYgcmVzdWx0IGlzbid0IHRydXRoeSwgdGhlIGtleVxuICAgICAgICAvLyBpcyBsaWtlbHkgdW5kZWZpbmVkIGFuZCB3ZSdsbCBwYXNzIGl0IHN0cmFpZ2h0IHRvIHRoZVxuICAgICAgICAvLyBjYWxsYmFjay5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGJJbmZvLnNlcmlhbGl6ZXIuZGVzZXJpYWxpemUocmVzdWx0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBJdGVyYXRlIG92ZXIgYWxsIGl0ZW1zIGluIHRoZSBzdG9yZS5cbmZ1bmN0aW9uIGl0ZXJhdGUkMihpdGVyYXRvciwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIGtleVByZWZpeCA9IGRiSW5mby5rZXlQcmVmaXg7XG4gICAgICAgIHZhciBrZXlQcmVmaXhMZW5ndGggPSBrZXlQcmVmaXgubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbG9jYWxTdG9yYWdlLmxlbmd0aDtcblxuICAgICAgICAvLyBXZSB1c2UgYSBkZWRpY2F0ZWQgaXRlcmF0b3IgaW5zdGVhZCBvZiB0aGUgYGlgIHZhcmlhYmxlIGJlbG93XG4gICAgICAgIC8vIHNvIG90aGVyIGtleXMgd2UgZmV0Y2ggaW4gbG9jYWxTdG9yYWdlIGFyZW4ndCBjb3VudGVkIGluXG4gICAgICAgIC8vIHRoZSBgaXRlcmF0aW9uTnVtYmVyYCBhcmd1bWVudCBwYXNzZWQgdG8gdGhlIGBpdGVyYXRlKClgXG4gICAgICAgIC8vIGNhbGxiYWNrLlxuICAgICAgICAvL1xuICAgICAgICAvLyBTZWU6IGdpdGh1Yi5jb20vbW96aWxsYS9sb2NhbEZvcmFnZS9wdWxsLzQzNSNkaXNjdXNzaW9uX3IzODA2MTUzMFxuICAgICAgICB2YXIgaXRlcmF0aW9uTnVtYmVyID0gMTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihrZXlQcmVmaXgpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuXG4gICAgICAgICAgICAvLyBJZiBhIHJlc3VsdCB3YXMgZm91bmQsIHBhcnNlIGl0IGZyb20gdGhlIHNlcmlhbGl6ZWRcbiAgICAgICAgICAgIC8vIHN0cmluZyBpbnRvIGEgSlMgb2JqZWN0LiBJZiByZXN1bHQgaXNuJ3QgdHJ1dGh5LCB0aGVcbiAgICAgICAgICAgIC8vIGtleSBpcyBsaWtlbHkgdW5kZWZpbmVkIGFuZCB3ZSdsbCBwYXNzIGl0IHN0cmFpZ2h0XG4gICAgICAgICAgICAvLyB0byB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRiSW5mby5zZXJpYWxpemVyLmRlc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBpdGVyYXRvcih2YWx1ZSwga2V5LnN1YnN0cmluZyhrZXlQcmVmaXhMZW5ndGgpLCBpdGVyYXRpb25OdW1iZXIrKyk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBTYW1lIGFzIGxvY2FsU3RvcmFnZSdzIGtleSgpIG1ldGhvZCwgZXhjZXB0IHRha2VzIGEgY2FsbGJhY2suXG5mdW5jdGlvbiBrZXkkMihuLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxvY2FsU3RvcmFnZS5rZXkobik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBwcmVmaXggZnJvbSB0aGUga2V5LCBpZiBhIGtleSBpcyBmb3VuZC5cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cmluZyhkYkluZm8ua2V5UHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24ga2V5cyQyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGJJbmZvID0gc2VsZi5fZGJJbmZvO1xuICAgICAgICB2YXIgbGVuZ3RoID0gbG9jYWxTdG9yYWdlLmxlbmd0aDtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbUtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG4gICAgICAgICAgICBpZiAoaXRlbUtleS5pbmRleE9mKGRiSW5mby5rZXlQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGl0ZW1LZXkuc3Vic3RyaW5nKGRiSW5mby5rZXlQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2V5cztcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbi8vIFN1cHBseSB0aGUgbnVtYmVyIG9mIGtleXMgaW4gdGhlIGRhdGFzdG9yZSB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5mdW5jdGlvbiBsZW5ndGgkMihjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYua2V5cygpLnRoZW4oZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgcmV0dXJuIGtleXMubGVuZ3RoO1xuICAgIH0pO1xuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuLy8gUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgc3RvcmUsIG5pY2UgYW5kIHNpbXBsZS5cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0kMihrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IHNlbGYucmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZGJJbmZvLmtleVByZWZpeCArIGtleSk7XG4gICAgfSk7XG5cbiAgICBleGVjdXRlQ2FsbGJhY2socHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuXG4vLyBTZXQgYSBrZXkncyB2YWx1ZSBhbmQgcnVuIGFuIG9wdGlvbmFsIGNhbGxiYWNrIG9uY2UgdGhlIHZhbHVlIGlzIHNldC5cbi8vIFVubGlrZSBHYWlhJ3MgaW1wbGVtZW50YXRpb24sIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBwYXNzZWQgdGhlIHZhbHVlLFxuLy8gaW4gY2FzZSB5b3Ugd2FudCB0byBvcGVyYXRlIG9uIHRoYXQgdmFsdWUgb25seSBhZnRlciB5b3UncmUgc3VyZSBpdFxuLy8gc2F2ZWQsIG9yIHNvbWV0aGluZyBsaWtlIHRoYXQuXG5mdW5jdGlvbiBzZXRJdGVtJDIoa2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBrZXkgPSBub3JtYWxpemVLZXkoa2V5KTtcblxuICAgIHZhciBwcm9taXNlID0gc2VsZi5yZWFkeSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBDb252ZXJ0IHVuZGVmaW5lZCB2YWx1ZXMgdG8gbnVsbC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvbG9jYWxGb3JhZ2UvcHVsbC80MlxuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSB0aGUgb3JpZ2luYWwgdmFsdWUgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gICAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlJDEoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGRiSW5mbyA9IHNlbGYuX2RiSW5mbztcbiAgICAgICAgICAgIGRiSW5mby5zZXJpYWxpemVyLnNlcmlhbGl6ZSh2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShkYkluZm8ua2V5UHJlZml4ICsga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG9yaWdpbmFsVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FwYWNpdHkgZXhjZWVkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYWtlIHRoaXMgYSBzcGVjaWZpYyBlcnJvci9ldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InIHx8IGUubmFtZSA9PT0gJ05TX0VSUk9SX0RPTV9RVU9UQV9SRUFDSEVEJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIGRyb3BJbnN0YW5jZSQyKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBnZXRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nICYmIG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRDb25maWcgPSB0aGlzLmNvbmZpZygpO1xuICAgICAgICBvcHRpb25zLm5hbWUgPSBvcHRpb25zLm5hbWUgfHwgY3VycmVudENvbmZpZy5uYW1lO1xuICAgICAgICBvcHRpb25zLnN0b3JlTmFtZSA9IG9wdGlvbnMuc3RvcmVOYW1lIHx8IGN1cnJlbnRDb25maWcuc3RvcmVOYW1lO1xuICAgIH1cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJvbWlzZTtcbiAgICBpZiAoIW9wdGlvbnMubmFtZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZSQxLnJlamVjdCgnSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gbmV3IFByb21pc2UkMShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUob3B0aW9ucy5uYW1lICsgJy8nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfZ2V0S2V5UHJlZml4KG9wdGlvbnMsIHNlbGYuX2RlZmF1bHRDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoa2V5UHJlZml4KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gbG9jYWxTdG9yYWdlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoaSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5LmluZGV4T2Yoa2V5UHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZXhlY3V0ZUNhbGxiYWNrKHByb21pc2UsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxudmFyIGxvY2FsU3RvcmFnZVdyYXBwZXIgPSB7XG4gICAgX2RyaXZlcjogJ2xvY2FsU3RvcmFnZVdyYXBwZXInLFxuICAgIF9pbml0U3RvcmFnZTogX2luaXRTdG9yYWdlJDIsXG4gICAgX3N1cHBvcnQ6IGlzTG9jYWxTdG9yYWdlVmFsaWQoKSxcbiAgICBpdGVyYXRlOiBpdGVyYXRlJDIsXG4gICAgZ2V0SXRlbTogZ2V0SXRlbSQyLFxuICAgIHNldEl0ZW06IHNldEl0ZW0kMixcbiAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtJDIsXG4gICAgY2xlYXI6IGNsZWFyJDIsXG4gICAgbGVuZ3RoOiBsZW5ndGgkMixcbiAgICBrZXk6IGtleSQyLFxuICAgIGtleXM6IGtleXMkMixcbiAgICBkcm9wSW5zdGFuY2U6IGRyb3BJbnN0YW5jZSQyXG59O1xuXG52YXIgc2FtZVZhbHVlID0gZnVuY3Rpb24gc2FtZVZhbHVlKHgsIHkpIHtcbiAgICByZXR1cm4geCA9PT0geSB8fCB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT09ICdudW1iZXInICYmIGlzTmFOKHgpICYmIGlzTmFOKHkpO1xufTtcblxudmFyIGluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMoYXJyYXksIHNlYXJjaEVsZW1lbnQpIHtcbiAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAoc2FtZVZhbHVlKGFycmF5W2ldLCBzZWFyY2hFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuLy8gRHJpdmVycyBhcmUgc3RvcmVkIGhlcmUgd2hlbiBgZGVmaW5lRHJpdmVyKClgIGlzIGNhbGxlZC5cbi8vIFRoZXkgYXJlIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyBvZiBsb2NhbEZvcmFnZS5cbnZhciBEZWZpbmVkRHJpdmVycyA9IHt9O1xuXG52YXIgRHJpdmVyU3VwcG9ydCA9IHt9O1xuXG52YXIgRGVmYXVsdERyaXZlcnMgPSB7XG4gICAgSU5ERVhFRERCOiBhc3luY1N0b3JhZ2UsXG4gICAgV0VCU1FMOiB3ZWJTUUxTdG9yYWdlLFxuICAgIExPQ0FMU1RPUkFHRTogbG9jYWxTdG9yYWdlV3JhcHBlclxufTtcblxudmFyIERlZmF1bHREcml2ZXJPcmRlciA9IFtEZWZhdWx0RHJpdmVycy5JTkRFWEVEREIuX2RyaXZlciwgRGVmYXVsdERyaXZlcnMuV0VCU1FMLl9kcml2ZXIsIERlZmF1bHREcml2ZXJzLkxPQ0FMU1RPUkFHRS5fZHJpdmVyXTtcblxudmFyIE9wdGlvbmFsRHJpdmVyTWV0aG9kcyA9IFsnZHJvcEluc3RhbmNlJ107XG5cbnZhciBMaWJyYXJ5TWV0aG9kcyA9IFsnY2xlYXInLCAnZ2V0SXRlbScsICdpdGVyYXRlJywgJ2tleScsICdrZXlzJywgJ2xlbmd0aCcsICdyZW1vdmVJdGVtJywgJ3NldEl0ZW0nXS5jb25jYXQoT3B0aW9uYWxEcml2ZXJNZXRob2RzKTtcblxudmFyIERlZmF1bHRDb25maWcgPSB7XG4gICAgZGVzY3JpcHRpb246ICcnLFxuICAgIGRyaXZlcjogRGVmYXVsdERyaXZlck9yZGVyLnNsaWNlKCksXG4gICAgbmFtZTogJ2xvY2FsZm9yYWdlJyxcbiAgICAvLyBEZWZhdWx0IERCIHNpemUgaXMgX0pVU1QgVU5ERVJfIDVNQiwgYXMgaXQncyB0aGUgaGlnaGVzdCBzaXplXG4gICAgLy8gd2UgY2FuIHVzZSB3aXRob3V0IGEgcHJvbXB0LlxuICAgIHNpemU6IDQ5ODA3MzYsXG4gICAgc3RvcmVOYW1lOiAna2V5dmFsdWVwYWlycycsXG4gICAgdmVyc2lvbjogMS4wXG59O1xuXG5mdW5jdGlvbiBjYWxsV2hlblJlYWR5KGxvY2FsRm9yYWdlSW5zdGFuY2UsIGxpYnJhcnlNZXRob2QpIHtcbiAgICBsb2NhbEZvcmFnZUluc3RhbmNlW2xpYnJhcnlNZXRob2RdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiBsb2NhbEZvcmFnZUluc3RhbmNlLnJlYWR5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxGb3JhZ2VJbnN0YW5jZVtsaWJyYXJ5TWV0aG9kXS5hcHBseShsb2NhbEZvcmFnZUluc3RhbmNlLCBfYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9rZXkgaW4gYXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShfa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShhcmdbX2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF1bX2tleV0gPSBhcmdbX2tleV0uc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c1swXVtfa2V5XSA9IGFyZ1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhcmd1bWVudHNbMF07XG59XG5cbnZhciBMb2NhbEZvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2NhbEZvcmFnZShvcHRpb25zKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2NhbEZvcmFnZSk7XG5cbiAgICAgICAgZm9yICh2YXIgZHJpdmVyVHlwZUtleSBpbiBEZWZhdWx0RHJpdmVycykge1xuICAgICAgICAgICAgaWYgKERlZmF1bHREcml2ZXJzLmhhc093blByb3BlcnR5KGRyaXZlclR5cGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlciA9IERlZmF1bHREcml2ZXJzW2RyaXZlclR5cGVLZXldO1xuICAgICAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gZHJpdmVyLl9kcml2ZXI7XG4gICAgICAgICAgICAgICAgdGhpc1tkcml2ZXJUeXBlS2V5XSA9IGRyaXZlck5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIURlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gd2FpdCBmb3IgdGhlIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHRoZSBkZWZhdWx0IGRyaXZlcnMgY2FuIGJlIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gYSBibG9ja2luZyBtYW5uZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbmVEcml2ZXIoZHJpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWZhdWx0Q29uZmlnID0gZXh0ZW5kKHt9LCBEZWZhdWx0Q29uZmlnKTtcbiAgICAgICAgdGhpcy5fY29uZmlnID0gZXh0ZW5kKHt9LCB0aGlzLl9kZWZhdWx0Q29uZmlnLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZHJpdmVyU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faW5pdERyaXZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RiSW5mbyA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fd3JhcExpYnJhcnlNZXRob2RzV2l0aFJlYWR5KCk7XG4gICAgICAgIHRoaXMuc2V0RHJpdmVyKHRoaXMuX2NvbmZpZy5kcml2ZXIpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgIH1cblxuICAgIC8vIFNldCBhbnkgY29uZmlnIHZhbHVlcyBmb3IgbG9jYWxGb3JhZ2U7IGNhbiBiZSBjYWxsZWQgYW55dGltZSBiZWZvcmVcbiAgICAvLyB0aGUgZmlyc3QgQVBJIGNhbGwgKGUuZy4gYGdldEl0ZW1gLCBgc2V0SXRlbWApLlxuICAgIC8vIFdlIGxvb3AgdGhyb3VnaCBvcHRpb25zIHNvIHdlIGRvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBjb25maWdcbiAgICAvLyB2YWx1ZXMuXG5cblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5jb25maWcgPSBmdW5jdGlvbiBjb25maWcob3B0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgb3B0aW9ucyBhcmd1bWVudCBpcyBhbiBvYmplY3QsIHdlIHVzZSBpdCB0byBzZXQgdmFsdWVzLlxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHJldHVybiBlaXRoZXIgYSBzcGVjaWZpZWQgY29uZmlnIHZhbHVlIG9yIGFsbFxuICAgICAgICAvLyBjb25maWcgdmFsdWVzLlxuICAgICAgICBpZiAoKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRpb25zKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBJZiBsb2NhbGZvcmFnZSBpcyByZWFkeSBhbmQgZnVsbHkgaW5pdGlhbGl6ZWQsIHdlIGNhbid0IHNldFxuICAgICAgICAgICAgLy8gYW55IG5ldyBjb25maWd1cmF0aW9uIHZhbHVlcy4gSW5zdGVhZCwgd2UgcmV0dXJuIGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkNhbid0IGNhbGwgY29uZmlnKCkgYWZ0ZXIgbG9jYWxmb3JhZ2UgXCIgKyAnaGFzIGJlZW4gdXNlZC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09ICdzdG9yZU5hbWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNbaV0gPSBvcHRpb25zW2ldLnJlcGxhY2UoL1xcVy9nLCAnXycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpID09PSAndmVyc2lvbicgJiYgdHlwZW9mIG9wdGlvbnNbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0RhdGFiYXNlIHZlcnNpb24gbXVzdCBiZSBhIG51bWJlci4nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25maWdbaV0gPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZnRlciBhbGwgY29uZmlnIG9wdGlvbnMgYXJlIHNldCBhbmRcbiAgICAgICAgICAgIC8vIHRoZSBkcml2ZXIgb3B0aW9uIGlzIHVzZWQsIHRyeSBzZXR0aW5nIGl0XG4gICAgICAgICAgICBpZiAoJ2RyaXZlcicgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmRyaXZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldERyaXZlcih0aGlzLl9jb25maWcuZHJpdmVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnW29wdGlvbnNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBVc2VkIHRvIGRlZmluZSBhIGN1c3RvbSBkcml2ZXIsIHNoYXJlZCBhY3Jvc3MgYWxsIGluc3RhbmNlcyBvZlxuICAgIC8vIGxvY2FsRm9yYWdlLlxuXG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZGVmaW5lRHJpdmVyID0gZnVuY3Rpb24gZGVmaW5lRHJpdmVyKGRyaXZlck9iamVjdCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSQxKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBkcml2ZXJPYmplY3QuX2RyaXZlcjtcbiAgICAgICAgICAgICAgICB2YXIgY29tcGxpYW5jZUVycm9yID0gbmV3IEVycm9yKCdDdXN0b20gZHJpdmVyIG5vdCBjb21wbGlhbnQ7IHNlZSAnICsgJ2h0dHBzOi8vbW96aWxsYS5naXRodWIuaW8vbG9jYWxGb3JhZ2UvI2RlZmluZWRyaXZlcicpO1xuXG4gICAgICAgICAgICAgICAgLy8gQSBkcml2ZXIgbmFtZSBzaG91bGQgYmUgZGVmaW5lZCBhbmQgbm90IG92ZXJsYXAgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsaWJyYXJ5LWRlZmluZWQsIGRlZmF1bHQgZHJpdmVycy5cbiAgICAgICAgICAgICAgICBpZiAoIWRyaXZlck9iamVjdC5fZHJpdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChjb21wbGlhbmNlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRyaXZlck1ldGhvZHMgPSBMaWJyYXJ5TWV0aG9kcy5jb25jYXQoJ19pbml0U3RvcmFnZScpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkcml2ZXJNZXRob2RzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcml2ZXJNZXRob2ROYW1lID0gZHJpdmVyTWV0aG9kc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBwcm9wZXJ0eSBpcyB0aGVyZSxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGEgbWV0aG9kIGV2ZW4gd2hlbiBvcHRpb25hbFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSZXF1aXJlZCA9ICFpbmNsdWRlcyhPcHRpb25hbERyaXZlck1ldGhvZHMsIGRyaXZlck1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGlzUmVxdWlyZWQgfHwgZHJpdmVyT2JqZWN0W2RyaXZlck1ldGhvZE5hbWVdKSAmJiB0eXBlb2YgZHJpdmVyT2JqZWN0W2RyaXZlck1ldGhvZE5hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoY29tcGxpYW5jZUVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjb25maWd1cmVNaXNzaW5nTWV0aG9kcyA9IGZ1bmN0aW9uIGNvbmZpZ3VyZU1pc3NpbmdNZXRob2RzKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5ID0gZnVuY3Rpb24gbWV0aG9kTm90SW1wbGVtZW50ZWRGYWN0b3J5KG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdNZXRob2QgJyArIG1ldGhvZE5hbWUgKyAnIGlzIG5vdCBpbXBsZW1lbnRlZCBieSB0aGUgY3VycmVudCBkcml2ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UkMS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVDYWxsYmFjayhwcm9taXNlLCBhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbGVuID0gT3B0aW9uYWxEcml2ZXJNZXRob2RzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9uYWxEcml2ZXJNZXRob2QgPSBPcHRpb25hbERyaXZlck1ldGhvZHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkcml2ZXJPYmplY3Rbb3B0aW9uYWxEcml2ZXJNZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJpdmVyT2JqZWN0W29wdGlvbmFsRHJpdmVyTWV0aG9kXSA9IG1ldGhvZE5vdEltcGxlbWVudGVkRmFjdG9yeShvcHRpb25hbERyaXZlck1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgY29uZmlndXJlTWlzc2luZ01ldGhvZHMoKTtcblxuICAgICAgICAgICAgICAgIHZhciBzZXREcml2ZXJTdXBwb3J0ID0gZnVuY3Rpb24gc2V0RHJpdmVyU3VwcG9ydChzdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKCdSZWRlZmluaW5nIExvY2FsRm9yYWdlIGRyaXZlcjogJyArIGRyaXZlck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIERlZmluZWREcml2ZXJzW2RyaXZlck5hbWVdID0gZHJpdmVyT2JqZWN0O1xuICAgICAgICAgICAgICAgICAgICBEcml2ZXJTdXBwb3J0W2RyaXZlck5hbWVdID0gc3VwcG9ydDtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXNlIGEgdGhlbiwgc28gdGhhdCB3ZSBjYW4gZGVmaW5lXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyaXZlcnMgdGhhdCBoYXZlIHNpbXBsZSBfc3VwcG9ydCBtZXRob2RzXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIGEgYmxvY2tpbmcgbWFubmVyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKCdfc3VwcG9ydCcgaW4gZHJpdmVyT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcml2ZXJPYmplY3QuX3N1cHBvcnQgJiYgdHlwZW9mIGRyaXZlck9iamVjdC5fc3VwcG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJpdmVyT2JqZWN0Ll9zdXBwb3J0KCkudGhlbihzZXREcml2ZXJTdXBwb3J0LCByZWplY3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RHJpdmVyU3VwcG9ydCghIWRyaXZlck9iamVjdC5fc3VwcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXREcml2ZXJTdXBwb3J0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgTG9jYWxGb3JhZ2UucHJvdG90eXBlLmRyaXZlciA9IGZ1bmN0aW9uIGRyaXZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyaXZlciB8fCBudWxsO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZ2V0RHJpdmVyID0gZnVuY3Rpb24gZ2V0RHJpdmVyKGRyaXZlck5hbWUsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBnZXREcml2ZXJQcm9taXNlID0gRGVmaW5lZERyaXZlcnNbZHJpdmVyTmFtZV0gPyBQcm9taXNlJDEucmVzb2x2ZShEZWZpbmVkRHJpdmVyc1tkcml2ZXJOYW1lXSkgOiBQcm9taXNlJDEucmVqZWN0KG5ldyBFcnJvcignRHJpdmVyIG5vdCBmb3VuZC4nKSk7XG5cbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhnZXREcml2ZXJQcm9taXNlLCBjYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBnZXREcml2ZXJQcm9taXNlO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuZ2V0U2VyaWFsaXplciA9IGZ1bmN0aW9uIGdldFNlcmlhbGl6ZXIoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlcmlhbGl6ZXJQcm9taXNlID0gUHJvbWlzZSQxLnJlc29sdmUobG9jYWxmb3JhZ2VTZXJpYWxpemVyKTtcbiAgICAgICAgZXhlY3V0ZVR3b0NhbGxiYWNrcyhzZXJpYWxpemVyUHJvbWlzZSwgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplclByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5yZWFkeSA9IGZ1bmN0aW9uIHJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgcHJvbWlzZSA9IHNlbGYuX2RyaXZlclNldC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLl9yZWFkeSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gc2VsZi5faW5pdERyaXZlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fcmVhZHk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4ZWN1dGVUd29DYWxsYmFja3MocHJvbWlzZSwgY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5zZXREcml2ZXIgPSBmdW5jdGlvbiBzZXREcml2ZXIoZHJpdmVycywgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNBcnJheShkcml2ZXJzKSkge1xuICAgICAgICAgICAgZHJpdmVycyA9IFtkcml2ZXJzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdXBwb3J0ZWREcml2ZXJzID0gdGhpcy5fZ2V0U3VwcG9ydGVkRHJpdmVycyhkcml2ZXJzKTtcblxuICAgICAgICBmdW5jdGlvbiBzZXREcml2ZXJUb0NvbmZpZygpIHtcbiAgICAgICAgICAgIHNlbGYuX2NvbmZpZy5kcml2ZXIgPSBzZWxmLmRyaXZlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZXh0ZW5kU2VsZldpdGhEcml2ZXIoZHJpdmVyKSB7XG4gICAgICAgICAgICBzZWxmLl9leHRlbmQoZHJpdmVyKTtcbiAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG5cbiAgICAgICAgICAgIHNlbGYuX3JlYWR5ID0gc2VsZi5faW5pdFN0b3JhZ2Uoc2VsZi5fY29uZmlnKTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmLl9yZWFkeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGluaXREcml2ZXIoc3VwcG9ydGVkRHJpdmVycykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudERyaXZlckluZGV4ID0gMDtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRyaXZlclByb21pc2VMb29wKCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudERyaXZlckluZGV4IDwgc3VwcG9ydGVkRHJpdmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gc3VwcG9ydGVkRHJpdmVyc1tjdXJyZW50RHJpdmVySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudERyaXZlckluZGV4Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2RiSW5mbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZWFkeSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmdldERyaXZlcihkcml2ZXJOYW1lKS50aGVuKGV4dGVuZFNlbGZXaXRoRHJpdmVyKVtcImNhdGNoXCJdKGRyaXZlclByb21pc2VMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldERyaXZlclRvQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTm8gYXZhaWxhYmxlIHN0b3JhZ2UgbWV0aG9kIGZvdW5kLicpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9kcml2ZXJTZXQgPSBQcm9taXNlJDEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2RyaXZlclNldDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZHJpdmVyUHJvbWlzZUxvb3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBhIGRyaXZlciBpbml0aWFsaXphdGlvbiBpbiBwcm9ncmVzc1xuICAgICAgICAvLyBzbyB3YWl0IGZvciBpdCB0byBmaW5pc2ggaW4gb3JkZXIgdG8gYXZvaWQgYSBwb3NzaWJsZVxuICAgICAgICAvLyByYWNlIGNvbmRpdGlvbiB0byBzZXQgX2RiSW5mb1xuICAgICAgICB2YXIgb2xkRHJpdmVyU2V0RG9uZSA9IHRoaXMuX2RyaXZlclNldCAhPT0gbnVsbCA/IHRoaXMuX2RyaXZlclNldFtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlJDEucmVzb2x2ZSgpO1xuICAgICAgICB9KSA6IFByb21pc2UkMS5yZXNvbHZlKCk7XG5cbiAgICAgICAgdGhpcy5fZHJpdmVyU2V0ID0gb2xkRHJpdmVyU2V0RG9uZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gc3VwcG9ydGVkRHJpdmVyc1swXTtcbiAgICAgICAgICAgIHNlbGYuX2RiSW5mbyA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLl9yZWFkeSA9IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmdldERyaXZlcihkcml2ZXJOYW1lKS50aGVuKGZ1bmN0aW9uIChkcml2ZXIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9kcml2ZXIgPSBkcml2ZXIuX2RyaXZlcjtcbiAgICAgICAgICAgICAgICBzZXREcml2ZXJUb0NvbmZpZygpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSgpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2luaXREcml2ZXIgPSBpbml0RHJpdmVyKHN1cHBvcnRlZERyaXZlcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0RHJpdmVyVG9Db25maWcoKTtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcignTm8gYXZhaWxhYmxlIHN0b3JhZ2UgbWV0aG9kIGZvdW5kLicpO1xuICAgICAgICAgICAgc2VsZi5fZHJpdmVyU2V0ID0gUHJvbWlzZSQxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5fZHJpdmVyU2V0O1xuICAgICAgICB9KTtcblxuICAgICAgICBleGVjdXRlVHdvQ2FsbGJhY2tzKHRoaXMuX2RyaXZlclNldCwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJpdmVyU2V0O1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuc3VwcG9ydHMgPSBmdW5jdGlvbiBzdXBwb3J0cyhkcml2ZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiAhIURyaXZlclN1cHBvcnRbZHJpdmVyTmFtZV07XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5fZXh0ZW5kID0gZnVuY3Rpb24gX2V4dGVuZChsaWJyYXJ5TWV0aG9kc0FuZFByb3BlcnRpZXMpIHtcbiAgICAgICAgZXh0ZW5kKHRoaXMsIGxpYnJhcnlNZXRob2RzQW5kUHJvcGVydGllcyk7XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5fZ2V0U3VwcG9ydGVkRHJpdmVycyA9IGZ1bmN0aW9uIF9nZXRTdXBwb3J0ZWREcml2ZXJzKGRyaXZlcnMpIHtcbiAgICAgICAgdmFyIHN1cHBvcnRlZERyaXZlcnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRyaXZlcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkcml2ZXJOYW1lID0gZHJpdmVyc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzKGRyaXZlck5hbWUpKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkRHJpdmVycy5wdXNoKGRyaXZlck5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWREcml2ZXJzO1xuICAgIH07XG5cbiAgICBMb2NhbEZvcmFnZS5wcm90b3R5cGUuX3dyYXBMaWJyYXJ5TWV0aG9kc1dpdGhSZWFkeSA9IGZ1bmN0aW9uIF93cmFwTGlicmFyeU1ldGhvZHNXaXRoUmVhZHkoKSB7XG4gICAgICAgIC8vIEFkZCBhIHN0dWIgZm9yIGVhY2ggZHJpdmVyIEFQSSBtZXRob2QgdGhhdCBkZWxheXMgdGhlIGNhbGwgdG8gdGhlXG4gICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgZHJpdmVyIG1ldGhvZCB1bnRpbCBsb2NhbEZvcmFnZSBpcyByZWFkeS4gVGhlc2Ugc3R1YnNcbiAgICAgICAgLy8gd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZHJpdmVyIG1ldGhvZHMgYXMgc29vbiBhcyB0aGUgZHJpdmVyIGlzXG4gICAgICAgIC8vIGxvYWRlZCwgc28gdGhlcmUgaXMgbm8gcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gTGlicmFyeU1ldGhvZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGxXaGVuUmVhZHkodGhpcywgTGlicmFyeU1ldGhvZHNbaV0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIExvY2FsRm9yYWdlLnByb3RvdHlwZS5jcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2NhbEZvcmFnZShvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIExvY2FsRm9yYWdlO1xufSgpO1xuXG4vLyBUaGUgYWN0dWFsIGxvY2FsRm9yYWdlIG9iamVjdCB0aGF0IHdlIGV4cG9zZSBhcyBhIG1vZHVsZSBvciB2aWEgYVxuLy8gZ2xvYmFsLiBJdCdzIGV4dGVuZGVkIGJ5IHB1bGxpbmcgaW4gb25lIG9mIG91ciBvdGhlciBsaWJyYXJpZXMuXG5cblxudmFyIGxvY2FsZm9yYWdlX2pzID0gbmV3IExvY2FsRm9yYWdlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9jYWxmb3JhZ2VfanM7XG5cbn0se1wiM1wiOjN9XX0se30sWzRdKSg0KVxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/localforage/dist/localforage.js\n");

/***/ }),

/***/ "../../node_modules/next/dist/client/link.js":
/*!********************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/dist/client/link.js ***!
  \********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nvar _slicedToArray = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js\");\n\nvar _s = $RefreshSig$();\n\nvar _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/interopRequireWildcard.js\");\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"../../node_modules/react/index.js\"));\n\nvar _router = __webpack_require__(/*! ../next-server/lib/router/router */ \"../../node_modules/next/dist/next-server/lib/router/router.js\");\n\nvar _router2 = __webpack_require__(/*! ./router */ \"../../node_modules/next/dist/client/router.js\");\n\nvar _useIntersection = __webpack_require__(/*! ./use-intersection */ \"../../node_modules/next/dist/client/use-intersection.js\");\n\nvar prefetched = {};\n\nfunction prefetch(router, href, as, options) {\n  if ( false || !router) return;\n  if (!(0, _router.isLocalURL)(href)) return; // Prefetch the JSON page if asked (only in the client)\n  // We need to handle a prefetch error here since we may be\n  // loading with priority which can reject but we don't\n  // want to force navigation since this is only a prefetch\n\n  router.prefetch(href, as, options)[\"catch\"](function (err) {\n    if (true) {\n      // rethrow to show invalid URL errors\n      throw err;\n    }\n  });\n  var curLocale = options && typeof options.locale !== 'undefined' ? options.locale : router && router.locale; // Join on an invalid URI character\n\n  prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')] = true;\n}\n\nfunction isModifiedEvent(event) {\n  var target = event.currentTarget.target;\n  return target && target !== '_self' || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n  event.nativeEvent && event.nativeEvent.which === 2;\n}\n\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale) {\n  var nodeName = e.currentTarget.nodeName;\n\n  if (nodeName === 'A' && (isModifiedEvent(e) || !(0, _router.isLocalURL)(href))) {\n    // ignore click for browsers default behavior\n    return;\n  }\n\n  e.preventDefault(); //  avoid scroll for urls with anchor refs\n\n  if (scroll == null) {\n    scroll = as.indexOf('#') < 0;\n  } // replace state instead of push if prop is present\n\n\n  router[replace ? 'replace' : 'push'](href, as, {\n    shallow: shallow,\n    locale: locale,\n    scroll: scroll\n  });\n}\n\nfunction Link(props) {\n  _s();\n\n  if (true) {\n    var createPropError = function createPropError(args) {\n      return new Error(\"Failed prop type: The prop `\".concat(args.key, \"` expects a \").concat(args.expected, \" in `<Link>`, but got `\").concat(args.actual, \"` instead.\") + (true ? \"\\nOpen your browser's console to view the Component stack trace.\" : undefined));\n    }; // TypeScript trick for type-guarding:\n\n\n    var requiredPropsGuard = {\n      href: true\n    };\n    var requiredProps = Object.keys(requiredPropsGuard);\n    requiredProps.forEach(function (key) {\n      if (key === 'href') {\n        if (props[key] == null || typeof props[key] !== 'string' && typeof props[key] !== 'object') {\n          throw createPropError({\n            key: key,\n            expected: '`string` or `object`',\n            actual: props[key] === null ? 'null' : typeof props[key]\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // TypeScript trick for type-guarding:\n\n    var optionalPropsGuard = {\n      as: true,\n      replace: true,\n      scroll: true,\n      shallow: true,\n      passHref: true,\n      prefetch: true,\n      locale: true\n    };\n    var optionalProps = Object.keys(optionalPropsGuard);\n    optionalProps.forEach(function (key) {\n      var valType = typeof props[key];\n\n      if (key === 'as') {\n        if (props[key] && valType !== 'string' && valType !== 'object') {\n          throw createPropError({\n            key: key,\n            expected: '`string` or `object`',\n            actual: valType\n          });\n        }\n      } else if (key === 'locale') {\n        if (props[key] && valType !== 'string') {\n          throw createPropError({\n            key: key,\n            expected: '`string`',\n            actual: valType\n          });\n        }\n      } else if (key === 'replace' || key === 'scroll' || key === 'shallow' || key === 'passHref' || key === 'prefetch') {\n        if (props[key] != null && valType !== 'boolean') {\n          throw createPropError({\n            key: key,\n            expected: '`boolean`',\n            actual: valType\n          });\n        }\n      } else {\n        // TypeScript trick for type-guarding:\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        var _ = key;\n      }\n    }); // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n\n    var hasWarned = _react[\"default\"].useRef(false);\n\n    if (props.prefetch && !hasWarned.current) {\n      hasWarned.current = true;\n      console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated');\n    }\n  }\n\n  var p = props.prefetch !== false;\n  var router = (0, _router2.useRouter)();\n  var pathname = router && router.asPath || '/';\n\n  var _react$default$useMem = _react[\"default\"].useMemo(function () {\n    var _ref = (0, _router.resolveHref)(pathname, props.href, true),\n        _ref2 = _slicedToArray(_ref, 2),\n        resolvedHref = _ref2[0],\n        resolvedAs = _ref2[1];\n\n    return {\n      href: resolvedHref,\n      as: props.as ? (0, _router.resolveHref)(pathname, props.as) : resolvedAs || resolvedHref\n    };\n  }, [pathname, props.href, props.as]),\n      href = _react$default$useMem.href,\n      as = _react$default$useMem.as;\n\n  var children = props.children,\n      replace = props.replace,\n      shallow = props.shallow,\n      scroll = props.scroll,\n      locale = props.locale; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag\n\n  if (typeof children === 'string') {\n    children = /*#__PURE__*/_react[\"default\"].createElement(\"a\", null, children);\n  } // This will return the first child, if multiple are provided it will throw an error\n\n\n  var child = _react.Children.only(children);\n\n  var childRef = child && typeof child === 'object' && child.ref;\n\n  var _ref3 = (0, _useIntersection.useIntersection)({\n    rootMargin: '200px'\n  }),\n      _ref4 = _slicedToArray(_ref3, 2),\n      setIntersectionRef = _ref4[0],\n      isVisible = _ref4[1];\n\n  var setRef = _react[\"default\"].useCallback(function (el) {\n    setIntersectionRef(el);\n\n    if (childRef) {\n      if (typeof childRef === 'function') childRef(el);else if (typeof childRef === 'object') {\n        childRef.current = el;\n      }\n    }\n  }, [childRef, setIntersectionRef]);\n\n  (0, _react.useEffect)(function () {\n    var shouldPrefetch = isVisible && p && (0, _router.isLocalURL)(href);\n    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale;\n    var isPrefetched = prefetched[href + '%' + as + (curLocale ? '%' + curLocale : '')];\n\n    if (shouldPrefetch && !isPrefetched) {\n      prefetch(router, href, as, {\n        locale: curLocale\n      });\n    }\n  }, [as, href, isVisible, locale, p, router]);\n  var childProps = {\n    ref: setRef,\n    onClick: function onClick(e) {\n      if (child.props && typeof child.props.onClick === 'function') {\n        child.props.onClick(e);\n      }\n\n      if (!e.defaultPrevented) {\n        linkClicked(e, router, href, as, replace, shallow, scroll, locale);\n      }\n    }\n  };\n\n  childProps.onMouseEnter = function (e) {\n    if (!(0, _router.isLocalURL)(href)) return;\n\n    if (child.props && typeof child.props.onMouseEnter === 'function') {\n      child.props.onMouseEnter(e);\n    }\n\n    prefetch(router, href, as, {\n      priority: true\n    });\n  }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n  // defined, we specify the current 'href', so that repetition is not needed by the user\n\n\n  if (props.passHref || child.type === 'a' && !('href' in child.props)) {\n    var curLocale = typeof locale !== 'undefined' ? locale : router && router.locale; // we only render domain locales if we are currently on a domain locale\n    // so that locale links are still visitable in development/preview envs\n\n    var localeDomain = router && router.isLocaleDomain && (0, _router.getDomainLocale)(as, curLocale, router && router.locales, router && router.domainLocales);\n    childProps.href = localeDomain || (0, _router.addBasePath)((0, _router.addLocale)(as, curLocale, router && router.defaultLocale));\n  }\n\n  return /*#__PURE__*/_react[\"default\"].cloneElement(child, childProps);\n}\n\n_s(Link, \"7cX92ILFgstKFyzTMH+g73G4t5k=\");\n\n_c = Link;\nvar _default = Link;\nexports[\"default\"] = _default;\n\nvar _c;\n\n$RefreshReg$(_c, \"Link\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ \"../../node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC9saW5rLnRzeD81ZTRiIl0sIm5hbWVzIjpbInByZWZldGNoZWQiLCJyb3V0ZXIiLCJlcnIiLCJjdXJMb2NhbGUiLCJvcHRpb25zIiwiaHJlZiIsImV2ZW50IiwidGFyZ2V0IiwiZSIsIm5vZGVOYW1lIiwiaXNNb2RpZmllZEV2ZW50Iiwic2Nyb2xsIiwiYXMiLCJyZXBsYWNlIiwic2hhbGxvdyIsImxvY2FsZSIsImFyZ3MiLCJrZXkiLCJleHBlY3RlZCIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJPYmplY3QiLCJwcm9wcyIsImNyZWF0ZVByb3BFcnJvciIsImFjdHVhbCIsIl8iLCJvcHRpb25hbFByb3BzR3VhcmQiLCJwYXNzSHJlZiIsInByZWZldGNoIiwib3B0aW9uYWxQcm9wcyIsInZhbFR5cGUiLCJoYXNXYXJuZWQiLCJSZWFjdCIsImNvbnNvbGUiLCJwIiwicGF0aG5hbWUiLCJyZXNvbHZlZEFzIiwiY2hpbGRyZW4iLCJjaGlsZCIsIkNoaWxkcmVuIiwiY2hpbGRSZWYiLCJyb290TWFyZ2luIiwic2V0UmVmIiwiZWwiLCJzZXRJbnRlcnNlY3Rpb25SZWYiLCJzaG91bGRQcmVmZXRjaCIsImlzVmlzaWJsZSIsImlzUHJlZmV0Y2hlZCIsImNoaWxkUHJvcHMiLCJyZWYiLCJvbkNsaWNrIiwibGlua0NsaWNrZWQiLCJwcmlvcml0eSIsImxvY2FsZURvbWFpbiIsIkxpbmsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7O0FBU0E7O0FBQ0E7O0FBdUJBLElBQU1BLFVBQTJDLEdBQWpEOztBQUVBLDZDQUtRO0FBQ04sTUFBSSxVQUFpQyxDQUFyQyxRQUE4QztBQUM5QyxNQUFJLENBQUMsd0JBQUwsSUFBSyxDQUFMLEVBQXVCLE9BRmpCLENBR047QUFDQTtBQUNBO0FBQ0E7O0FBQ0FDLFFBQU0sQ0FBTkEscUNBQTBDQyxhQUFELEVBQVM7QUFDaEQsY0FBMkM7QUFD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LENBQUM5QixDQUFDLENBQU4sa0JBQXlCO0FBQ3ZCMkMsbUJBQVcsZ0RBQVhBLE1BQVcsQ0FBWEE7QUFFSDtBQWRIO0FBS0ksR0FMSjs7QUFpQkFILFlBQVUsQ0FBVkEsZUFBMkJ4QyxXQUFELEVBQXlCO0FBQ2pELFFBQUksQ0FBQyx3QkFBTCxJQUFLLENBQUwsRUFBdUI7O0FBQ3ZCLFFBQUk4QixLQUFLLENBQUxBLFNBQWUsT0FBT0EsS0FBSyxDQUFMQSxNQUFQLGlCQUFuQixZQUFtRTtBQUNqRUEsV0FBSyxDQUFMQTtBQUVGVjs7QUFBQUEsWUFBUSxtQkFBbUI7QUFBRXdCLGNBQVEsRUFBckN4QjtBQUEyQixLQUFuQixDQUFSQTtBQUxGb0IsSUEvS3VELENBdUx2RDtBQUNBOzs7QUFDQSxNQUFJMUIsS0FBSyxDQUFMQSxZQUFtQmdCLEtBQUssQ0FBTEEsZ0JBQXNCLEVBQUUsVUFBVUEsS0FBSyxDQUE5RCxLQUE2QyxDQUE3QyxFQUF3RTtBQUN0RSxRQUFNbkMsU0FBUyxHQUNiLHlDQUF5Q0YsTUFBTSxJQUFJQSxNQUFNLENBRDNELE9BRHNFLENBSXRFO0FBQ0E7O0FBQ0EsUUFBTW9ELFlBQVksR0FDaEJwRCxNQUFNLElBQ05BLE1BQU0sQ0FETkEsa0JBRUEsNENBR0VBLE1BQU0sSUFBSUEsTUFBTSxDQUhsQixTQUlFQSxNQUFNLElBQUlBLE1BQU0sQ0FQcEIsYUFHRSxDQUhGO0FBVUErQyxjQUFVLENBQVZBLE9BQ0VLLFlBQVksSUFDWix5QkFBWSxzQ0FBeUJwRCxNQUFNLElBQUlBLE1BQU0sQ0FGdkQrQyxhQUVjLENBQVosQ0FGRkE7QUFLRjs7QUFBQSxzQkFBT2hCLHNDQUFQLFVBQU9BLENBQVA7OztHQTlNRixJOztLQUFBLEk7ZUFpTmVzQixJIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2xpbmsuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgQ2hpbGRyZW4sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHtcbiAgYWRkQmFzZVBhdGgsXG4gIGFkZExvY2FsZSxcbiAgZ2V0RG9tYWluTG9jYWxlLFxuICBpc0xvY2FsVVJMLFxuICBOZXh0Um91dGVyLFxuICBQcmVmZXRjaE9wdGlvbnMsXG4gIHJlc29sdmVIcmVmLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IHVzZVJvdXRlciB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgdXNlSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi91c2UtaW50ZXJzZWN0aW9uJ1xuXG50eXBlIFVybCA9IHN0cmluZyB8IFVybE9iamVjdFxudHlwZSBSZXF1aXJlZEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IG5ldmVyIDogS1xufVtrZXlvZiBUXVxudHlwZSBPcHRpb25hbEtleXM8VD4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHt9IGV4dGVuZHMgUGljazxULCBLPiA/IEsgOiBuZXZlclxufVtrZXlvZiBUXVxuXG5leHBvcnQgdHlwZSBMaW5rUHJvcHMgPSB7XG4gIGhyZWY6IFVybFxuICBhcz86IFVybFxuICByZXBsYWNlPzogYm9vbGVhblxuICBzY3JvbGw/OiBib29sZWFuXG4gIHNoYWxsb3c/OiBib29sZWFuXG4gIHBhc3NIcmVmPzogYm9vbGVhblxuICBwcmVmZXRjaD86IGJvb2xlYW5cbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbn1cbnR5cGUgTGlua1Byb3BzUmVxdWlyZWQgPSBSZXF1aXJlZEtleXM8TGlua1Byb3BzPlxudHlwZSBMaW5rUHJvcHNPcHRpb25hbCA9IE9wdGlvbmFsS2V5czxMaW5rUHJvcHM+XG5cbmNvbnN0IHByZWZldGNoZWQ6IHsgW2NhY2hlS2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fVxuXG5mdW5jdGlvbiBwcmVmZXRjaChcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnNcbik6IHZvaWQge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIXJvdXRlcikgcmV0dXJuXG4gIGlmICghaXNMb2NhbFVSTChocmVmKSkgcmV0dXJuXG4gIC8vIFByZWZldGNoIHRoZSBKU09OIHBhZ2UgaWYgYXNrZWQgKG9ubHkgaW4gdGhlIGNsaWVudClcbiAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAvLyBsb2FkaW5nIHdpdGggcHJpb3JpdHkgd2hpY2ggY2FuIHJlamVjdCBidXQgd2UgZG9uJ3RcbiAgLy8gd2FudCB0byBmb3JjZSBuYXZpZ2F0aW9uIHNpbmNlIHRoaXMgaXMgb25seSBhIHByZWZldGNoXG4gIHJvdXRlci5wcmVmZXRjaChocmVmLCBhcywgb3B0aW9ucykuY2F0Y2goKGVycikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyByZXRocm93IHRvIHNob3cgaW52YWxpZCBVUkwgZXJyb3JzXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH0pXG4gIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgb3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IG9wdGlvbnMubG9jYWxlXG4gICAgICA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG5cbiAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcbiAgcHJlZmV0Y2hlZFtocmVmICsgJyUnICsgYXMgKyAoY3VyTG9jYWxlID8gJyUnICsgY3VyTG9jYWxlIDogJycpXSA9IHRydWVcbn1cblxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50KTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgdGFyZ2V0IH0gPSBldmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50XG4gIHJldHVybiAoXG4gICAgKHRhcmdldCAmJiB0YXJnZXQgIT09ICdfc2VsZicpIHx8XG4gICAgZXZlbnQubWV0YUtleSB8fFxuICAgIGV2ZW50LmN0cmxLZXkgfHxcbiAgICBldmVudC5zaGlmdEtleSB8fFxuICAgIGV2ZW50LmFsdEtleSB8fCAvLyB0cmlnZ2VycyByZXNvdXJjZSBkb3dubG9hZFxuICAgIChldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMilcbiAgKVxufVxuXG5mdW5jdGlvbiBsaW5rQ2xpY2tlZChcbiAgZTogUmVhY3QuTW91c2VFdmVudCxcbiAgcm91dGVyOiBOZXh0Um91dGVyLFxuICBocmVmOiBzdHJpbmcsXG4gIGFzOiBzdHJpbmcsXG4gIHJlcGxhY2U/OiBib29sZWFuLFxuICBzaGFsbG93PzogYm9vbGVhbixcbiAgc2Nyb2xsPzogYm9vbGVhbixcbiAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2Vcbik6IHZvaWQge1xuICBjb25zdCB7IG5vZGVOYW1lIH0gPSBlLmN1cnJlbnRUYXJnZXRcblxuICBpZiAobm9kZU5hbWUgPT09ICdBJyAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8ICFpc0xvY2FsVVJMKGhyZWYpKSkge1xuICAgIC8vIGlnbm9yZSBjbGljayBmb3IgYnJvd3NlcuKAmXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIHJldHVyblxuICB9XG5cbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG5cbiAgLy8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG4gIGlmIChzY3JvbGwgPT0gbnVsbCkge1xuICAgIHNjcm9sbCA9IGFzLmluZGV4T2YoJyMnKSA8IDBcbiAgfVxuXG4gIC8vIHJlcGxhY2Ugc3RhdGUgaW5zdGVhZCBvZiBwdXNoIGlmIHByb3AgaXMgcHJlc2VudFxuICByb3V0ZXJbcmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICBzaGFsbG93LFxuICAgIGxvY2FsZSxcbiAgICBzY3JvbGwsXG4gIH0pXG59XG5cbmZ1bmN0aW9uIExpbmsocHJvcHM6IFJlYWN0LlByb3BzV2l0aENoaWxkcmVuPExpbmtQcm9wcz4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJnczoge1xuICAgICAga2V5OiBzdHJpbmdcbiAgICAgIGV4cGVjdGVkOiBzdHJpbmdcbiAgICAgIGFjdHVhbDogc3RyaW5nXG4gICAgfSkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICAgICAgYEZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIFxcYCR7YXJncy5rZXl9XFxgIGV4cGVjdHMgYSAke2FyZ3MuZXhwZWN0ZWR9IGluIFxcYDxMaW5rPlxcYCwgYnV0IGdvdCBcXGAke2FyZ3MuYWN0dWFsfVxcYCBpbnN0ZWFkLmAgK1xuICAgICAgICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCJcbiAgICAgICAgICAgIDogJycpXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCByZXF1aXJlZFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNSZXF1aXJlZCwgdHJ1ZT4gPSB7XG4gICAgICBocmVmOiB0cnVlLFxuICAgIH0gYXMgY29uc3RcbiAgICBjb25zdCByZXF1aXJlZFByb3BzOiBMaW5rUHJvcHNSZXF1aXJlZFtdID0gT2JqZWN0LmtleXMoXG4gICAgICByZXF1aXJlZFByb3BzR3VhcmRcbiAgICApIGFzIExpbmtQcm9wc1JlcXVpcmVkW11cbiAgICByZXF1aXJlZFByb3BzLmZvckVhY2goKGtleTogTGlua1Byb3BzUmVxdWlyZWQpID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdocmVmJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJvcHNba2V5XSA9PSBudWxsIHx8XG4gICAgICAgICAgKHR5cGVvZiBwcm9wc1trZXldICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgcHJvcHNba2V5XSAhPT0gJ29iamVjdCcpXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogcHJvcHNba2V5XSA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBwcm9wc1trZXldLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICBjb25zdCBvcHRpb25hbFByb3BzR3VhcmQ6IFJlY29yZDxMaW5rUHJvcHNPcHRpb25hbCwgdHJ1ZT4gPSB7XG4gICAgICBhczogdHJ1ZSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICBzY3JvbGw6IHRydWUsXG4gICAgICBzaGFsbG93OiB0cnVlLFxuICAgICAgcGFzc0hyZWY6IHRydWUsXG4gICAgICBwcmVmZXRjaDogdHJ1ZSxcbiAgICAgIGxvY2FsZTogdHJ1ZSxcbiAgICB9IGFzIGNvbnN0XG4gICAgY29uc3Qgb3B0aW9uYWxQcm9wczogTGlua1Byb3BzT3B0aW9uYWxbXSA9IE9iamVjdC5rZXlzKFxuICAgICAgb3B0aW9uYWxQcm9wc0d1YXJkXG4gICAgKSBhcyBMaW5rUHJvcHNPcHRpb25hbFtdXG4gICAgb3B0aW9uYWxQcm9wcy5mb3JFYWNoKChrZXk6IExpbmtQcm9wc09wdGlvbmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWxUeXBlID0gdHlwZW9mIHByb3BzW2tleV1cblxuICAgICAgaWYgKGtleSA9PT0gJ2FzJykge1xuICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSAnc3RyaW5nJyAmJiB2YWxUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBleHBlY3RlZDogJ2BzdHJpbmdgIG9yIGBvYmplY3RgJyxcbiAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZSxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2xvY2FsZScpIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gJiYgdmFsVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgc3RyaW5nYCcsXG4gICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGUsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAga2V5ID09PSAncmVwbGFjZScgfHxcbiAgICAgICAga2V5ID09PSAnc2Nyb2xsJyB8fFxuICAgICAgICBrZXkgPT09ICdzaGFsbG93JyB8fFxuICAgICAgICBrZXkgPT09ICdwYXNzSHJlZicgfHxcbiAgICAgICAga2V5ID09PSAncHJlZmV0Y2gnXG4gICAgICApIHtcbiAgICAgICAgaWYgKHByb3BzW2tleV0gIT0gbnVsbCAmJiB2YWxUeXBlICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhwZWN0ZWQ6ICdgYm9vbGVhbmAnLFxuICAgICAgICAgICAgYWN0dWFsOiB2YWxUeXBlLFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgY29uc3QgXzogbmV2ZXIgPSBrZXlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVGhpcyBob29rIGlzIGluIGEgY29uZGl0aW9uYWwgYnV0IHRoYXQgaXMgb2sgYmVjYXVzZSBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIG5ldmVyIGNoYW5nZXNcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBjb25zdCBoYXNXYXJuZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpXG4gICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCkge1xuICAgICAgaGFzV2FybmVkLmN1cnJlbnQgPSB0cnVlXG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgY29uc3QgcCA9IHByb3BzLnByZWZldGNoICE9PSBmYWxzZVxuXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXG4gIGNvbnN0IHBhdGhuYW1lID0gKHJvdXRlciAmJiByb3V0ZXIuYXNQYXRoKSB8fCAnLydcblxuICBjb25zdCB7IGhyZWYsIGFzIH0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHBhdGhuYW1lLCBwcm9wcy5ocmVmLCB0cnVlKVxuICAgIHJldHVybiB7XG4gICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICBhczogcHJvcHMuYXNcbiAgICAgICAgPyByZXNvbHZlSHJlZihwYXRobmFtZSwgcHJvcHMuYXMpXG4gICAgICAgIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWYsXG4gICAgfVxuICB9LCBbcGF0aG5hbWUsIHByb3BzLmhyZWYsIHByb3BzLmFzXSlcblxuICBsZXQgeyBjaGlsZHJlbiwgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUgfSA9IHByb3BzXG5cbiAgLy8gRGVwcmVjYXRlZC4gV2FybmluZyBzaG93biBieSBwcm9wVHlwZSBjaGVjay4gSWYgdGhlIGNoaWxkcmVuIHByb3ZpZGVkIGlzIGEgc3RyaW5nICg8TGluaz5leGFtcGxlPC9MaW5rPikgd2Ugd3JhcCBpdCBpbiBhbiA8YT4gdGFnXG4gIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgY2hpbGRyZW4gPSA8YT57Y2hpbGRyZW59PC9hPlxuICB9XG5cbiAgLy8gVGhpcyB3aWxsIHJldHVybiB0aGUgZmlyc3QgY2hpbGQsIGlmIG11bHRpcGxlIGFyZSBwcm92aWRlZCBpdCB3aWxsIHRocm93IGFuIGVycm9yXG4gIGNvbnN0IGNoaWxkOiBhbnkgPSBDaGlsZHJlbi5vbmx5KGNoaWxkcmVuKVxuICBjb25zdCBjaGlsZFJlZjogYW55ID0gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSAnb2JqZWN0JyAmJiBjaGlsZC5yZWZcblxuICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGVdID0gdXNlSW50ZXJzZWN0aW9uKHtcbiAgICByb290TWFyZ2luOiAnMjAwcHgnLFxuICB9KVxuICBjb25zdCBzZXRSZWYgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZWw6IEVsZW1lbnQpID0+IHtcbiAgICAgIHNldEludGVyc2VjdGlvblJlZihlbClcbiAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZFJlZihlbClcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkUmVmID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGNoaWxkUmVmLmN1cnJlbnQgPSBlbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBbY2hpbGRSZWYsIHNldEludGVyc2VjdGlvblJlZl1cbiAgKVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHNob3VsZFByZWZldGNoID0gaXNWaXNpYmxlICYmIHAgJiYgaXNMb2NhbFVSTChocmVmKVxuICAgIGNvbnN0IGN1ckxvY2FsZSA9XG4gICAgICB0eXBlb2YgbG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGxvY2FsZSA6IHJvdXRlciAmJiByb3V0ZXIubG9jYWxlXG4gICAgY29uc3QgaXNQcmVmZXRjaGVkID1cbiAgICAgIHByZWZldGNoZWRbaHJlZiArICclJyArIGFzICsgKGN1ckxvY2FsZSA/ICclJyArIGN1ckxvY2FsZSA6ICcnKV1cbiAgICBpZiAoc2hvdWxkUHJlZmV0Y2ggJiYgIWlzUHJlZmV0Y2hlZCkge1xuICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICBsb2NhbGU6IGN1ckxvY2FsZSxcbiAgICAgIH0pXG4gICAgfVxuICB9LCBbYXMsIGhyZWYsIGlzVmlzaWJsZSwgbG9jYWxlLCBwLCByb3V0ZXJdKVxuXG4gIGNvbnN0IGNoaWxkUHJvcHM6IHtcbiAgICBvbk1vdXNlRW50ZXI/OiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgIG9uQ2xpY2s6IFJlYWN0Lk1vdXNlRXZlbnRIYW5kbGVyXG4gICAgaHJlZj86IHN0cmluZ1xuICAgIHJlZj86IGFueVxuICB9ID0ge1xuICAgIHJlZjogc2V0UmVmLFxuICAgIG9uQ2xpY2s6IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICBpZiAoY2hpbGQucHJvcHMgJiYgdHlwZW9mIGNoaWxkLnByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKVxuICAgICAgfVxuICAgICAgaWYgKCFlLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgbGlua0NsaWNrZWQoZSwgcm91dGVyLCBocmVmLCBhcywgcmVwbGFjZSwgc2hhbGxvdywgc2Nyb2xsLCBsb2NhbGUpXG4gICAgICB9XG4gICAgfSxcbiAgfVxuXG4gIGNoaWxkUHJvcHMub25Nb3VzZUVudGVyID0gKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwoaHJlZikpIHJldHVyblxuICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIoZSlcbiAgICB9XG4gICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgeyBwcmlvcml0eTogdHJ1ZSB9KVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgaXMgYW4gPGE+IHRhZyBhbmQgZG9lc24ndCBoYXZlIGEgaHJlZiBhdHRyaWJ1dGUsIG9yIGlmIHRoZSAncGFzc0hyZWYnIHByb3BlcnR5IGlzXG4gIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICBpZiAocHJvcHMucGFzc0hyZWYgfHwgKGNoaWxkLnR5cGUgPT09ICdhJyAmJiAhKCdocmVmJyBpbiBjaGlsZC5wcm9wcykpKSB7XG4gICAgY29uc3QgY3VyTG9jYWxlID1cbiAgICAgIHR5cGVvZiBsb2NhbGUgIT09ICd1bmRlZmluZWQnID8gbG9jYWxlIDogcm91dGVyICYmIHJvdXRlci5sb2NhbGVcblxuICAgIC8vIHdlIG9ubHkgcmVuZGVyIGRvbWFpbiBsb2NhbGVzIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gYSBkb21haW4gbG9jYWxlXG4gICAgLy8gc28gdGhhdCBsb2NhbGUgbGlua3MgYXJlIHN0aWxsIHZpc2l0YWJsZSBpbiBkZXZlbG9wbWVudC9wcmV2aWV3IGVudnNcbiAgICBjb25zdCBsb2NhbGVEb21haW4gPVxuICAgICAgcm91dGVyICYmXG4gICAgICByb3V0ZXIuaXNMb2NhbGVEb21haW4gJiZcbiAgICAgIGdldERvbWFpbkxvY2FsZShcbiAgICAgICAgYXMsXG4gICAgICAgIGN1ckxvY2FsZSxcbiAgICAgICAgcm91dGVyICYmIHJvdXRlci5sb2NhbGVzLFxuICAgICAgICByb3V0ZXIgJiYgcm91dGVyLmRvbWFpbkxvY2FsZXNcbiAgICAgIClcblxuICAgIGNoaWxkUHJvcHMuaHJlZiA9XG4gICAgICBsb2NhbGVEb21haW4gfHxcbiAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShhcywgY3VyTG9jYWxlLCByb3V0ZXIgJiYgcm91dGVyLmRlZmF1bHRMb2NhbGUpKVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZCwgY2hpbGRQcm9wcylcbn1cblxuZXhwb3J0IGRlZmF1bHQgTGlua1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/client/link.js\n");

/***/ }),

/***/ "../../node_modules/next/dist/client/use-intersection.js":
/*!********************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/dist/client/use-intersection.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nvar _slicedToArray = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/slicedToArray.js\");\n\nexports.__esModule = true;\nexports.useIntersection = useIntersection;\n\nvar _react = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n\nvar _requestIdleCallback = __webpack_require__(/*! ./request-idle-callback */ \"../../node_modules/next/dist/client/request-idle-callback.js\");\n\nvar hasIntersectionObserver = typeof IntersectionObserver !== 'undefined';\n\nfunction useIntersection(_ref) {\n  var rootMargin = _ref.rootMargin,\n      disabled = _ref.disabled;\n  var isDisabled = disabled || !hasIntersectionObserver;\n  var unobserve = (0, _react.useRef)();\n\n  var _ref2 = (0, _react.useState)(false),\n      _ref3 = _slicedToArray(_ref2, 2),\n      visible = _ref3[0],\n      setVisible = _ref3[1];\n\n  var setRef = (0, _react.useCallback)(function (el) {\n    if (unobserve.current) {\n      unobserve.current();\n      unobserve.current = undefined;\n    }\n\n    if (isDisabled || visible) return;\n\n    if (el && el.tagName) {\n      unobserve.current = observe(el, function (isVisible) {\n        return isVisible && setVisible(isVisible);\n      }, {\n        rootMargin: rootMargin\n      });\n    }\n  }, [isDisabled, rootMargin, visible]);\n  (0, _react.useEffect)(function () {\n    if (!hasIntersectionObserver) {\n      if (!visible) {\n        var idleCallback = (0, _requestIdleCallback.requestIdleCallback)(function () {\n          return setVisible(true);\n        });\n        return function () {\n          return (0, _requestIdleCallback.cancelIdleCallback)(idleCallback);\n        };\n      }\n    }\n  }, [visible]);\n  return [setRef, visible];\n}\n\nfunction observe(element, callback, options) {\n  var _createObserver = createObserver(options),\n      id = _createObserver.id,\n      observer = _createObserver.observer,\n      elements = _createObserver.elements;\n\n  elements.set(element, callback);\n  observer.observe(element);\n  return function unobserve() {\n    elements[\"delete\"](element);\n    observer.unobserve(element); // Destroy observer when there's nothing left to watch:\n\n    if (elements.size === 0) {\n      observer.disconnect();\n      observers[\"delete\"](id);\n    }\n  };\n}\n\nvar observers = new Map();\n\nfunction createObserver(options) {\n  var id = options.rootMargin || '';\n  var instance = observers.get(id);\n\n  if (instance) {\n    return instance;\n  }\n\n  var elements = new Map();\n  var observer = new IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      var callback = elements.get(entry.target);\n      var isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n\n      if (callback && isVisible) {\n        callback(isVisible);\n      }\n    });\n  }, options);\n  observers.set(id, instance = {\n    id: id,\n    observer: observer,\n    elements: elements\n  });\n  return instance;\n}\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../compiled/webpack/module.js */ \"../../node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLnRzeD85MjhiIl0sIm5hbWVzIjpbImhhc0ludGVyc2VjdGlvbk9ic2VydmVyIiwiaXNEaXNhYmxlZCIsImRpc2FibGVkIiwidW5vYnNlcnZlIiwic2V0UmVmIiwiZWwiLCJvYnNlcnZlIiwiaXNWaXNpYmxlIiwic2V0VmlzaWJsZSIsInJvb3RNYXJnaW4iLCJpZGxlQ2FsbGJhY2siLCJjcmVhdGVPYnNlcnZlciIsImVsZW1lbnRzIiwib2JzZXJ2ZXIiLCJvYnNlcnZlcnMiLCJpZCIsIm9wdGlvbnMiLCJpbnN0YW5jZSIsImVudHJpZXMiLCJlbnRyeSIsImNhbGxiYWNrIl0sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7O0FBQ0E7O0FBY0EsSUFBTUEsdUJBQXVCLEdBQUcsZ0NBQWhDOztBQUVPLCtCQUdxRDtBQUFBLE1BSFQsVUFHUyxRQUhULFVBR1M7QUFBQSxNQUhyRCxRQUdxRCxRQUhyRCxRQUdxRDtBQUMxRCxNQUFNQyxVQUFtQixHQUFHQyxRQUFRLElBQUksQ0FBeEM7QUFFQSxNQUFNQyxTQUFTLEdBQUcsV0FBbEIsTUFBa0IsR0FBbEI7O0FBSDBELGNBSTVCLHFCQUE5QixLQUE4QixDQUo0QjtBQUFBO0FBQUEsTUFJcEQsT0FKb0Q7QUFBQSxNQUlwRCxVQUpvRDs7QUFNMUQsTUFBTUMsTUFBTSxHQUFHLHdCQUNaQyxZQUFELEVBQWtCO0FBQ2hCLFFBQUlGLFNBQVMsQ0FBYixTQUF1QjtBQUNyQkEsZUFBUyxDQUFUQTtBQUNBQSxlQUFTLENBQVRBO0FBR0Y7O0FBQUEsUUFBSUYsVUFBVSxJQUFkLFNBQTJCOztBQUUzQixRQUFJSSxFQUFFLElBQUlBLEVBQUUsQ0FBWixTQUFzQjtBQUNwQkYsZUFBUyxDQUFUQSxVQUFvQkcsT0FBTyxLQUV4QkMsbUJBQUQ7QUFBQSxlQUFlQSxTQUFTLElBQUlDLFVBQVUsQ0FGYixTQUVhLENBQXRDO0FBQUEsT0FGeUIsRUFHekI7QUFBRUMsa0JBSEpOLEVBR0lNO0FBQUYsT0FIeUIsQ0FBM0JOO0FBTUg7QUFoQlksS0FpQmIseUJBakJGLE9BaUJFLENBakJhLENBQWY7QUFvQkEsd0JBQVUsWUFBTTtBQUNkLFFBQUksQ0FBSix5QkFBOEI7QUFDNUIsVUFBSSxDQUFKLFNBQWM7QUFDWixZQUFNTyxZQUFZLEdBQUcsOENBQW9CO0FBQUEsaUJBQU1GLFVBQVUsQ0FBekQsSUFBeUQsQ0FBaEI7QUFBQSxTQUFwQixDQUFyQjtBQUNBLGVBQU87QUFBQSxpQkFBTSw2Q0FBYixZQUFhLENBQU47QUFBQSxTQUFQO0FBRUg7QUFDRjtBQVBELEtBT0csQ0FQSCxPQU9HLENBUEg7QUFTQSxTQUFPLFNBQVAsT0FBTyxDQUFQO0FBR0Y7O0FBQUEsNkNBSWM7QUFBQSx3QkFDdUJHLGNBQWMsQ0FBakQsT0FBaUQsQ0FEckM7QUFBQSxNQUNOLEVBRE0sbUJBQ04sRUFETTtBQUFBLE1BQ04sUUFETSxtQkFDTixRQURNO0FBQUEsTUFDTixRQURNLG1CQUNOLFFBRE07O0FBRVpDLFVBQVEsQ0FBUkE7QUFFQUMsVUFBUSxDQUFSQTtBQUNBLFNBQU8scUJBQTJCO0FBQ2hDRDtBQUNBQyxZQUFRLENBQVJBLG1CQUZnQyxDQUloQzs7QUFDQSxRQUFJRCxRQUFRLENBQVJBLFNBQUosR0FBeUI7QUFDdkJDLGNBQVEsQ0FBUkE7QUFDQUM7QUFFSDtBQVREO0FBWUY7O0FBQUEsSUFBTUEsU0FBUyxHQUFHLElBQWxCLEdBQWtCLEVBQWxCOztBQUNBLGlDQUF3RTtBQUN0RSxNQUFNQyxFQUFFLEdBQUdDLE9BQU8sQ0FBUEEsY0FBWDtBQUNBLE1BQUlDLFFBQVEsR0FBR0gsU0FBUyxDQUFUQSxJQUFmLEVBQWVBLENBQWY7O0FBQ0EsZ0JBQWM7QUFDWjtBQUdGOztBQUFBLE1BQU1GLFFBQVEsR0FBRyxJQUFqQixHQUFpQixFQUFqQjtBQUNBLE1BQU1DLFFBQVEsR0FBRyx5QkFBMEJLLGlCQUFELEVBQWE7QUFDckRBLFdBQU8sQ0FBUEEsUUFBaUJDLGVBQUQsRUFBVztBQUN6QixVQUFNQyxRQUFRLEdBQUdSLFFBQVEsQ0FBUkEsSUFBYU8sS0FBSyxDQUFuQyxNQUFpQlAsQ0FBakI7QUFDQSxVQUFNTCxTQUFTLEdBQUdZLEtBQUssQ0FBTEEsa0JBQXdCQSxLQUFLLENBQUxBLG9CQUExQzs7QUFDQSxVQUFJQyxRQUFRLElBQVosV0FBMkI7QUFDekJBLGdCQUFRLENBQVJBLFNBQVEsQ0FBUkE7QUFFSDtBQU5ERjtBQURlLEtBQWpCLE9BQWlCLENBQWpCO0FBVUFKLFdBQVMsQ0FBVEEsUUFFR0csUUFBUSxHQUFHO0FBQ1ZGLE1BRFUsRUFDVkEsRUFEVTtBQUVWRixZQUZVLEVBRVZBLFFBRlU7QUFHVkQsWUFMSkUsRUFLSUY7QUFIVSxHQUZkRTtBQVFBO0FBQ0QiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvdXNlLWludGVyc2VjdGlvbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7XG4gIHJlcXVlc3RJZGxlQ2FsbGJhY2ssXG4gIGNhbmNlbElkbGVDYWxsYmFjayxcbn0gZnJvbSAnLi9yZXF1ZXN0LWlkbGUtY2FsbGJhY2snXG5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0gUGljazxJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQsICdyb290TWFyZ2luJz5cbnR5cGUgVXNlSW50ZXJzZWN0aW9uID0geyBkaXNhYmxlZD86IGJvb2xlYW4gfSAmIFVzZUludGVyc2VjdGlvbk9ic2VydmVySW5pdFxudHlwZSBPYnNlcnZlQ2FsbGJhY2sgPSAoaXNWaXNpYmxlOiBib29sZWFuKSA9PiB2b2lkXG50eXBlIE9ic2VydmVyID0ge1xuICBpZDogc3RyaW5nXG4gIG9ic2VydmVyOiBJbnRlcnNlY3Rpb25PYnNlcnZlclxuICBlbGVtZW50czogTWFwPEVsZW1lbnQsIE9ic2VydmVDYWxsYmFjaz5cbn1cblxuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb248VCBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgcm9vdE1hcmdpbixcbiAgZGlzYWJsZWQsXG59OiBVc2VJbnRlcnNlY3Rpb24pOiBbKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB2b2lkLCBib29sZWFuXSB7XG4gIGNvbnN0IGlzRGlzYWJsZWQ6IGJvb2xlYW4gPSBkaXNhYmxlZCB8fCAhaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcblxuICBjb25zdCB1bm9ic2VydmUgPSB1c2VSZWY8RnVuY3Rpb24+KClcbiAgY29uc3QgW3Zpc2libGUsIHNldFZpc2libGVdID0gdXNlU3RhdGUoZmFsc2UpXG5cbiAgY29uc3Qgc2V0UmVmID0gdXNlQ2FsbGJhY2soXG4gICAgKGVsOiBUIHwgbnVsbCkgPT4ge1xuICAgICAgaWYgKHVub2JzZXJ2ZS5jdXJyZW50KSB7XG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50KClcbiAgICAgICAgdW5vYnNlcnZlLmN1cnJlbnQgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzYWJsZWQgfHwgdmlzaWJsZSkgcmV0dXJuXG5cbiAgICAgIGlmIChlbCAmJiBlbC50YWdOYW1lKSB7XG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShcbiAgICAgICAgICBlbCxcbiAgICAgICAgICAoaXNWaXNpYmxlKSA9PiBpc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpLFxuICAgICAgICAgIHsgcm9vdE1hcmdpbiB9XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuICAgIFtpc0Rpc2FibGVkLCByb290TWFyZ2luLCB2aXNpYmxlXVxuICApXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWhhc0ludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgaWRsZUNhbGxiYWNrID0gcmVxdWVzdElkbGVDYWxsYmFjaygoKSA9PiBzZXRWaXNpYmxlKHRydWUpKVxuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsSWRsZUNhbGxiYWNrKGlkbGVDYWxsYmFjaylcbiAgICAgIH1cbiAgICB9XG4gIH0sIFt2aXNpYmxlXSlcblxuICByZXR1cm4gW3NldFJlZiwgdmlzaWJsZV1cbn1cblxuZnVuY3Rpb24gb2JzZXJ2ZShcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgY2FsbGJhY2s6IE9ic2VydmVDYWxsYmFjayxcbiAgb3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XG4pOiAoKSA9PiB2b2lkIHtcbiAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKVxuICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spXG5cbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KVxuICByZXR1cm4gZnVuY3Rpb24gdW5vYnNlcnZlKCk6IHZvaWQge1xuICAgIGVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KVxuICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KVxuXG4gICAgLy8gRGVzdHJveSBvYnNlcnZlciB3aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIHdhdGNoOlxuICAgIGlmIChlbGVtZW50cy5zaXplID09PSAwKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXA8c3RyaW5nLCBPYnNlcnZlcj4oKVxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9uczogVXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KTogT2JzZXJ2ZXIge1xuICBjb25zdCBpZCA9IG9wdGlvbnMucm9vdE1hcmdpbiB8fCAnJ1xuICBsZXQgaW5zdGFuY2UgPSBvYnNlcnZlcnMuZ2V0KGlkKVxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VcbiAgfVxuXG4gIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcDxFbGVtZW50LCBPYnNlcnZlQ2FsbGJhY2s+KClcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDBcbiAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgY2FsbGJhY2soaXNWaXNpYmxlKVxuICAgICAgfVxuICAgIH0pXG4gIH0sIG9wdGlvbnMpXG5cbiAgb2JzZXJ2ZXJzLnNldChcbiAgICBpZCxcbiAgICAoaW5zdGFuY2UgPSB7XG4gICAgICBpZCxcbiAgICAgIG9ic2VydmVyLFxuICAgICAgZWxlbWVudHMsXG4gICAgfSlcbiAgKVxuICByZXR1cm4gaW5zdGFuY2Vcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/next/dist/client/use-intersection.js\n");

/***/ }),

/***/ "../../node_modules/next/link.js":
/*!********************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/link.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./dist/client/link */ \"../../node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL25leHQvbGluay5qcz85NmUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLHVFQUFvQiIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/link.js\n");

/***/ }),

/***/ "../../node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \*************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _arrayWithoutHoles; });\n/* harmony import */ var _babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayLikeToArray */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return Object(_babel_runtime_helpers_esm_arrayLikeToArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzPzFlNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQTJFO0FBQzVEO0FBQ2YsaUNBQWlDLDJGQUFnQjtBQUNqRCIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheVwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\n");

/***/ }),

/***/ "../../node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!************************************************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _asyncToGenerator; });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanM/NDZmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FzeW5jVG9HZW5lcmF0b3IuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\n");

/***/ }),

/***/ "../../node_modules/next/node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _iterableToArray; });\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcz8yZWI2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBZTtBQUNmO0FBQ0EiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/next/node_modules/@babel/runtime/helpers/esm/iterableToArray.js\n");

/***/ }),

/***/ "../../node_modules/next/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \*************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _nonIterableSpread; });\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlU3ByZWFkLmpzPzIwMmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFlO0FBQ2Y7QUFDQSIsImZpbGUiOiIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/next/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\n");

/***/ }),

/***/ "../../node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \*************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return _toConsumableArray; });\n/* harmony import */ var _babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/arrayWithoutHoles */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/iterableToArray */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/iterableToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/unsupportedIterableToArray */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/nonIterableSpread */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\");\n\n\n\n\nfunction _toConsumableArray(arr) {\n  return Object(_babel_runtime_helpers_esm_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr) || Object(_babel_runtime_helpers_esm_iterableToArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arr) || Object(_babel_runtime_helpers_esm_unsupportedIterableToArray__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(arr) || Object(_babel_runtime_helpers_esm_nonIterableSpread__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL25leHQvbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzPzlkZGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTZFO0FBQ0o7QUFDc0I7QUFDbEI7QUFDOUQ7QUFDZixTQUFTLDRGQUFpQixTQUFTLDBGQUFlLFNBQVMscUdBQTBCLFNBQVMsNEZBQWlCO0FBQy9HIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcnJheVdpdGhvdXRIb2xlcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheVwiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlU3ByZWFkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZFwiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n");

/***/ }),

/***/ "../../node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js ***!
  \*******************************************************************************************************************************/
/*! exports provided: OverlayScrollbarsComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayScrollbarsComponent\", function() { return OverlayScrollbarsComponent; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! overlayscrollbars */ \"../../node_modules/overlayscrollbars/js/OverlayScrollbars.js\");\n/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(overlayscrollbars__WEBPACK_IMPORTED_MODULE_1__);\n\r\n\r\n\r\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nclass OverlayScrollbarsComponent extends react__WEBPACK_IMPORTED_MODULE_0__[\"Component\"] {\r\n    constructor(props) {\r\n        super(props);\r\n        this._osInstance = null;\r\n        this._osTargetRef = react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef();\r\n    }\r\n    osInstance() {\r\n        return this._osInstance;\r\n    }\r\n    osTarget() {\r\n        return this._osTargetRef.current || null;\r\n    }\r\n    componentDidMount() {\r\n        this._osInstance = overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default()(this.osTarget(), this.props.options || {}, this.props.extensions);\r\n        mergeHostClassNames(this._osInstance, this.props.className);\r\n    }\r\n    componentWillUnmount() {\r\n        if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default.a.valid(this._osInstance)) {\r\n            this._osInstance.destroy();\r\n            this._osInstance = null;\r\n        }\r\n    }\r\n    componentDidUpdate(prevProps) {\r\n        if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default.a.valid(this._osInstance)) {\r\n            this._osInstance.options(this.props.options);\r\n            if (prevProps.className !== this.props.className) {\r\n                mergeHostClassNames(this._osInstance, this.props.className);\r\n            }\r\n        }\r\n    }\r\n    render() {\r\n        const _a = this.props, divProps = __rest(_a, [\"options\", \"extensions\", \"children\", \"className\"]);\r\n        return (react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", Object.assign({ className: \"os-host\" }, divProps, { ref: this._osTargetRef }),\r\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-resize-observer-host\" }),\r\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-padding\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-viewport\" },\r\n                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-content\" }, this.props.children))),\r\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-scrollbar os-scrollbar-horizontal \" },\r\n                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-scrollbar-track\" },\r\n                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-scrollbar-handle\" }))),\r\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-scrollbar os-scrollbar-vertical\" },\r\n                react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-scrollbar-track\" },\r\n                    react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-scrollbar-handle\" }))),\r\n            react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", { className: \"os-scrollbar-corner\" })));\r\n    }\r\n}\r\nfunction mergeHostClassNames(osInstance, className) {\r\n    if (overlayscrollbars__WEBPACK_IMPORTED_MODULE_1___default.a.valid(osInstance)) {\r\n        const { host } = osInstance.getElements();\r\n        const regex = new RegExp(`(^os-host([-_].+|)$)|${osInstance.options().className.replace(/\\s/g, \"$|\")}$`, 'g');\r\n        const osClassNames = host.className.split(' ')\r\n            .filter(name => name.match(regex))\r\n            .join(' ');\r\n        host.className = `${osClassNames} ${className || ''}`;\r\n    }\r\n}\r\n\r\n\r\n//# sourceMappingURL=overlayscrollbars-react.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL292ZXJsYXlzY3JvbGxiYXJzLXJlYWN0L2Rpc3Qvb3ZlcmxheXNjcm9sbGJhcnMtcmVhY3QuZXNtLmpzPzkwYWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXlDO0FBQ1M7O0FBRWxEO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxjQUFjO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLCtDQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0Q0FBSztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFpQiwwQ0FBMEM7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNENBQUsscUNBQXFDLHVCQUF1QixhQUFhLHlCQUF5QjtBQUN2SCxZQUFZLDRDQUFLLHVCQUF1Qix1Q0FBdUM7QUFDL0UsWUFBWSw0Q0FBSyx1QkFBdUIsMEJBQTBCO0FBQ2xFLGdCQUFnQiw0Q0FBSyx1QkFBdUIsMkJBQTJCO0FBQ3ZFLG9CQUFvQiw0Q0FBSyx1QkFBdUIsMEJBQTBCO0FBQzFFLFlBQVksNENBQUssdUJBQXVCLHFEQUFxRDtBQUM3RixnQkFBZ0IsNENBQUssdUJBQXVCLGtDQUFrQztBQUM5RSxvQkFBb0IsNENBQUssdUJBQXVCLG1DQUFtQztBQUNuRixZQUFZLDRDQUFLLHVCQUF1QixrREFBa0Q7QUFDMUYsZ0JBQWdCLDRDQUFLLHVCQUF1QixrQ0FBa0M7QUFDOUUsb0JBQW9CLDRDQUFLLHVCQUF1QixtQ0FBbUM7QUFDbkYsWUFBWSw0Q0FBSyx1QkFBdUIsbUNBQW1DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0RBQWlCO0FBQ3pCLGVBQWUsT0FBTztBQUN0Qix5REFBeUQsb0RBQW9EO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhLEdBQUcsZ0JBQWdCO0FBQzVEO0FBQ0E7O0FBRXNDO0FBQ3RDIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9vdmVybGF5c2Nyb2xsYmFycy1yZWFjdC9kaXN0L292ZXJsYXlzY3JvbGxiYXJzLXJlYWN0LmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XHJcbmltcG9ydCBPdmVybGF5U2Nyb2xsYmFycyBmcm9tICdvdmVybGF5c2Nyb2xsYmFycyc7XHJcblxyXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5jbGFzcyBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xyXG4gICAgICAgIHN1cGVyKHByb3BzKTtcclxuICAgICAgICB0aGlzLl9vc0luc3RhbmNlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9vc1RhcmdldFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xyXG4gICAgfVxyXG4gICAgb3NJbnN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3NJbnN0YW5jZTtcclxuICAgIH1cclxuICAgIG9zVGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vc1RhcmdldFJlZi5jdXJyZW50IHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcclxuICAgICAgICB0aGlzLl9vc0luc3RhbmNlID0gT3ZlcmxheVNjcm9sbGJhcnModGhpcy5vc1RhcmdldCgpLCB0aGlzLnByb3BzLm9wdGlvbnMgfHwge30sIHRoaXMucHJvcHMuZXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgbWVyZ2VIb3N0Q2xhc3NOYW1lcyh0aGlzLl9vc0luc3RhbmNlLCB0aGlzLnByb3BzLmNsYXNzTmFtZSk7XHJcbiAgICB9XHJcbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcclxuICAgICAgICBpZiAoT3ZlcmxheVNjcm9sbGJhcnMudmFsaWQodGhpcy5fb3NJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3NJbnN0YW5jZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX29zSW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcclxuICAgICAgICBpZiAoT3ZlcmxheVNjcm9sbGJhcnMudmFsaWQodGhpcy5fb3NJbnN0YW5jZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fb3NJbnN0YW5jZS5vcHRpb25zKHRoaXMucHJvcHMub3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChwcmV2UHJvcHMuY2xhc3NOYW1lICE9PSB0aGlzLnByb3BzLmNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgbWVyZ2VIb3N0Q2xhc3NOYW1lcyh0aGlzLl9vc0luc3RhbmNlLCB0aGlzLnByb3BzLmNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgX2EgPSB0aGlzLnByb3BzLCBkaXZQcm9wcyA9IF9fcmVzdChfYSwgW1wib3B0aW9uc1wiLCBcImV4dGVuc2lvbnNcIiwgXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiXSk7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oeyBjbGFzc05hbWU6IFwib3MtaG9zdFwiIH0sIGRpdlByb3BzLCB7IHJlZjogdGhpcy5fb3NUYXJnZXRSZWYgfSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3MtcmVzaXplLW9ic2VydmVyLWhvc3RcIiB9KSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJvcy1wYWRkaW5nXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3Mtdmlld3BvcnRcIiB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3MtY29udGVudFwiIH0sIHRoaXMucHJvcHMuY2hpbGRyZW4pKSksXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci1ob3Jpem9udGFsIFwiIH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLXNjcm9sbGJhci10cmFja1wiIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXItaGFuZGxlXCIgfSkpKSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJvcy1zY3JvbGxiYXIgb3Mtc2Nyb2xsYmFyLXZlcnRpY2FsXCIgfSxcclxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwib3Mtc2Nyb2xsYmFyLXRyYWNrXCIgfSxcclxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLXNjcm9sbGJhci1oYW5kbGVcIiB9KSkpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIm9zLXNjcm9sbGJhci1jb3JuZXJcIiB9KSkpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIG1lcmdlSG9zdENsYXNzTmFtZXMob3NJbnN0YW5jZSwgY2xhc3NOYW1lKSB7XHJcbiAgICBpZiAoT3ZlcmxheVNjcm9sbGJhcnMudmFsaWQob3NJbnN0YW5jZSkpIHtcclxuICAgICAgICBjb25zdCB7IGhvc3QgfSA9IG9zSW5zdGFuY2UuZ2V0RWxlbWVudHMoKTtcclxuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYCheb3MtaG9zdChbLV9dLit8KSQpfCR7b3NJbnN0YW5jZS5vcHRpb25zKCkuY2xhc3NOYW1lLnJlcGxhY2UoL1xccy9nLCBcIiR8XCIpfSRgLCAnZycpO1xyXG4gICAgICAgIGNvbnN0IG9zQ2xhc3NOYW1lcyA9IGhvc3QuY2xhc3NOYW1lLnNwbGl0KCcgJylcclxuICAgICAgICAgICAgLmZpbHRlcihuYW1lID0+IG5hbWUubWF0Y2gocmVnZXgpKVxyXG4gICAgICAgICAgICAuam9pbignICcpO1xyXG4gICAgICAgIGhvc3QuY2xhc3NOYW1lID0gYCR7b3NDbGFzc05hbWVzfSAke2NsYXNzTmFtZSB8fCAnJ31gO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgeyBPdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudCB9O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vdmVybGF5c2Nyb2xsYmFycy1yZWFjdC5lc20uanMubWFwXHJcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js\n");

/***/ }),

/***/ "../../node_modules/overlayscrollbars/js/OverlayScrollbars.js":
/*!*************************************************************************************************************!*\
  !*** /Users/alejandrosandoval/space/world_eserp/web/node_modules/overlayscrollbars/js/OverlayScrollbars.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * OverlayScrollbars\r\n * https://github.com/KingSora/OverlayScrollbars\r\n *\r\n * Version: 1.13.0\r\n *\r\n * Copyright KingSora | Rene Haas.\r\n * https://github.com/KingSora\r\n *\r\n * Released under the MIT license.\r\n * Date: 02.08.2020\r\n */\r\n\r\n(function (global, factory) {\r\n    if (true)\r\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return factory(global, global.document, undefined); }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    else {}\r\n}(typeof window !== 'undefined' ? window : this,\r\n    function (window, document, undefined) {\r\n        'use strict';\r\n        var PLUGINNAME = 'OverlayScrollbars';\r\n        var TYPES = {\r\n            o: 'object',\r\n            f: 'function',\r\n            a: 'array',\r\n            s: 'string',\r\n            b: 'boolean',\r\n            n: 'number',\r\n            u: 'undefined',\r\n            z: 'null'\r\n            //d : 'date',\r\n            //e : 'error',\r\n            //r : 'regexp',\r\n            //y : 'symbol'\r\n        };\r\n        var LEXICON = {\r\n            c: 'class',\r\n            s: 'style',\r\n            i: 'id',\r\n            l: 'length',\r\n            p: 'prototype',\r\n            ti: 'tabindex',\r\n            oH: 'offsetHeight',\r\n            cH: 'clientHeight',\r\n            sH: 'scrollHeight',\r\n            oW: 'offsetWidth',\r\n            cW: 'clientWidth',\r\n            sW: 'scrollWidth',\r\n            hOP: 'hasOwnProperty',\r\n            bCR: 'getBoundingClientRect'\r\n        };\r\n        var VENDORS = (function () {\r\n            //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix\r\n            var jsCache = {};\r\n            var cssCache = {};\r\n            var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];\r\n            var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];\r\n            function firstLetterToUpper(str) {\r\n                return str.charAt(0).toUpperCase() + str.slice(1);\r\n            }\r\n\r\n            return {\r\n                _cssPrefixes: cssPrefixes,\r\n                _jsPrefixes: jsPrefixes,\r\n                _cssProperty: function (name) {\r\n                    var result = cssCache[name];\r\n\r\n                    if (cssCache[LEXICON.hOP](name))\r\n                        return result;\r\n\r\n                    var uppercasedName = firstLetterToUpper(name);\r\n                    var elmStyle = document.createElement('div')[LEXICON.s];\r\n                    var resultPossibilities;\r\n                    var i = 0;\r\n                    var v;\r\n                    var currVendorWithoutDashes;\r\n\r\n                    for (; i < cssPrefixes.length; i++) {\r\n                        currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');\r\n                        resultPossibilities = [\r\n                            name, //transition\r\n                            cssPrefixes[i] + name, //-webkit-transition\r\n                            currVendorWithoutDashes + uppercasedName, //webkitTransition\r\n                            firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition\r\n                        ];\r\n                        for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {\r\n                            if (elmStyle[resultPossibilities[v]] !== undefined) {\r\n                                result = resultPossibilities[v];\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    cssCache[name] = result;\r\n                    return result;\r\n                },\r\n                _cssPropertyValue: function (property, values, suffix) {\r\n                    var name = property + ' ' + values;\r\n                    var result = cssCache[name];\r\n\r\n                    if (cssCache[LEXICON.hOP](name))\r\n                        return result;\r\n\r\n                    var dummyStyle = document.createElement('div')[LEXICON.s];\r\n                    var possbleValues = values.split(' ');\r\n                    var preparedSuffix = suffix || '';\r\n                    var i = 0;\r\n                    var v = -1;\r\n                    var prop;\r\n\r\n                    for (; i < possbleValues[LEXICON.l]; i++) {\r\n                        for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {\r\n                            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];\r\n                            dummyStyle.cssText = property + ':' + prop + preparedSuffix;\r\n                            if (dummyStyle[LEXICON.l]) {\r\n                                result = prop;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    cssCache[name] = result;\r\n                    return result;\r\n                },\r\n                _jsAPI: function (name, isInterface, fallback) {\r\n                    var i = 0;\r\n                    var result = jsCache[name];\r\n\r\n                    if (!jsCache[LEXICON.hOP](name)) {\r\n                        result = window[name];\r\n                        for (; i < jsPrefixes[LEXICON.l]; i++)\r\n                            result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];\r\n                        jsCache[name] = result;\r\n                    }\r\n                    return result || fallback;\r\n                }\r\n            }\r\n        })();\r\n        var COMPATIBILITY = (function () {\r\n            function windowSize(x) {\r\n                return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];\r\n            }\r\n            function bind(func, thisObj) {\r\n                if (typeof func != TYPES.f) {\r\n                    throw \"Can't bind function!\";\r\n                    // closest thing possible to the ECMAScript 5\r\n                    // internal IsCallable function\r\n                    //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\r\n                }\r\n                var proto = LEXICON.p;\r\n                var aArgs = Array[proto].slice.call(arguments, 2);\r\n                var fNOP = function () { };\r\n                var fBound = function () { return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments))); };\r\n\r\n                if (func[proto])\r\n                    fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property\r\n                fBound[proto] = new fNOP();\r\n\r\n                return fBound;\r\n            }\r\n\r\n            return {\r\n                /**\r\n                 * Gets the current window width.\r\n                 * @returns {Number|number} The current window width in pixel.\r\n                 */\r\n                wW: bind(windowSize, 0, true),\r\n\r\n                /**\r\n                 * Gets the current window height.\r\n                 * @returns {Number|number} The current window height in pixel.\r\n                 */\r\n                wH: bind(windowSize, 0),\r\n\r\n                /**\r\n                 * Gets the MutationObserver Object or undefined if not supported.\r\n                 * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.\r\n                 */\r\n                mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),\r\n\r\n                /**\r\n                 * Gets the ResizeObserver Object or undefined if not supported.\r\n                 * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.\r\n                 */\r\n                rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),\r\n\r\n                /**\r\n                 * Gets the RequestAnimationFrame method or it's corresponding polyfill.\r\n                 * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.\r\n                 */\r\n                rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) { return window.setTimeout(func, 1000 / 60); }),\r\n\r\n                /**\r\n                 * Gets the CancelAnimationFrame method or it's corresponding polyfill.\r\n                 * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.\r\n                 */\r\n                cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) { return window.clearTimeout(id); }),\r\n\r\n                /**\r\n                 * Gets the current time.\r\n                 * @returns {number} The current time.\r\n                 */\r\n                now: function () {\r\n                    return Date.now && Date.now() || new Date().getTime();\r\n                },\r\n\r\n                /**\r\n                 * Stops the propagation of the given event.\r\n                 * @param event The event of which the propagation shall be stoped.\r\n                 */\r\n                stpP: function (event) {\r\n                    if (event.stopPropagation)\r\n                        event.stopPropagation();\r\n                    else\r\n                        event.cancelBubble = true;\r\n                },\r\n\r\n                /**\r\n                 * Prevents the default action of the given event.\r\n                 * @param event The event of which the default action shall be prevented.\r\n                 */\r\n                prvD: function (event) {\r\n                    if (event.preventDefault && event.cancelable)\r\n                        event.preventDefault();\r\n                    else\r\n                        event.returnValue = false;\r\n                },\r\n\r\n                /**\r\n                 * Gets the pageX and pageY values of the given mouse event.\r\n                 * @param event The mouse event of which the pageX and pageX shall be got.\r\n                 * @returns {{x: number, y: number}} x = pageX value, y = pageY value.\r\n                 */\r\n                page: function (event) {\r\n                    event = event.originalEvent || event;\r\n\r\n                    var strPage = 'page';\r\n                    var strClient = 'client';\r\n                    var strX = 'X';\r\n                    var strY = 'Y';\r\n                    var target = event.target || event.srcElement || document;\r\n                    var eventDoc = target.ownerDocument || document;\r\n                    var doc = eventDoc.documentElement;\r\n                    var body = eventDoc.body;\r\n\r\n                    //if touch event return return pageX/Y of it\r\n                    if (event.touches !== undefined) {\r\n                        var touch = event.touches[0];\r\n                        return {\r\n                            x: touch[strPage + strX],\r\n                            y: touch[strPage + strY]\r\n                        }\r\n                    }\r\n\r\n                    // Calculate pageX/Y if not native supported\r\n                    if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {\r\n\r\n                        return {\r\n                            x: event[strClient + strX] +\r\n                                (doc && doc.scrollLeft || body && body.scrollLeft || 0) -\r\n                                (doc && doc.clientLeft || body && body.clientLeft || 0),\r\n                            y: event[strClient + strY] +\r\n                                (doc && doc.scrollTop || body && body.scrollTop || 0) -\r\n                                (doc && doc.clientTop || body && body.clientTop || 0)\r\n                        }\r\n                    }\r\n                    return {\r\n                        x: event[strPage + strX],\r\n                        y: event[strPage + strY]\r\n                    };\r\n                },\r\n\r\n                /**\r\n                 * Gets the clicked mouse button of the given mouse event.\r\n                 * @param event The mouse event of which the clicked button shal be got.\r\n                 * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)\r\n                 */\r\n                mBtn: function (event) {\r\n                    var button = event.button;\r\n                    if (!event.which && button !== undefined)\r\n                        return (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));\r\n                    else\r\n                        return event.which;\r\n                },\r\n\r\n                /**\r\n                 * Checks whether a item is in the given array and returns its index.\r\n                 * @param item The item of which the position in the array shall be determined.\r\n                 * @param arr The array.\r\n                 * @returns {number} The zero based index of the item or -1 if the item isn't in the array.\r\n                 */\r\n                inA: function (item, arr) {\r\n                    for (var i = 0; i < arr[LEXICON.l]; i++)\r\n                        //Sometiems in IE a \"SCRIPT70\" Permission denied error occurs if HTML elements in a iFrame are compared\r\n                        try {\r\n                            if (arr[i] === item)\r\n                                return i;\r\n                        }\r\n                        catch (e) { }\r\n                    return -1;\r\n                },\r\n\r\n                /**\r\n                 * Returns true if the given value is a array.\r\n                 * @param arr The potential array.\r\n                 * @returns {boolean} True if the given value is a array, false otherwise.\r\n                 */\r\n                isA: function (arr) {\r\n                    var def = Array.isArray;\r\n                    return def ? def(arr) : this.type(arr) == TYPES.a;\r\n                },\r\n\r\n                /**\r\n                 * Determine the internal JavaScript [[Class]] of the given object.\r\n                 * @param obj The object of which the type shall be determined.\r\n                 * @returns {string} The type of the given object.\r\n                 */\r\n                type: function (obj) {\r\n                    if (obj === undefined)\r\n                        return obj + '';\r\n                    if (obj === null)\r\n                        return obj + '';\r\n                    return Object[LEXICON.p].toString.call(obj).replace(/^\\[object (.+)\\]$/, '$1').toLowerCase();\r\n                },\r\n\r\n\r\n                bind: bind\r\n\r\n                /**\r\n                 * Gets the vendor-prefixed CSS property by the given name.\r\n                 * For example the given name is \"transform\" and you're using a old Firefox browser then the returned value would be \"-moz-transform\".\r\n                 * If the browser doesn't need a vendor-prefix, then the returned string is the given name.\r\n                 * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.\r\n                 * @param propName The unprefixed CSS property name.\r\n                 * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.\r\n\r\n                cssProp: function(propName) {\r\n                    return VENDORS._cssProperty(propName);\r\n                }\r\n                */\r\n            }\r\n        })();\r\n\r\n\r\n        var MATH = Math;\r\n        var JQUERY = window.jQuery;\r\n        var EASING = (function () {\r\n            var _easingsMath = {\r\n                p: MATH.PI,\r\n                c: MATH.cos,\r\n                s: MATH.sin,\r\n                w: MATH.pow,\r\n                t: MATH.sqrt,\r\n                n: MATH.asin,\r\n                a: MATH.abs,\r\n                o: 1.70158\r\n            };\r\n\r\n            /*\r\n             x : current percent (0 - 1),\r\n             t : current time (duration * percent),\r\n             b : start value (from),\r\n             c : end value (to),\r\n             d : duration\r\n\r\n             easingName : function(x, t, b, c, d) { return easedValue; }\r\n             */\r\n\r\n            return {\r\n                swing: function (x, t, b, c, d) {\r\n                    return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;\r\n                },\r\n                linear: function (x, t, b, c, d) {\r\n                    return x;\r\n                },\r\n                easeInQuad: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t + b;\r\n                },\r\n                easeOutQuad: function (x, t, b, c, d) {\r\n                    return -c * (t /= d) * (t - 2) + b;\r\n                },\r\n                easeInOutQuad: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t + b : -c / 2 * ((--t) * (t - 2) - 1) + b;\r\n                },\r\n                easeInCubic: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t * t + b;\r\n                },\r\n                easeOutCubic: function (x, t, b, c, d) {\r\n                    return c * ((t = t / d - 1) * t * t + 1) + b;\r\n                },\r\n                easeInOutCubic: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;\r\n                },\r\n                easeInQuart: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t * t * t + b;\r\n                },\r\n                easeOutQuart: function (x, t, b, c, d) {\r\n                    return -c * ((t = t / d - 1) * t * t * t - 1) + b;\r\n                },\r\n                easeInOutQuart: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;\r\n                },\r\n                easeInQuint: function (x, t, b, c, d) {\r\n                    return c * (t /= d) * t * t * t * t + b;\r\n                },\r\n                easeOutQuint: function (x, t, b, c, d) {\r\n                    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;\r\n                },\r\n                easeInOutQuint: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;\r\n                },\r\n                easeInSine: function (x, t, b, c, d) {\r\n                    return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;\r\n                },\r\n                easeOutSine: function (x, t, b, c, d) {\r\n                    return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;\r\n                },\r\n                easeInOutSine: function (x, t, b, c, d) {\r\n                    return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;\r\n                },\r\n                easeInExpo: function (x, t, b, c, d) {\r\n                    return (t == 0) ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;\r\n                },\r\n                easeOutExpo: function (x, t, b, c, d) {\r\n                    return (t == d) ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;\r\n                },\r\n                easeInOutExpo: function (x, t, b, c, d) {\r\n                    if (t == 0) return b;\r\n                    if (t == d) return b + c;\r\n                    if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;\r\n                    return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;\r\n                },\r\n                easeInCirc: function (x, t, b, c, d) {\r\n                    return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;\r\n                },\r\n                easeOutCirc: function (x, t, b, c, d) {\r\n                    return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;\r\n                },\r\n                easeInOutCirc: function (x, t, b, c, d) {\r\n                    return ((t /= d / 2) < 1) ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;\r\n                },\r\n                easeInElastic: function (x, t, b, c, d) {\r\n                    var s = _easingsMath.o; var p = 0; var a = c;\r\n                    if (t == 0) return b; if ((t /= d) == 1) return b + c; if (!p) p = d * .3;\r\n                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }\r\n                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\r\n                    return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;\r\n                },\r\n                easeOutElastic: function (x, t, b, c, d) {\r\n                    var s = _easingsMath.o; var p = 0; var a = c;\r\n                    if (t == 0) return b;\r\n                    if ((t /= d) == 1) return b + c;\r\n                    if (!p) p = d * .3;\r\n                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }\r\n                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\r\n                    return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;\r\n                },\r\n                easeInOutElastic: function (x, t, b, c, d) {\r\n                    var s = _easingsMath.o; var p = 0; var a = c;\r\n                    if (t == 0) return b;\r\n                    if ((t /= d / 2) == 2) return b + c;\r\n                    if (!p) p = d * (.3 * 1.5);\r\n                    if (a < _easingsMath.a(c)) { a = c; s = p / 4; }\r\n                    else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);\r\n                    if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;\r\n                    return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;\r\n                },\r\n                easeInBack: function (x, t, b, c, d, s) {\r\n                    s = s || _easingsMath.o;\r\n                    return c * (t /= d) * t * ((s + 1) * t - s) + b;\r\n                },\r\n                easeOutBack: function (x, t, b, c, d, s) {\r\n                    s = s || _easingsMath.o;\r\n                    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;\r\n                },\r\n                easeInOutBack: function (x, t, b, c, d, s) {\r\n                    s = s || _easingsMath.o;\r\n                    return ((t /= d / 2) < 1) ? c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;\r\n                },\r\n                easeInBounce: function (x, t, b, c, d) {\r\n                    return c - this.easeOutBounce(x, d - t, 0, c, d) + b;\r\n                },\r\n                easeOutBounce: function (x, t, b, c, d) {\r\n                    var o = 7.5625;\r\n                    if ((t /= d) < (1 / 2.75)) {\r\n                        return c * (o * t * t) + b;\r\n                    } else if (t < (2 / 2.75)) {\r\n                        return c * (o * (t -= (1.5 / 2.75)) * t + .75) + b;\r\n                    } else if (t < (2.5 / 2.75)) {\r\n                        return c * (o * (t -= (2.25 / 2.75)) * t + .9375) + b;\r\n                    } else {\r\n                        return c * (o * (t -= (2.625 / 2.75)) * t + .984375) + b;\r\n                    }\r\n                },\r\n                easeInOutBounce: function (x, t, b, c, d) {\r\n                    return (t < d / 2) ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;\r\n                }\r\n            };\r\n            /*\r\n             *\r\n             * TERMS OF USE - EASING EQUATIONS\r\n             * \r\n             * Open source under the BSD License. \r\n             * \r\n             * Copyright  2001 Robert Penner\r\n             * All rights reserved.\r\n             * \r\n             * Redistribution and use in source and binary forms, with or without modification, \r\n             * are permitted provided that the following conditions are met:\r\n             * \r\n             * Redistributions of source code must retain the above copyright notice, this list of \r\n             * conditions and the following disclaimer.\r\n             * Redistributions in binary form must reproduce the above copyright notice, this list \r\n             * of conditions and the following disclaimer in the documentation and/or other materials \r\n             * provided with the distribution.\r\n             * \r\n             * Neither the name of the author nor the names of contributors may be used to endorse \r\n             * or promote products derived from this software without specific prior written permission.\r\n             * \r\n             * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY \r\n             * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\r\n             * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\r\n             *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\r\n             *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE\r\n             *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED \r\n             * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n             *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED \r\n             * OF THE POSSIBILITY OF SUCH DAMAGE. \r\n             *\r\n             */\r\n        })();\r\n        var FRAMEWORK = (function () {\r\n            var _rnothtmlwhite = (/[^\\x20\\t\\r\\n\\f]+/g);\r\n            var _strSpace = ' ';\r\n            var _strEmpty = '';\r\n            var _strScrollLeft = 'scrollLeft';\r\n            var _strScrollTop = 'scrollTop';\r\n            var _animations = [];\r\n            var _type = COMPATIBILITY.type;\r\n            var _cssNumber = {\r\n                animationIterationCount: true,\r\n                columnCount: true,\r\n                fillOpacity: true,\r\n                flexGrow: true,\r\n                flexShrink: true,\r\n                fontWeight: true,\r\n                lineHeight: true,\r\n                opacity: true,\r\n                order: true,\r\n                orphans: true,\r\n                widows: true,\r\n                zIndex: true,\r\n                zoom: true\r\n            };\r\n\r\n            function extend() {\r\n                var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {},\r\n                    i = 1,\r\n                    length = arguments[LEXICON.l],\r\n                    deep = false;\r\n\r\n                // Handle a deep copy situation\r\n                if (_type(target) == TYPES.b) {\r\n                    deep = target;\r\n                    target = arguments[1] || {};\r\n                    // skip the boolean and the target\r\n                    i = 2;\r\n                }\r\n\r\n                // Handle case when target is a string or something (possible in deep copy)\r\n                if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {\r\n                    target = {};\r\n                }\r\n\r\n                // extend jQuery itself if only one argument is passed\r\n                if (length === i) {\r\n                    target = FakejQuery;\r\n                    --i;\r\n                }\r\n\r\n                for (; i < length; i++) {\r\n                    // Only deal with non-null/undefined values\r\n                    if ((options = arguments[i]) != null) {\r\n                        // Extend the base object\r\n                        for (name in options) {\r\n                            src = target[name];\r\n                            copy = options[name];\r\n\r\n                            // Prevent never-ending loop\r\n                            if (target === copy) {\r\n                                continue;\r\n                            }\r\n\r\n                            // Recurse if we're merging plain objects or arrays\r\n                            if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {\r\n                                if (copyIsArray) {\r\n                                    copyIsArray = false;\r\n                                    clone = src && COMPATIBILITY.isA(src) ? src : [];\r\n\r\n                                } else {\r\n                                    clone = src && isPlainObject(src) ? src : {};\r\n                                }\r\n\r\n                                // Never move original objects, clone them\r\n                                target[name] = extend(deep, clone, copy);\r\n\r\n                                // Don't bring in undefined values\r\n                            } else if (copy !== undefined) {\r\n                                target[name] = copy;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Return the modified object\r\n                return target;\r\n            };\r\n\r\n            function inArray(item, arr, fromIndex) {\r\n                for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++)\r\n                    if (arr[i] === item)\r\n                        return i;\r\n                return -1;\r\n            }\r\n\r\n            function isFunction(obj) {\r\n                return _type(obj) == TYPES.f;\r\n            };\r\n\r\n            function isEmptyObject(obj) {\r\n                for (var name in obj)\r\n                    return false;\r\n                return true;\r\n            };\r\n\r\n            function isPlainObject(obj) {\r\n                if (!obj || _type(obj) != TYPES.o)\r\n                    return false;\r\n\r\n                var key;\r\n                var proto = LEXICON.p;\r\n                var hasOwnProperty = Object[proto].hasOwnProperty;\r\n                var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');\r\n                var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');\r\n\r\n                if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\r\n                    return false;\r\n                }\r\n\r\n\r\n                for (key in obj) { /**/ }\r\n\r\n                return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);\r\n            };\r\n\r\n            function each(obj, callback) {\r\n                var i = 0;\r\n\r\n                if (isArrayLike(obj)) {\r\n                    for (; i < obj[LEXICON.l]; i++) {\r\n                        if (callback.call(obj[i], i, obj[i]) === false)\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    for (i in obj) {\r\n                        if (callback.call(obj[i], i, obj[i]) === false)\r\n                            break;\r\n                    }\r\n                }\r\n\r\n                return obj;\r\n            };\r\n\r\n            function isArrayLike(obj) {\r\n                var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];\r\n                var t = _type(obj);\r\n                return isFunction(t) ? false : (t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && (length - 1) in obj);\r\n            }\r\n\r\n            function stripAndCollapse(value) {\r\n                var tokens = value.match(_rnothtmlwhite) || [];\r\n                return tokens.join(_strSpace);\r\n            }\r\n\r\n            function matches(elem, selector) {\r\n                var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];\r\n                var i = nodeList[LEXICON.l];\r\n\r\n                while (i--)\r\n                    if (nodeList[i] == elem)\r\n                        return true;\r\n\r\n                return false;\r\n            }\r\n\r\n            function insertAdjacentElement(el, strategy, child) {\r\n                if (COMPATIBILITY.isA(child)) {\r\n                    for (var i = 0; i < child[LEXICON.l]; i++)\r\n                        insertAdjacentElement(el, strategy, child[i]);\r\n                }\r\n                else if (_type(child) == TYPES.s)\r\n                    el.insertAdjacentHTML(strategy, child);\r\n                else\r\n                    el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);\r\n            }\r\n\r\n            function setCSSVal(el, prop, val) {\r\n                try {\r\n                    if (el[LEXICON.s][prop] !== undefined)\r\n                        el[LEXICON.s][prop] = parseCSSVal(prop, val);\r\n                } catch (e) { }\r\n            }\r\n\r\n            function parseCSSVal(prop, val) {\r\n                if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n)\r\n                    val += 'px';\r\n                return val;\r\n            }\r\n\r\n            function startNextAnimationInQ(animObj, removeFromQ) {\r\n                var index;\r\n                var nextAnim;\r\n                if (removeFromQ !== false)\r\n                    animObj.q.splice(0, 1);\r\n                if (animObj.q[LEXICON.l] > 0) {\r\n                    nextAnim = animObj.q[0];\r\n                    animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);\r\n                }\r\n                else {\r\n                    index = inArray(animObj, _animations);\r\n                    if (index > -1)\r\n                        _animations.splice(index, 1);\r\n                }\r\n            }\r\n\r\n            function setAnimationValue(el, prop, value) {\r\n                if (prop === _strScrollLeft || prop === _strScrollTop)\r\n                    el[prop] = value;\r\n                else\r\n                    setCSSVal(el, prop, value);\r\n            }\r\n\r\n            function animate(el, props, options, easing, complete, guaranteedNext) {\r\n                var hasOptions = isPlainObject(options);\r\n                var from = {};\r\n                var to = {};\r\n                var i = 0;\r\n                var key;\r\n                var animObj;\r\n                var start;\r\n                var progress;\r\n                var step;\r\n                var specialEasing;\r\n                var duration;\r\n                if (hasOptions) {\r\n                    easing = options.easing;\r\n                    start = options.start;\r\n                    progress = options.progress;\r\n                    step = options.step;\r\n                    specialEasing = options.specialEasing;\r\n                    complete = options.complete;\r\n                    duration = options.duration;\r\n                }\r\n                else\r\n                    duration = options;\r\n                specialEasing = specialEasing || {};\r\n                duration = duration || 400;\r\n                easing = easing || 'swing';\r\n                guaranteedNext = guaranteedNext || false;\r\n\r\n                for (; i < _animations[LEXICON.l]; i++) {\r\n                    if (_animations[i].el === el) {\r\n                        animObj = _animations[i];\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!animObj) {\r\n                    animObj = {\r\n                        el: el,\r\n                        q: []\r\n                    };\r\n                    _animations.push(animObj);\r\n                }\r\n\r\n                for (key in props) {\r\n                    if (key === _strScrollLeft || key === _strScrollTop)\r\n                        from[key] = el[key];\r\n                    else\r\n                        from[key] = FakejQuery(el).css(key);\r\n                }\r\n\r\n                for (key in from) {\r\n                    if (from[key] !== props[key] && props[key] !== undefined)\r\n                        to[key] = props[key];\r\n                }\r\n\r\n                if (!isEmptyObject(to)) {\r\n                    var timeNow;\r\n                    var end;\r\n                    var percent;\r\n                    var fromVal;\r\n                    var toVal;\r\n                    var easedVal;\r\n                    var timeStart;\r\n                    var frame;\r\n                    var elapsed;\r\n                    var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);\r\n                    var qObj = {\r\n                        props: to,\r\n                        duration: hasOptions ? options : duration,\r\n                        easing: easing,\r\n                        complete: complete\r\n                    };\r\n                    if (qPos === -1) {\r\n                        qPos = animObj.q[LEXICON.l];\r\n                        animObj.q.push(qObj);\r\n                    }\r\n\r\n                    if (qPos === 0) {\r\n                        if (duration > 0) {\r\n                            timeStart = COMPATIBILITY.now();\r\n                            frame = function () {\r\n                                timeNow = COMPATIBILITY.now();\r\n                                elapsed = (timeNow - timeStart);\r\n                                end = qObj.stop || elapsed >= duration;\r\n                                percent = 1 - ((MATH.max(0, timeStart + duration - timeNow) / duration) || 0);\r\n\r\n                                for (key in to) {\r\n                                    fromVal = parseFloat(from[key]);\r\n                                    toVal = parseFloat(to[key]);\r\n                                    easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;\r\n                                    setAnimationValue(el, key, easedVal);\r\n                                    if (isFunction(step)) {\r\n                                        step(easedVal, {\r\n                                            elem: el,\r\n                                            prop: key,\r\n                                            start: fromVal,\r\n                                            now: easedVal,\r\n                                            end: toVal,\r\n                                            pos: percent,\r\n                                            options: {\r\n                                                easing: easing,\r\n                                                speacialEasing: specialEasing,\r\n                                                duration: duration,\r\n                                                complete: complete,\r\n                                                step: step\r\n                                            },\r\n                                            startTime: timeStart\r\n                                        });\r\n                                    }\r\n                                }\r\n\r\n                                if (isFunction(progress))\r\n                                    progress({}, percent, MATH.max(0, duration - elapsed));\r\n\r\n                                if (end) {\r\n                                    startNextAnimationInQ(animObj);\r\n                                    if (isFunction(complete))\r\n                                        complete();\r\n                                }\r\n                                else\r\n                                    qObj.frame = COMPATIBILITY.rAF()(frame);\r\n                            };\r\n                            qObj.frame = COMPATIBILITY.rAF()(frame);\r\n                        }\r\n                        else {\r\n                            for (key in to)\r\n                                setAnimationValue(el, key, to[key]);\r\n                            startNextAnimationInQ(animObj);\r\n                        }\r\n                    }\r\n                }\r\n                else if (guaranteedNext)\r\n                    startNextAnimationInQ(animObj);\r\n            }\r\n\r\n            function stop(el, clearQ, jumpToEnd) {\r\n                var animObj;\r\n                var qObj;\r\n                var key;\r\n                var i = 0;\r\n                for (; i < _animations[LEXICON.l]; i++) {\r\n                    animObj = _animations[i];\r\n                    if (animObj.el === el) {\r\n                        if (animObj.q[LEXICON.l] > 0) {\r\n                            qObj = animObj.q[0];\r\n                            qObj.stop = true;\r\n                            COMPATIBILITY.cAF()(qObj.frame);\r\n                            animObj.q.splice(0, 1);\r\n\r\n                            if (jumpToEnd)\r\n                                for (key in qObj.props)\r\n                                    setAnimationValue(el, key, qObj.props[key]);\r\n\r\n                            if (clearQ)\r\n                                animObj.q = [];\r\n                            else\r\n                                startNextAnimationInQ(animObj, false);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            function elementIsVisible(el) {\r\n                return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);\r\n            }\r\n\r\n            function FakejQuery(selector) {\r\n                if (arguments[LEXICON.l] === 0)\r\n                    return this;\r\n\r\n                var base = new FakejQuery();\r\n                var elements = selector;\r\n                var i = 0;\r\n                var elms;\r\n                var el;\r\n\r\n                if (_type(selector) == TYPES.s) {\r\n                    elements = [];\r\n                    if (selector.charAt(0) === '<') {\r\n                        el = document.createElement('div');\r\n                        el.innerHTML = selector;\r\n                        elms = el.children;\r\n                    }\r\n                    else {\r\n                        elms = document.querySelectorAll(selector);\r\n                    }\r\n\r\n                    for (; i < elms[LEXICON.l]; i++)\r\n                        elements.push(elms[i]);\r\n                }\r\n\r\n                if (elements) {\r\n                    if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self))\r\n                        elements = [elements];\r\n\r\n                    for (i = 0; i < elements[LEXICON.l]; i++)\r\n                        base[i] = elements[i];\r\n\r\n                    base[LEXICON.l] = elements[LEXICON.l];\r\n                }\r\n\r\n                return base;\r\n            };\r\n\r\n            FakejQuery[LEXICON.p] = {\r\n\r\n                //EVENTS:\r\n\r\n                on: function (eventName, handler) {\r\n                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\r\n\r\n                    var eventNameLength = eventName[LEXICON.l];\r\n                    var i = 0;\r\n                    var el;\r\n                    return this.each(function () {\r\n                        el = this;\r\n                        try {\r\n                            if (el.addEventListener) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.addEventListener(eventName[i], handler);\r\n                            }\r\n                            else if (el.detachEvent) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.attachEvent('on' + eventName[i], handler);\r\n                            }\r\n                        } catch (e) { }\r\n                    });\r\n                },\r\n\r\n                off: function (eventName, handler) {\r\n                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\r\n\r\n                    var eventNameLength = eventName[LEXICON.l];\r\n                    var i = 0;\r\n                    var el;\r\n                    return this.each(function () {\r\n                        el = this;\r\n                        try {\r\n                            if (el.removeEventListener) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.removeEventListener(eventName[i], handler);\r\n                            }\r\n                            else if (el.detachEvent) {\r\n                                for (; i < eventNameLength; i++)\r\n                                    el.detachEvent('on' + eventName[i], handler);\r\n                            }\r\n                        } catch (e) { }\r\n                    });\r\n                },\r\n\r\n                one: function (eventName, handler) {\r\n                    eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];\r\n                    return this.each(function () {\r\n                        var el = FakejQuery(this);\r\n                        FakejQuery.each(eventName, function (i, oneEventName) {\r\n                            var oneHandler = function (e) {\r\n                                handler.call(this, e);\r\n                                el.off(oneEventName, oneHandler);\r\n                            };\r\n                            el.on(oneEventName, oneHandler);\r\n                        });\r\n                    });\r\n                },\r\n\r\n                trigger: function (eventName) {\r\n                    var el;\r\n                    var event;\r\n                    return this.each(function () {\r\n                        el = this;\r\n                        if (document.createEvent) {\r\n                            event = document.createEvent('HTMLEvents');\r\n                            event.initEvent(eventName, true, false);\r\n                            el.dispatchEvent(event);\r\n                        }\r\n                        else {\r\n                            el.fireEvent('on' + eventName);\r\n                        }\r\n                    });\r\n                },\r\n\r\n                //DOM NODE INSERTING / REMOVING:\r\n\r\n                append: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'beforeend', child); });\r\n                },\r\n\r\n                prepend: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'afterbegin', child); });\r\n                },\r\n\r\n                before: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'beforebegin', child); });\r\n                },\r\n\r\n                after: function (child) {\r\n                    return this.each(function () { insertAdjacentElement(this, 'afterend', child); });\r\n                },\r\n\r\n                remove: function () {\r\n                    return this.each(function () {\r\n                        var el = this;\r\n                        var parentNode = el.parentNode;\r\n                        if (parentNode != null)\r\n                            parentNode.removeChild(el);\r\n                    });\r\n                },\r\n\r\n                unwrap: function () {\r\n                    var parents = [];\r\n                    var i;\r\n                    var el;\r\n                    var parent;\r\n\r\n                    this.each(function () {\r\n                        parent = this.parentNode;\r\n                        if (inArray(parent, parents) === - 1)\r\n                            parents.push(parent);\r\n                    });\r\n\r\n                    for (i = 0; i < parents[LEXICON.l]; i++) {\r\n                        el = parents[i];\r\n                        parent = el.parentNode;\r\n                        while (el.firstChild)\r\n                            parent.insertBefore(el.firstChild, el);\r\n                        parent.removeChild(el);\r\n                    }\r\n\r\n                    return this;\r\n                },\r\n\r\n                wrapAll: function (wrapperHTML) {\r\n                    var i;\r\n                    var nodes = this;\r\n                    var wrapper = FakejQuery(wrapperHTML)[0];\r\n                    var deepest = wrapper;\r\n                    var parent = nodes[0].parentNode;\r\n                    var previousSibling = nodes[0].previousSibling;\r\n                    while (deepest.childNodes[LEXICON.l] > 0)\r\n                        deepest = deepest.childNodes[0];\r\n\r\n                    for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++)\r\n                        deepest.appendChild(nodes[i]);\r\n\r\n                    var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;\r\n                    parent.insertBefore(wrapper, nextSibling);\r\n\r\n                    return this;\r\n                },\r\n\r\n                wrapInner: function (wrapperHTML) {\r\n                    return this.each(function () {\r\n                        var el = FakejQuery(this);\r\n                        var contents = el.contents();\r\n\r\n                        if (contents[LEXICON.l])\r\n                            contents.wrapAll(wrapperHTML);\r\n                        else\r\n                            el.append(wrapperHTML);\r\n                    });\r\n                },\r\n\r\n                wrap: function (wrapperHTML) {\r\n                    return this.each(function () { FakejQuery(this).wrapAll(wrapperHTML); });\r\n                },\r\n\r\n\r\n                //DOM NODE MANIPULATION / INFORMATION:\r\n\r\n                css: function (styles, val) {\r\n                    var el;\r\n                    var key;\r\n                    var cptStyle;\r\n                    var getCptStyle = window.getComputedStyle;\r\n                    if (_type(styles) == TYPES.s) {\r\n                        if (val === undefined) {\r\n                            el = this[0];\r\n                            cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles];\r\n\r\n                            //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)\r\n                            return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;\r\n                        }\r\n                        else {\r\n                            return this.each(function () {\r\n                                setCSSVal(this, styles, val);\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        return this.each(function () {\r\n                            for (key in styles)\r\n                                setCSSVal(this, key, styles[key]);\r\n                        });\r\n                    }\r\n                },\r\n\r\n                hasClass: function (className) {\r\n                    var elem, i = 0;\r\n                    var classNamePrepared = _strSpace + className + _strSpace;\r\n                    var classList;\r\n\r\n                    while ((elem = this[i++])) {\r\n                        classList = elem.classList;\r\n                        if (classList && classList.contains(className))\r\n                            return true;\r\n                        else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1)\r\n                            return true;\r\n                    }\r\n\r\n                    return false;\r\n                },\r\n\r\n                addClass: function (className) {\r\n                    var classes;\r\n                    var elem;\r\n                    var cur;\r\n                    var curValue;\r\n                    var clazz;\r\n                    var finalValue;\r\n                    var supportClassList;\r\n                    var elmClassList;\r\n                    var i = 0;\r\n                    var v = 0;\r\n\r\n                    if (className) {\r\n                        classes = className.match(_rnothtmlwhite) || [];\r\n\r\n                        while ((elem = this[i++])) {\r\n                            elmClassList = elem.classList;\r\n                            if (supportClassList === undefined)\r\n                                supportClassList = elmClassList !== undefined;\r\n\r\n                            if (supportClassList) {\r\n                                while ((clazz = classes[v++]))\r\n                                    elmClassList.add(clazz);\r\n                            }\r\n                            else {\r\n                                curValue = elem.className + _strEmpty;\r\n                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);\r\n\r\n                                if (cur) {\r\n                                    while ((clazz = classes[v++]))\r\n                                        if (cur.indexOf(_strSpace + clazz + _strSpace) < 0)\r\n                                            cur += clazz + _strSpace;\r\n\r\n                                    finalValue = stripAndCollapse(cur);\r\n                                    if (curValue !== finalValue)\r\n                                        elem.className = finalValue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return this;\r\n                },\r\n\r\n                removeClass: function (className) {\r\n                    var classes;\r\n                    var elem;\r\n                    var cur;\r\n                    var curValue;\r\n                    var clazz;\r\n                    var finalValue;\r\n                    var supportClassList;\r\n                    var elmClassList;\r\n                    var i = 0;\r\n                    var v = 0;\r\n\r\n                    if (className) {\r\n                        classes = className.match(_rnothtmlwhite) || [];\r\n\r\n                        while ((elem = this[i++])) {\r\n                            elmClassList = elem.classList;\r\n                            if (supportClassList === undefined)\r\n                                supportClassList = elmClassList !== undefined;\r\n\r\n                            if (supportClassList) {\r\n                                while ((clazz = classes[v++]))\r\n                                    elmClassList.remove(clazz);\r\n                            }\r\n                            else {\r\n                                curValue = elem.className + _strEmpty;\r\n                                cur = elem.nodeType === 1 && (_strSpace + stripAndCollapse(curValue) + _strSpace);\r\n\r\n                                if (cur) {\r\n                                    while ((clazz = classes[v++]))\r\n                                        while (cur.indexOf(_strSpace + clazz + _strSpace) > -1)\r\n                                            cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);\r\n\r\n                                    finalValue = stripAndCollapse(cur);\r\n                                    if (curValue !== finalValue)\r\n                                        elem.className = finalValue;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return this;\r\n                },\r\n\r\n                hide: function () {\r\n                    return this.each(function () { this[LEXICON.s].display = 'none'; });\r\n                },\r\n\r\n                show: function () {\r\n                    return this.each(function () { this[LEXICON.s].display = 'block'; });\r\n                },\r\n\r\n                attr: function (attrName, value) {\r\n                    var i = 0;\r\n                    var el;\r\n                    while (el = this[i++]) {\r\n                        if (value === undefined)\r\n                            return el.getAttribute(attrName);\r\n                        el.setAttribute(attrName, value);\r\n                    }\r\n                    return this;\r\n                },\r\n\r\n                removeAttr: function (attrName) {\r\n                    return this.each(function () { this.removeAttribute(attrName); });\r\n                },\r\n\r\n                offset: function () {\r\n                    var el = this[0];\r\n                    var rect = el[LEXICON.bCR]();\r\n                    var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];\r\n                    var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];\r\n                    return {\r\n                        top: rect.top + scrollTop,\r\n                        left: rect.left + scrollLeft\r\n                    };\r\n                },\r\n\r\n                position: function () {\r\n                    var el = this[0];\r\n                    return {\r\n                        top: el.offsetTop,\r\n                        left: el.offsetLeft\r\n                    };\r\n                },\r\n\r\n                scrollLeft: function (value) {\r\n                    var i = 0;\r\n                    var el;\r\n                    while (el = this[i++]) {\r\n                        if (value === undefined)\r\n                            return el[_strScrollLeft];\r\n                        el[_strScrollLeft] = value;\r\n                    }\r\n                    return this;\r\n                },\r\n\r\n                scrollTop: function (value) {\r\n                    var i = 0;\r\n                    var el;\r\n                    while (el = this[i++]) {\r\n                        if (value === undefined)\r\n                            return el[_strScrollTop];\r\n                        el[_strScrollTop] = value;\r\n                    }\r\n                    return this;\r\n                },\r\n\r\n                val: function (value) {\r\n                    var el = this[0];\r\n                    if (!value)\r\n                        return el.value;\r\n                    el.value = value;\r\n                    return this;\r\n                },\r\n\r\n\r\n                //DOM TRAVERSAL / FILTERING:\r\n\r\n                first: function () {\r\n                    return this.eq(0);\r\n                },\r\n\r\n                last: function () {\r\n                    return this.eq(-1);\r\n                },\r\n\r\n                eq: function (index) {\r\n                    return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);\r\n                },\r\n\r\n                find: function (selector) {\r\n                    var children = [];\r\n                    var i;\r\n                    this.each(function () {\r\n                        var el = this;\r\n                        var ch = el.querySelectorAll(selector);\r\n                        for (i = 0; i < ch[LEXICON.l]; i++)\r\n                            children.push(ch[i]);\r\n                    });\r\n                    return FakejQuery(children);\r\n                },\r\n\r\n                children: function (selector) {\r\n                    var children = [];\r\n                    var el;\r\n                    var ch;\r\n                    var i;\r\n\r\n                    this.each(function () {\r\n                        ch = this.children;\r\n                        for (i = 0; i < ch[LEXICON.l]; i++) {\r\n                            el = ch[i];\r\n                            if (selector) {\r\n                                if ((el.matches && el.matches(selector)) || matches(el, selector))\r\n                                    children.push(el);\r\n                            }\r\n                            else\r\n                                children.push(el);\r\n                        }\r\n                    });\r\n                    return FakejQuery(children);\r\n                },\r\n\r\n                parent: function (selector) {\r\n                    var parents = [];\r\n                    var parent;\r\n                    this.each(function () {\r\n                        parent = this.parentNode;\r\n                        if (selector ? FakejQuery(parent).is(selector) : true)\r\n                            parents.push(parent);\r\n                    });\r\n                    return FakejQuery(parents);\r\n                },\r\n\r\n                is: function (selector) {\r\n\r\n                    var el;\r\n                    var i;\r\n                    for (i = 0; i < this[LEXICON.l]; i++) {\r\n                        el = this[i];\r\n                        if (selector === ':visible')\r\n                            return elementIsVisible(el);\r\n                        if (selector === ':hidden')\r\n                            return !elementIsVisible(el);\r\n                        if ((el.matches && el.matches(selector)) || matches(el, selector))\r\n                            return true;\r\n                    }\r\n                    return false;\r\n                },\r\n\r\n                contents: function () {\r\n                    var contents = [];\r\n                    var childs;\r\n                    var i;\r\n\r\n                    this.each(function () {\r\n                        childs = this.childNodes;\r\n                        for (i = 0; i < childs[LEXICON.l]; i++)\r\n                            contents.push(childs[i]);\r\n                    });\r\n\r\n                    return FakejQuery(contents);\r\n                },\r\n\r\n                each: function (callback) {\r\n                    return each(this, callback);\r\n                },\r\n\r\n\r\n                //ANIMATION:\r\n\r\n                animate: function (props, duration, easing, complete) {\r\n                    return this.each(function () { animate(this, props, duration, easing, complete); });\r\n                },\r\n\r\n                stop: function (clearQ, jump) {\r\n                    return this.each(function () { stop(this, clearQ, jump); });\r\n                }\r\n            };\r\n\r\n            extend(FakejQuery, {\r\n                extend: extend,\r\n                inArray: inArray,\r\n                isEmptyObject: isEmptyObject,\r\n                isPlainObject: isPlainObject,\r\n                each: each\r\n            });\r\n\r\n            return FakejQuery;\r\n        })();\r\n        var INSTANCES = (function () {\r\n            var _targets = [];\r\n            var _instancePropertyString = '__overlayScrollbars__';\r\n\r\n            /**\r\n             * Register, unregister or get a certain (or all) instances.\r\n             * Register: Pass the target and the instance.\r\n             * Unregister: Pass the target and null.\r\n             * Get Instance: Pass the target from which the instance shall be got.\r\n             * Get Targets: Pass no arguments.\r\n             * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got\r\n             * @param instance The instance.\r\n             * @returns {*|void} Returns the instance from the given target.\r\n             */\r\n            return function (target, instance) {\r\n                var argLen = arguments[LEXICON.l];\r\n                if (argLen < 1) {\r\n                    //return all targets\r\n                    return _targets;\r\n                }\r\n                else {\r\n                    if (instance) {\r\n                        //register instance\r\n                        target[_instancePropertyString] = instance;\r\n                        _targets.push(target);\r\n                    }\r\n                    else {\r\n                        var index = COMPATIBILITY.inA(target, _targets);\r\n                        if (index > -1) {\r\n                            if (argLen > 1) {\r\n                                //unregister instance\r\n                                delete target[_instancePropertyString];\r\n                                _targets.splice(index, 1);\r\n                            }\r\n                            else {\r\n                                //get instance from target\r\n                                return _targets[index][_instancePropertyString];\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        })();\r\n        var PLUGIN = (function () {\r\n            var _plugin;\r\n            var _pluginsGlobals;\r\n            var _pluginsAutoUpdateLoop;\r\n            var _pluginsExtensions = [];\r\n            var _pluginsOptions = (function () {\r\n                var type = COMPATIBILITY.type;\r\n                var possibleTemplateTypes = [\r\n                    TYPES.b, //boolean\r\n                    TYPES.n, //number\r\n                    TYPES.s, //string\r\n                    TYPES.a, //array\r\n                    TYPES.o, //object\r\n                    TYPES.f, //function\r\n                    TYPES.z  //null\r\n                ];\r\n                var restrictedStringsSplit = ' ';\r\n                var restrictedStringsPossibilitiesSplit = ':';\r\n                var classNameAllowedValues = [TYPES.z, TYPES.s];\r\n                var numberAllowedValues = TYPES.n;\r\n                var booleanNullAllowedValues = [TYPES.z, TYPES.b];\r\n                var booleanTrueTemplate = [true, TYPES.b];\r\n                var booleanFalseTemplate = [false, TYPES.b];\r\n                var callbackTemplate = [null, [TYPES.z, TYPES.f]];\r\n                var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];\r\n                var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];\r\n                var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';\r\n                var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';\r\n                var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';\r\n                var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';\r\n                var optionsDefaultsAndTemplate = {\r\n                    className: ['os-theme-dark', classNameAllowedValues],                //null || string\r\n                    resize: ['none', resizeAllowedValues],                               //none || both  || horizontal || vertical || n || b || h || v\r\n                    sizeAutoCapable: booleanTrueTemplate,                                //true || false\r\n                    clipAlways: booleanTrueTemplate,                                     //true || false\r\n                    normalizeRTL: booleanTrueTemplate,                                   //true || false\r\n                    paddingAbsolute: booleanFalseTemplate,                               //true || false\r\n                    autoUpdate: [null, booleanNullAllowedValues],                        //true || false || null\r\n                    autoUpdateInterval: [33, numberAllowedValues],                       //number\r\n                    updateOnLoad: updateOnLoadTemplate,                                  //string || array || null\r\n                    nativeScrollbarsOverlaid: {\r\n                        showNativeScrollbars: booleanFalseTemplate,                      //true || false\r\n                        initialize: booleanTrueTemplate                                  //true || false\r\n                    },\r\n                    overflowBehavior: {\r\n                        x: ['scroll', overflowBehaviorAllowedValues],                    //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s\r\n                        y: ['scroll', overflowBehaviorAllowedValues]                     //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s\r\n                    },\r\n                    scrollbars: {\r\n                        visibility: ['auto', scrollbarsVisibilityAllowedValues],         //visible || hidden || auto || v || h || a\r\n                        autoHide: ['never', scrollbarsAutoHideAllowedValues],            //never || scroll || leave || move || n || s || l || m\r\n                        autoHideDelay: [800, numberAllowedValues],                       //number\r\n                        dragScrolling: booleanTrueTemplate,                              //true || false\r\n                        clickScrolling: booleanFalseTemplate,                            //true || false\r\n                        touchSupport: booleanTrueTemplate,                               //true || false\r\n                        snapHandle: booleanFalseTemplate                                 //true || false\r\n                    },\r\n                    textarea: {\r\n                        dynWidth: booleanFalseTemplate,                                  //true || false\r\n                        dynHeight: booleanFalseTemplate,                                 //true || false\r\n                        inheritedAttrs: inheritedAttrsTemplate                           //string || array || null\r\n                    },\r\n                    callbacks: {\r\n                        onInitialized: callbackTemplate,                                 //null || function\r\n                        onInitializationWithdrawn: callbackTemplate,                     //null || function\r\n                        onDestroyed: callbackTemplate,                                   //null || function\r\n                        onScrollStart: callbackTemplate,                                 //null || function\r\n                        onScroll: callbackTemplate,                                      //null || function\r\n                        onScrollStop: callbackTemplate,                                  //null || function\r\n                        onOverflowChanged: callbackTemplate,                             //null || function\r\n                        onOverflowAmountChanged: callbackTemplate,                       //null || function\r\n                        onDirectionChanged: callbackTemplate,                            //null || function\r\n                        onContentSizeChanged: callbackTemplate,                          //null || function\r\n                        onHostSizeChanged: callbackTemplate,                             //null || function\r\n                        onUpdated: callbackTemplate                                      //null || function\r\n                    }\r\n                };\r\n                var convert = function (template) {\r\n                    var recursive = function (obj) {\r\n                        var key;\r\n                        var val;\r\n                        var valType;\r\n                        for (key in obj) {\r\n                            if (!obj[LEXICON.hOP](key))\r\n                                continue;\r\n                            val = obj[key];\r\n                            valType = type(val);\r\n                            if (valType == TYPES.a)\r\n                                obj[key] = val[template ? 1 : 0];\r\n                            else if (valType == TYPES.o)\r\n                                obj[key] = recursive(val);\r\n                        }\r\n                        return obj;\r\n                    };\r\n                    return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));\r\n                };\r\n\r\n                return {\r\n                    _defaults: convert(),\r\n\r\n                    _template: convert(true),\r\n\r\n                    /**\r\n                     * Validates the passed object by the passed template.\r\n                     * @param obj The object which shall be validated.\r\n                     * @param template The template which defines the allowed values and types.\r\n                     * @param writeErrors True if errors shall be logged to the console.\r\n                     * @param diffObj If a object is passed then only valid differences to this object will be returned.\r\n                     * @returns {{}} A object which contains two objects called \"default\" and \"prepared\" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.\r\n                     */\r\n                    _validate: function (obj, template, writeErrors, diffObj) {\r\n                        var validatedOptions = {};\r\n                        var validatedOptionsPrepared = {};\r\n                        var objectCopy = FRAMEWORK.extend(true, {}, obj);\r\n                        var inArray = FRAMEWORK.inArray;\r\n                        var isEmptyObj = FRAMEWORK.isEmptyObject;\r\n                        var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {\r\n                            for (var prop in template) {\r\n                                if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {\r\n                                    var isValid = false;\r\n                                    var isDiff = false;\r\n                                    var templateValue = template[prop];\r\n                                    var templateValueType = type(templateValue);\r\n                                    var templateIsComplex = templateValueType == TYPES.o;\r\n                                    var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;\r\n                                    var dataDiffValue = diffData[prop];\r\n                                    var dataValue = data[prop];\r\n                                    var dataValueType = type(dataValue);\r\n                                    var propPrefix = prevPropName ? prevPropName + '.' : '';\r\n                                    var error = \"The option \\\"\" + propPrefix + prop + \"\\\" wasn't set, because\";\r\n                                    var errorPossibleTypes = [];\r\n                                    var errorRestrictedStrings = [];\r\n                                    var restrictedStringValuesSplit;\r\n                                    var restrictedStringValuesPossibilitiesSplit;\r\n                                    var isRestrictedValue;\r\n                                    var mainPossibility;\r\n                                    var currType;\r\n                                    var i;\r\n                                    var v;\r\n                                    var j;\r\n\r\n                                    dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue;\r\n\r\n                                    //if the template has a object as value, it means that the options are complex (verschachtelt)\r\n                                    if (templateIsComplex && dataValueType == TYPES.o) {\r\n                                        validatedOptions[prop] = {};\r\n                                        validatedOptionsPrepared[prop] = {};\r\n                                        checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);\r\n                                        FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {\r\n                                            if (isEmptyObj(value[prop])) {\r\n                                                delete value[prop];\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                    else if (!templateIsComplex) {\r\n                                        for (i = 0; i < templateTypes[LEXICON.l]; i++) {\r\n                                            currType = templateTypes[i];\r\n                                            templateValueType = type(currType);\r\n                                            //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix\r\n                                            isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;\r\n                                            if (isRestrictedValue) {\r\n                                                errorPossibleTypes.push(TYPES.s);\r\n\r\n                                                //split it into a array which contains all possible values for example: [\"y:yes\", \"n:no\", \"m:maybe\"]\r\n                                                restrictedStringValuesSplit = currType.split(restrictedStringsSplit);\r\n                                                errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);\r\n                                                for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {\r\n                                                    //split the possible values into their possibiliteis for example: [\"y\", \"yes\"] -> the first is always the mainPossibility\r\n                                                    restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);\r\n                                                    mainPossibility = restrictedStringValuesPossibilitiesSplit[0];\r\n                                                    for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {\r\n                                                        //if any possibility matches with the dataValue, its valid\r\n                                                        if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {\r\n                                                            isValid = true;\r\n                                                            break;\r\n                                                        }\r\n                                                    }\r\n                                                    if (isValid)\r\n                                                        break;\r\n                                                }\r\n                                            }\r\n                                            else {\r\n                                                errorPossibleTypes.push(currType);\r\n\r\n                                                if (dataValueType === currType) {\r\n                                                    isValid = true;\r\n                                                    break;\r\n                                                }\r\n                                            }\r\n                                        }\r\n\r\n                                        if (isValid) {\r\n                                            isDiff = dataValue !== dataDiffValue;\r\n\r\n                                            if (isDiff)\r\n                                                validatedOptions[prop] = dataValue;\r\n\r\n                                            if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff)\r\n                                                validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;\r\n                                        }\r\n                                        else if (writeErrors) {\r\n                                            console.warn(error + \" it doesn't accept the type [ \" + dataValueType.toUpperCase() + \" ] with the value of \\\"\" + dataValue + \"\\\".\\r\\n\" +\r\n                                                \"Accepted types are: [ \" + errorPossibleTypes.join(', ').toUpperCase() + \" ].\" +\r\n                                                (errorRestrictedStrings[length] > 0 ? \"\\r\\nValid strings are: [ \" + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + \" ].\" : ''));\r\n                                        }\r\n                                        delete data[prop];\r\n                                    }\r\n                                }\r\n                            }\r\n                        };\r\n                        checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared);\r\n\r\n                        //add values which aren't specified in the template to the finished validated object to prevent them from being discarded\r\n                        /*\r\n                        if(keepForeignProps) {\r\n                            FRAMEWORK.extend(true, validatedOptions, objectCopy);\r\n                            FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);\r\n                        }\r\n                        */\r\n\r\n                        if (!isEmptyObj(objectCopy) && writeErrors)\r\n                            console.warn('The following options are discarded due to invalidity:\\r\\n' + window.JSON.stringify(objectCopy, null, 2));\r\n\r\n                        return {\r\n                            _default: validatedOptions,\r\n                            _prepared: validatedOptionsPrepared\r\n                        };\r\n                    }\r\n                }\r\n            }());\r\n\r\n            /**\r\n             * Initializes the object which contains global information about the plugin and each instance of it.\r\n             */\r\n            function initOverlayScrollbarsStatics() {\r\n                if (!_pluginsGlobals)\r\n                    _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);\r\n                if (!_pluginsAutoUpdateLoop)\r\n                    _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);\r\n            }\r\n\r\n            /**\r\n             * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.\r\n             * @param defaultOptions\r\n             * @constructor\r\n             */\r\n            function OverlayScrollbarsGlobals(defaultOptions) {\r\n                var _base = this;\r\n                var strOverflow = 'overflow';\r\n                var strHidden = 'hidden';\r\n                var strScroll = 'scroll';\r\n                var bodyElement = FRAMEWORK('body');\r\n                var scrollbarDummyElement = FRAMEWORK('<div id=\"os-dummy-scrollbar-size\"><div></div></div>');\r\n                var scrollbarDummyElement0 = scrollbarDummyElement[0];\r\n                var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));\r\n\r\n                bodyElement.append(scrollbarDummyElement);\r\n                scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)\r\n\r\n                var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);\r\n                var nativeScrollbarIsOverlaid = {\r\n                    x: nativeScrollbarSize.x === 0,\r\n                    y: nativeScrollbarSize.y === 0\r\n                };\r\n                var msie = (function () {\r\n                    var ua = window.navigator.userAgent;\r\n                    var strIndexOf = 'indexOf';\r\n                    var strSubString = 'substring';\r\n                    var msie = ua[strIndexOf]('MSIE ');\r\n                    var trident = ua[strIndexOf]('Trident/');\r\n                    var edge = ua[strIndexOf]('Edge/');\r\n                    var rv = ua[strIndexOf]('rv:');\r\n                    var result;\r\n                    var parseIntFunc = parseInt;\r\n\r\n                    // IE 10 or older => return version number\r\n                    if (msie > 0)\r\n                        result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10);\r\n\r\n                    // IE 11 => return version number\r\n                    else if (trident > 0)\r\n                        result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10);\r\n\r\n                    // Edge (IE 12+) => return version number\r\n                    else if (edge > 0)\r\n                        result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10);\r\n\r\n                    // other browser\r\n                    return result;\r\n                })();\r\n\r\n                FRAMEWORK.extend(_base, {\r\n                    defaultOptions: defaultOptions,\r\n                    msie: msie,\r\n                    autoUpdateLoop: false,\r\n                    autoUpdateRecommended: !COMPATIBILITY.mO(),\r\n                    nativeScrollbarSize: nativeScrollbarSize,\r\n                    nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,\r\n                    nativeScrollbarStyling: (function () {\r\n                        var result = false;\r\n                        scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');\r\n                        try {\r\n                            result = (scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie)) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';\r\n                        } catch (ex) { }\r\n\r\n                        //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.\r\n                        //and set overflow to scroll\r\n                        //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();\r\n                        //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;\r\n\r\n                        return result;\r\n                    })(),\r\n                    overlayScrollbarDummySize: { x: 30, y: 30 },\r\n                    cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,\r\n                    restrictedMeasuring: (function () {\r\n                        //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305\r\n                        //since 1.11.0 always false -> fixed via CSS (hopefully)\r\n                        scrollbarDummyElement.css(strOverflow, strHidden);\r\n                        var scrollSize = {\r\n                            w: scrollbarDummyElement0[LEXICON.sW],\r\n                            h: scrollbarDummyElement0[LEXICON.sH]\r\n                        };\r\n                        scrollbarDummyElement.css(strOverflow, 'visible');\r\n                        var scrollSize2 = {\r\n                            w: scrollbarDummyElement0[LEXICON.sW],\r\n                            h: scrollbarDummyElement0[LEXICON.sH]\r\n                        };\r\n                        return (scrollSize.w - scrollSize2.w) !== 0 || (scrollSize.h - scrollSize2.h) !== 0;\r\n                    })(),\r\n                    rtlScrollBehavior: (function () {\r\n                        scrollbarDummyElement.css({ 'overflow-y': strHidden, 'overflow-x': strScroll, 'direction': 'rtl' }).scrollLeft(0);\r\n                        var dummyContainerOffset = scrollbarDummyElement.offset();\r\n                        var dummyContainerChildOffset = dummyContainerChild.offset();\r\n                        //https://github.com/KingSora/OverlayScrollbars/issues/187\r\n                        scrollbarDummyElement.scrollLeft(-999);\r\n                        var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();\r\n                        return {\r\n                            //origin direction = determines if the zero scroll position is on the left or right side\r\n                            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)\r\n                            //true = on the left side\r\n                            //false = on the right side\r\n                            i: dummyContainerOffset.left === dummyContainerChildOffset.left,\r\n                            //negative = determines if the maximum scroll is positive or negative\r\n                            //'n' means 'negate' (n === true means that the axis must be negated to be correct)\r\n                            //true = negative\r\n                            //false = positive\r\n                            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left\r\n                        };\r\n                    })(),\r\n                    supportTransform: !!VENDORS._cssProperty('transform'),\r\n                    supportTransition: !!VENDORS._cssProperty('transition'),\r\n                    supportPassiveEvents: (function () {\r\n                        var supportsPassive = false;\r\n                        try {\r\n                            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\r\n                                get: function () {\r\n                                    supportsPassive = true;\r\n                                }\r\n                            }));\r\n                        } catch (e) { }\r\n                        return supportsPassive;\r\n                    })(),\r\n                    supportResizeObserver: !!COMPATIBILITY.rO(),\r\n                    supportMutationObserver: !!COMPATIBILITY.mO()\r\n                });\r\n\r\n                scrollbarDummyElement.removeAttr(LEXICON.s).remove();\r\n\r\n                //Catch zoom event:\r\n                (function () {\r\n                    if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y)\r\n                        return;\r\n\r\n                    var abs = MATH.abs;\r\n                    var windowWidth = COMPATIBILITY.wW();\r\n                    var windowHeight = COMPATIBILITY.wH();\r\n                    var windowDpr = getWindowDPR();\r\n                    var onResize = function () {\r\n                        if (INSTANCES().length > 0) {\r\n                            var newW = COMPATIBILITY.wW();\r\n                            var newH = COMPATIBILITY.wH();\r\n                            var deltaW = newW - windowWidth;\r\n                            var deltaH = newH - windowHeight;\r\n\r\n                            if (deltaW === 0 && deltaH === 0)\r\n                                return;\r\n\r\n                            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));\r\n                            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));\r\n                            var absDeltaW = abs(deltaW);\r\n                            var absDeltaH = abs(deltaH);\r\n                            var absDeltaWRatio = abs(deltaWRatio);\r\n                            var absDeltaHRatio = abs(deltaHRatio);\r\n                            var newDPR = getWindowDPR();\r\n\r\n                            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;\r\n                            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);\r\n                            var dprChanged = newDPR !== windowDpr && windowDpr > 0;\r\n                            var isZoom = deltaIsBigger && difference && dprChanged;\r\n                            var oldScrollbarSize = _base.nativeScrollbarSize;\r\n                            var newScrollbarSize;\r\n\r\n                            if (isZoom) {\r\n                                bodyElement.append(scrollbarDummyElement);\r\n                                newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);\r\n                                scrollbarDummyElement.remove();\r\n                                if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {\r\n                                    FRAMEWORK.each(INSTANCES(), function () {\r\n                                        if (INSTANCES(this))\r\n                                            INSTANCES(this).update('zoom');\r\n                                    });\r\n                                }\r\n                            }\r\n\r\n                            windowWidth = newW;\r\n                            windowHeight = newH;\r\n                            windowDpr = newDPR;\r\n                        }\r\n                    };\r\n\r\n                    function differenceIsBiggerThanOne(valOne, valTwo) {\r\n                        var absValOne = abs(valOne);\r\n                        var absValTwo = abs(valTwo);\r\n                        return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);\r\n                    }\r\n\r\n                    function getWindowDPR() {\r\n                        var dDPI = window.screen.deviceXDPI || 0;\r\n                        var sDPI = window.screen.logicalXDPI || 1;\r\n                        return window.devicePixelRatio || (dDPI / sDPI);\r\n                    }\r\n\r\n                    FRAMEWORK(window).on('resize', onResize);\r\n                })();\r\n\r\n                function calcNativeScrollbarSize(measureElement) {\r\n                    return {\r\n                        x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],\r\n                        y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]\r\n                    };\r\n                }\r\n            }\r\n\r\n            /**\r\n             * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.\r\n             * @constructor\r\n             */\r\n            function OverlayScrollbarsAutoUpdateLoop(globals) {\r\n                var _base = this;\r\n                var _inArray = FRAMEWORK.inArray;\r\n                var _getNow = COMPATIBILITY.now;\r\n                var _strAutoUpdate = 'autoUpdate';\r\n                var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';\r\n                var _strLength = LEXICON.l;\r\n                var _loopingInstances = [];\r\n                var _loopingInstancesIntervalCache = [];\r\n                var _loopIsActive = false;\r\n                var _loopIntervalDefault = 33;\r\n                var _loopInterval = _loopIntervalDefault;\r\n                var _loopTimeOld = _getNow();\r\n                var _loopID;\r\n\r\n\r\n                /**\r\n                 * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.\r\n                 */\r\n                var loop = function () {\r\n                    if (_loopingInstances[_strLength] > 0 && _loopIsActive) {\r\n                        _loopID = COMPATIBILITY.rAF()(function () {\r\n                            loop();\r\n                        });\r\n                        var timeNew = _getNow();\r\n                        var timeDelta = timeNew - _loopTimeOld;\r\n                        var lowestInterval;\r\n                        var instance;\r\n                        var instanceOptions;\r\n                        var instanceAutoUpdateAllowed;\r\n                        var instanceAutoUpdateInterval;\r\n                        var now;\r\n\r\n                        if (timeDelta > _loopInterval) {\r\n                            _loopTimeOld = timeNew - (timeDelta % _loopInterval);\r\n                            lowestInterval = _loopIntervalDefault;\r\n                            for (var i = 0; i < _loopingInstances[_strLength]; i++) {\r\n                                instance = _loopingInstances[i];\r\n                                if (instance !== undefined) {\r\n                                    instanceOptions = instance.options();\r\n                                    instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];\r\n                                    instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);\r\n                                    now = _getNow();\r\n\r\n                                    if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && (now - _loopingInstancesIntervalCache[i]) > instanceAutoUpdateInterval) {\r\n                                        instance.update('auto');\r\n                                        _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);\r\n                                    }\r\n\r\n                                    lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));\r\n                                }\r\n                            }\r\n                            _loopInterval = lowestInterval;\r\n                        }\r\n                    } else {\r\n                        _loopInterval = _loopIntervalDefault;\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.\r\n                 * @param instance The instance which shall be updated in a loop automatically.\r\n                 */\r\n                _base.add = function (instance) {\r\n                    if (_inArray(instance, _loopingInstances) === -1) {\r\n                        _loopingInstances.push(instance);\r\n                        _loopingInstancesIntervalCache.push(_getNow());\r\n                        if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {\r\n                            _loopIsActive = true;\r\n                            globals.autoUpdateLoop = _loopIsActive;\r\n                            loop();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.\r\n                 * @param instance The instance which shall be updated in a loop automatically.\r\n                 */\r\n                _base.remove = function (instance) {\r\n                    var index = _inArray(instance, _loopingInstances);\r\n                    if (index > -1) {\r\n                        //remove from loopingInstances list\r\n                        _loopingInstancesIntervalCache.splice(index, 1);\r\n                        _loopingInstances.splice(index, 1);\r\n\r\n                        //correct update loop behavior\r\n                        if (_loopingInstances[_strLength] === 0 && _loopIsActive) {\r\n                            _loopIsActive = false;\r\n                            globals.autoUpdateLoop = _loopIsActive;\r\n                            if (_loopID !== undefined) {\r\n                                COMPATIBILITY.cAF()(_loopID);\r\n                                _loopID = -1;\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n\r\n            /**\r\n             * A object which manages the scrollbars visibility of the target element.\r\n             * @param pluginTargetElement The element from which the scrollbars shall be hidden.\r\n             * @param options The custom options.\r\n             * @param extensions The custom extensions.\r\n             * @param globals\r\n             * @param autoUpdateLoop\r\n             * @returns {*}\r\n             * @constructor\r\n             */\r\n            function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {\r\n                //shortcuts\r\n                var type = COMPATIBILITY.type;\r\n                var inArray = FRAMEWORK.inArray;\r\n                var each = FRAMEWORK.each;\r\n\r\n                //make correct instanceof\r\n                var _base = new _plugin();\r\n                var _frameworkProto = FRAMEWORK[LEXICON.p];\r\n\r\n                //if passed element is no HTML element: skip and return\r\n                if (!isHTMLElement(pluginTargetElement))\r\n                    return;\r\n\r\n                //if passed element is already initialized: set passed options if there are any and return its instance\r\n                if (INSTANCES(pluginTargetElement)) {\r\n                    var inst = INSTANCES(pluginTargetElement);\r\n                    inst.options(options);\r\n                    return inst;\r\n                }\r\n\r\n                //globals:\r\n                var _nativeScrollbarIsOverlaid;\r\n                var _overlayScrollbarDummySize;\r\n                var _rtlScrollBehavior;\r\n                var _autoUpdateRecommended;\r\n                var _msieVersion;\r\n                var _nativeScrollbarStyling;\r\n                var _cssCalc;\r\n                var _nativeScrollbarSize;\r\n                var _supportTransition;\r\n                var _supportTransform;\r\n                var _supportPassiveEvents;\r\n                var _supportResizeObserver;\r\n                var _supportMutationObserver;\r\n                var _restrictedMeasuring;\r\n\r\n                //general readonly:\r\n                var _initialized;\r\n                var _destroyed;\r\n                var _isTextarea;\r\n                var _isBody;\r\n                var _documentMixed;\r\n                var _domExists;\r\n\r\n                //general:\r\n                var _isBorderBox;\r\n                var _sizeAutoObserverAdded;\r\n                var _paddingX;\r\n                var _paddingY;\r\n                var _borderX;\r\n                var _borderY;\r\n                var _marginX;\r\n                var _marginY;\r\n                var _isRTL;\r\n                var _sleeping;\r\n                var _contentBorderSize = {};\r\n                var _scrollHorizontalInfo = {};\r\n                var _scrollVerticalInfo = {};\r\n                var _viewportSize = {};\r\n                var _nativeScrollbarMinSize = {};\r\n\r\n                //naming:\t\r\n                var _strMinusHidden = '-hidden';\r\n                var _strMarginMinus = 'margin-';\r\n                var _strPaddingMinus = 'padding-';\r\n                var _strBorderMinus = 'border-';\r\n                var _strTop = 'top';\r\n                var _strRight = 'right';\r\n                var _strBottom = 'bottom';\r\n                var _strLeft = 'left';\r\n                var _strMinMinus = 'min-';\r\n                var _strMaxMinus = 'max-';\r\n                var _strWidth = 'width';\r\n                var _strHeight = 'height';\r\n                var _strFloat = 'float';\r\n                var _strEmpty = '';\r\n                var _strAuto = 'auto';\r\n                var _strSync = 'sync';\r\n                var _strScroll = 'scroll';\r\n                var _strHundredPercent = '100%';\r\n                var _strX = 'x';\r\n                var _strY = 'y';\r\n                var _strDot = '.';\r\n                var _strSpace = ' ';\r\n                var _strScrollbar = 'scrollbar';\r\n                var _strMinusHorizontal = '-horizontal';\r\n                var _strMinusVertical = '-vertical';\r\n                var _strScrollLeft = _strScroll + 'Left';\r\n                var _strScrollTop = _strScroll + 'Top';\r\n                var _strMouseTouchDownEvent = 'mousedown touchstart';\r\n                var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';\r\n                var _strMouseTouchMoveEvent = 'mousemove touchmove';\r\n                var _strMouseEnter = 'mouseenter';\r\n                var _strMouseLeave = 'mouseleave';\r\n                var _strKeyDownEvent = 'keydown';\r\n                var _strKeyUpEvent = 'keyup';\r\n                var _strSelectStartEvent = 'selectstart';\r\n                var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';\r\n                var _strResizeObserverProperty = '__overlayScrollbarsRO__';\r\n\r\n                //class names:\t\r\n                var _cassNamesPrefix = 'os-';\r\n                var _classNameHTMLElement = _cassNamesPrefix + 'html';\r\n                var _classNameHostElement = _cassNamesPrefix + 'host';\r\n                var _classNameHostElementForeign = _classNameHostElement + '-foreign';\r\n                var _classNameHostTextareaElement = _classNameHostElement + '-textarea';\r\n                var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;\r\n                var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;\r\n                var _classNameHostTransition = _classNameHostElement + '-transition';\r\n                var _classNameHostRTL = _classNameHostElement + '-rtl';\r\n                var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';\r\n                var _classNameHostScrolling = _classNameHostElement + '-scrolling';\r\n                var _classNameHostOverflow = _classNameHostElement + '-overflow';\r\n                var _classNameHostOverflow = _classNameHostElement + '-overflow';\r\n                var _classNameHostOverflowX = _classNameHostOverflow + '-x';\r\n                var _classNameHostOverflowY = _classNameHostOverflow + '-y';\r\n                var _classNameTextareaElement = _cassNamesPrefix + 'textarea';\r\n                var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';\r\n                var _classNamePaddingElement = _cassNamesPrefix + 'padding';\r\n                var _classNameViewportElement = _cassNamesPrefix + 'viewport';\r\n                var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';\r\n                var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';\r\n                var _classNameContentElement = _cassNamesPrefix + 'content';\r\n                var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';\r\n                var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';\r\n                var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';\r\n                var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';\r\n                var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';\r\n                var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';\r\n                var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';\r\n                var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;\r\n                var _classNameScrollbarTrack = _classNameScrollbar + '-track';\r\n                var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';\r\n                var _classNameScrollbarHandle = _classNameScrollbar + '-handle';\r\n                var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';\r\n                var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';\r\n                var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;\r\n                var _classNameScrollbarCorner = _classNameScrollbar + '-corner';\r\n                var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';\r\n                var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';\r\n                var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;\r\n                var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;\r\n                var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;\r\n                var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;\r\n                var _classNameDragging = _cassNamesPrefix + 'dragging';\r\n                var _classNameThemeNone = _cassNamesPrefix + 'theme-none';\r\n                var _classNamesDynamicDestroy = [\r\n                    _classNameViewportNativeScrollbarsInvisible,\r\n                    _classNameViewportNativeScrollbarsOverlaid,\r\n                    _classNameScrollbarTrackOff,\r\n                    _classNameScrollbarHandleOff,\r\n                    _classNameScrollbarUnusable,\r\n                    _classNameScrollbarAutoHidden,\r\n                    _classNameScrollbarCornerResize,\r\n                    _classNameScrollbarCornerResizeB,\r\n                    _classNameScrollbarCornerResizeH,\r\n                    _classNameScrollbarCornerResizeV,\r\n                    _classNameDragging].join(_strSpace);\r\n\r\n                //callbacks:\t\r\n                var _callbacksInitQeueue = [];\r\n\r\n                //attrs viewport shall inherit from target\t\r\n                var _viewportAttrsFromTarget = [LEXICON.ti];\r\n\r\n                //options:\t\r\n                var _defaultOptions;\r\n                var _currentOptions;\r\n                var _currentPreparedOptions;\r\n\r\n                //extensions:\t\r\n                var _extensions = {};\r\n                var _extensionsPrivateMethods = 'added removed on contract';\r\n\r\n                //update\t\r\n                var _lastUpdateTime;\r\n                var _swallowedUpdateHints = {};\r\n                var _swallowedUpdateTimeout;\r\n                var _swallowUpdateLag = 42;\r\n                var _updateOnLoadEventName = 'load';\r\n                var _updateOnLoadElms = [];\r\n\r\n                //DOM elements:\t\r\n                var _windowElement;\r\n                var _documentElement;\r\n                var _htmlElement;\r\n                var _bodyElement;\r\n                var _targetElement;                     //the target element of this OverlayScrollbars object\t\r\n                var _hostElement;                       //the host element of this OverlayScrollbars object -> may be the same as targetElement\t\r\n                var _sizeAutoObserverElement;           //observes size auto changes\t\r\n                var _sizeObserverElement;               //observes size and padding changes\t\r\n                var _paddingElement;                    //manages the padding\t\r\n                var _viewportElement;                   //is the viewport of our scrollbar model\t\r\n                var _contentElement;                    //the element which holds the content\t\r\n                var _contentArrangeElement;             //is needed for correct sizing of the content element (only if native scrollbars are overlays)\t\r\n                var _contentGlueElement;                //has always the size of the content element\t\r\n                var _textareaCoverElement;              //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling\t\r\n                var _scrollbarCornerElement;\r\n                var _scrollbarHorizontalElement;\r\n                var _scrollbarHorizontalTrackElement;\r\n                var _scrollbarHorizontalHandleElement;\r\n                var _scrollbarVerticalElement;\r\n                var _scrollbarVerticalTrackElement;\r\n                var _scrollbarVerticalHandleElement;\r\n                var _windowElementNative;\r\n                var _documentElementNative;\r\n                var _targetElementNative;\r\n                var _hostElementNative;\r\n                var _sizeAutoObserverElementNative;\r\n                var _sizeObserverElementNative;\r\n                var _paddingElementNative;\r\n                var _viewportElementNative;\r\n                var _contentElementNative;\r\n\r\n                //Cache:\t\r\n                var _hostSizeCache;\r\n                var _contentScrollSizeCache;\r\n                var _arrangeContentSizeCache;\r\n                var _hasOverflowCache;\r\n                var _hideOverflowCache;\r\n                var _widthAutoCache;\r\n                var _heightAutoCache;\r\n                var _cssBoxSizingCache;\r\n                var _cssPaddingCache;\r\n                var _cssBorderCache;\r\n                var _cssMarginCache;\r\n                var _cssDirectionCache;\r\n                var _cssDirectionDetectedCache;\r\n                var _paddingAbsoluteCache;\r\n                var _clipAlwaysCache;\r\n                var _contentGlueSizeCache;\r\n                var _overflowBehaviorCache;\r\n                var _overflowAmountCache;\r\n                var _ignoreOverlayScrollbarHidingCache;\r\n                var _autoUpdateCache;\r\n                var _sizeAutoCapableCache;\r\n                var _contentElementScrollSizeChangeDetectedCache;\r\n                var _hostElementSizeChangeDetectedCache;\r\n                var _scrollbarsVisibilityCache;\r\n                var _scrollbarsAutoHideCache;\r\n                var _scrollbarsClickScrollingCache;\r\n                var _scrollbarsDragScrollingCache;\r\n                var _resizeCache;\r\n                var _normalizeRTLCache;\r\n                var _classNameCache;\r\n                var _oldClassName;\r\n                var _textareaAutoWrappingCache;\r\n                var _textareaInfoCache;\r\n                var _textareaSizeCache;\r\n                var _textareaDynHeightCache;\r\n                var _textareaDynWidthCache;\r\n                var _bodyMinSizeCache;\r\n                var _updateAutoCache = {};\r\n\r\n                //MutationObserver:\t\r\n                var _mutationObserverHost;\r\n                var _mutationObserverContent;\r\n                var _mutationObserverHostCallback;\r\n                var _mutationObserverContentCallback;\r\n                var _mutationObserversConnected;\r\n                var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];\r\n                var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget);\r\n\r\n                //events:\t\r\n                var _destroyEvents = [];\r\n\r\n                //textarea:\t\r\n                var _textareaHasFocus;\r\n\r\n                //scrollbars:\t\r\n                var _scrollbarsAutoHideTimeoutId;\r\n                var _scrollbarsAutoHideMoveTimeoutId;\r\n                var _scrollbarsAutoHideDelay;\r\n                var _scrollbarsAutoHideNever;\r\n                var _scrollbarsAutoHideScroll;\r\n                var _scrollbarsAutoHideMove;\r\n                var _scrollbarsAutoHideLeave;\r\n                var _scrollbarsHandleHovered;\r\n                var _scrollbarsHandlesDefineScrollPos;\r\n\r\n                //resize\t\r\n                var _resizeNone;\r\n                var _resizeBoth;\r\n                var _resizeHorizontal;\r\n                var _resizeVertical;\r\n\r\n\r\n                //==== Event Listener ====//\t\r\n\r\n                /**\t\r\n                 * Adds or removes a event listener from the given element. \t\r\n                 * @param element The element to which the event listener shall be applied or removed.\t\r\n                 * @param eventNames The name(s) of the events.\t\r\n                 * @param listener The method which shall be called.\t\r\n                 * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.\t\r\n                 * @param passiveOrOptions The options for the event.\r\n                 */\r\n                function setupResponsiveEventListener(element, eventNames, listener, remove, passiveOrOptions) {\r\n                    var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);\r\n                    var method = remove ? 'removeEventListener' : 'addEventListener';\r\n                    var onOff = remove ? 'off' : 'on';\r\n                    var events = collected ? false : eventNames.split(_strSpace)\r\n                    var i = 0;\r\n\r\n                    var passiveOrOptionsIsObj = FRAMEWORK.isPlainObject(passiveOrOptions);\r\n                    var passive = (_supportPassiveEvents && (passiveOrOptionsIsObj ? (passiveOrOptions._passive) : passiveOrOptions)) || false;\r\n                    var capture = passiveOrOptionsIsObj && (passiveOrOptions._capture || false);\r\n                    var nativeParam = _supportPassiveEvents ? {\r\n                        passive: passive,\r\n                        capture: capture,\r\n                    } : capture;\r\n\r\n                    if (collected) {\r\n                        for (; i < eventNames[LEXICON.l]; i++)\r\n                            setupResponsiveEventListener(element, eventNames[i], listener[i], remove, passiveOrOptions);\r\n                    }\r\n                    else {\r\n                        for (; i < events[LEXICON.l]; i++) {\r\n                            if(_supportPassiveEvents) {\r\n                                element[0][method](events[i], listener, nativeParam);\r\n                            }\r\n                            else {\r\n                                element[onOff](events[i], listener);\r\n                            }     \r\n                        }\r\n                    }\r\n                }\r\n\r\n\r\n                function addDestroyEventListener(element, eventNames, listener, passive) {\r\n                    setupResponsiveEventListener(element, eventNames, listener, false, passive);\r\n                    _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));\r\n                }\r\n\r\n                //==== Resize Observer ====//\r\n\r\n                /**\r\n                 * Adds or removes a resize observer from the given element.\r\n                 * @param targetElement The element to which the resize observer shall be added or removed.\r\n                 * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.\r\n                 */\r\n                function setupResizeObserver(targetElement, onElementResizedCallback) {\r\n                    if (targetElement) {\r\n                        var resizeObserver = COMPATIBILITY.rO();\r\n                        var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';\r\n                        var strChildNodes = 'childNodes';\r\n                        var constScroll = 3333333;\r\n                        var callback = function () {\r\n                            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);\r\n                            onElementResizedCallback();\r\n                        };\r\n                        //add resize observer:\r\n                        if (onElementResizedCallback) {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];\r\n                                var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);\r\n                                observer.observe(element);\r\n                            }\r\n                            else {\r\n                                if (_msieVersion > 9 || !_autoUpdateRecommended) {\r\n                                    targetElement.prepend(\r\n                                        generateDiv(_classNameResizeObserverElement,\r\n                                            generateDiv({ c: _classNameResizeObserverItemElement, dir: 'ltr' },\r\n                                                generateDiv(_classNameResizeObserverItemElement,\r\n                                                    generateDiv(_classNameResizeObserverItemFinalElement)\r\n                                                ) +\r\n                                                generateDiv(_classNameResizeObserverItemElement,\r\n                                                    generateDiv({ c: _classNameResizeObserverItemFinalElement, style: 'width: 200%; height: 200%' })\r\n                                                )\r\n                                            )\r\n                                        )\r\n                                    );\r\n\r\n                                    var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];\r\n                                    var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);\r\n                                    var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);\r\n                                    var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);\r\n                                    var widthCache = observerElement[LEXICON.oW];\r\n                                    var heightCache = observerElement[LEXICON.oH];\r\n                                    var isDirty;\r\n                                    var rAFId;\r\n                                    var currWidth;\r\n                                    var currHeight;\r\n                                    var factor = 2;\r\n                                    var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!\r\n                                    var reset = function () {\r\n                                        /*\r\n                                         var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;\r\n                                         var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;\r\n                                         var expandChildCSS = {};\r\n                                         expandChildCSS[_strWidth] = sizeResetWidth;\r\n                                         expandChildCSS[_strHeight] = sizeResetHeight;\r\n                                         expandElementChild.css(expandChildCSS);\r\n\r\n\r\n                                         expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);\r\n                                         shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);\r\n                                         */\r\n                                        expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);\r\n                                        shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);\r\n                                    };\r\n                                    var onResized = function () {\r\n                                        rAFId = 0;\r\n                                        if (!isDirty)\r\n                                            return;\r\n\r\n                                        widthCache = currWidth;\r\n                                        heightCache = currHeight;\r\n                                        callback();\r\n                                    };\r\n                                    var onScroll = function (event) {\r\n                                        currWidth = observerElement[LEXICON.oW];\r\n                                        currHeight = observerElement[LEXICON.oH];\r\n                                        isDirty = currWidth != widthCache || currHeight != heightCache;\r\n\r\n                                        if (event && isDirty && !rAFId) {\r\n                                            COMPATIBILITY.cAF()(rAFId);\r\n                                            rAFId = COMPATIBILITY.rAF()(onResized);\r\n                                        }\r\n                                        else if (!event)\r\n                                            onResized();\r\n\r\n                                        reset();\r\n                                        if (event) {\r\n                                            COMPATIBILITY.prvD(event);\r\n                                            COMPATIBILITY.stpP(event);\r\n                                        }\r\n                                        return false;\r\n                                    };\r\n                                    var expandChildCSS = {};\r\n                                    var observerElementCSS = {};\r\n\r\n                                    setTopRightBottomLeft(observerElementCSS, _strEmpty, [\r\n                                        -((nativeScrollbarSize.y + 1) * factor),\r\n                                        nativeScrollbarSize.x * -factor,\r\n                                        nativeScrollbarSize.y * -factor,\r\n                                        -((nativeScrollbarSize.x + 1) * factor)\r\n                                    ]);\r\n\r\n                                    FRAMEWORK(observerElement).css(observerElementCSS);\r\n                                    expandElement.on(_strScroll, onScroll);\r\n                                    shrinkElement.on(_strScroll, onScroll);\r\n                                    targetElement.on(strAnimationStartEvent, function () {\r\n                                        onScroll(false);\r\n                                    });\r\n                                    //lets assume that the divs will never be that large and a constant value is enough\r\n                                    expandChildCSS[_strWidth] = constScroll;\r\n                                    expandChildCSS[_strHeight] = constScroll;\r\n                                    expandElementChild.css(expandChildCSS);\r\n\r\n                                    reset();\r\n                                }\r\n                                else {\r\n                                    var attachEvent = _documentElementNative.attachEvent;\r\n                                    var isIE = _msieVersion !== undefined;\r\n                                    if (attachEvent) {\r\n                                        targetElement.prepend(generateDiv(_classNameResizeObserverElement));\r\n                                        findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);\r\n                                    }\r\n                                    else {\r\n                                        var obj = _documentElementNative.createElement(TYPES.o);\r\n                                        obj.setAttribute(LEXICON.ti, '-1');\r\n                                        obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);\r\n                                        obj.onload = function () {\r\n                                            var wnd = this.contentDocument.defaultView;\r\n                                            wnd.addEventListener('resize', callback);\r\n                                            wnd.document.documentElement.style.display = 'none';\r\n                                        };\r\n                                        obj.type = 'text/html';\r\n                                        if (isIE)\r\n                                            targetElement.prepend(obj);\r\n                                        obj.data = 'about:blank';\r\n                                        if (!isIE)\r\n                                            targetElement.prepend(obj);\r\n                                        targetElement.on(strAnimationStartEvent, callback);\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (targetElement[0] === _sizeObserverElementNative) {\r\n                                var directionChanged = function () {\r\n                                    var dir = _hostElement.css('direction');\r\n                                    var css = {};\r\n                                    var scrollLeftValue = 0;\r\n                                    var result = false;\r\n                                    if (dir !== _cssDirectionDetectedCache) {\r\n                                        if (dir === 'ltr') {\r\n                                            css[_strLeft] = 0;\r\n                                            css[_strRight] = _strAuto;\r\n                                            scrollLeftValue = constScroll;\r\n                                        }\r\n                                        else {\r\n                                            css[_strLeft] = _strAuto;\r\n                                            css[_strRight] = 0;\r\n                                            scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;\r\n                                        }\r\n                                        //execution order is important for IE!!!\r\n                                        _sizeObserverElement.children().eq(0).css(css);\r\n                                        _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);\r\n                                        _cssDirectionDetectedCache = dir;\r\n                                        result = true;\r\n                                    }\r\n                                    return result;\r\n                                };\r\n                                directionChanged();\r\n                                addDestroyEventListener(targetElement, _strScroll, function (event) {\r\n                                    if (directionChanged())\r\n                                        update();\r\n                                    COMPATIBILITY.prvD(event);\r\n                                    COMPATIBILITY.stpP(event);\r\n                                    return false;\r\n                                });\r\n                            }\r\n                        }\r\n                        //remove resize observer:\r\n                        else {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.contents()[0];\r\n                                var resizeObserverObj = element[_strResizeObserverProperty];\r\n                                if (resizeObserverObj) {\r\n                                    resizeObserverObj.disconnect();\r\n                                    delete element[_strResizeObserverProperty];\r\n                                }\r\n                            }\r\n                            else {\r\n                                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Freezes or unfreezes the given resize observer.\r\n                 * @param targetElement The element to which the target resize observer is applied.\r\n                 * @param freeze True if the resize observer shall be frozen, false otherwise.\r\n                 \r\n                function freezeResizeObserver(targetElement, freeze) {\r\n                    if (targetElement !== undefined) {\r\n                        if(freeze) {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.contents()[0];\r\n                                element[_strResizeObserverProperty].unobserve(element);\r\n                            }\r\n                            else {\r\n                                targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);\r\n                                var w = targetElement.css(_strWidth);\r\n                                var h = targetElement.css(_strHeight);\r\n                                var css = {};\r\n                                css[_strWidth] = w;\r\n                                css[_strHeight] = h;\r\n                                targetElement.css(css);\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (_supportResizeObserver) {\r\n                                var element = targetElement.contents()[0];\r\n                                element[_strResizeObserverProperty].observe(element);\r\n                            }\r\n                            else {\r\n                                var css = { };\r\n                                css[_strHeight] = _strEmpty;\r\n                                css[_strWidth] = _strEmpty;\r\n                                targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                */\r\n\r\n\r\n                //==== Mutation Observers ====//\r\n\r\n                /**\r\n                 * Creates MutationObservers for the host and content Element if they are supported.\r\n                 */\r\n                function createMutationObservers() {\r\n                    if (_supportMutationObserver) {\r\n                        var mutationObserverContentLag = 11;\r\n                        var mutationObserver = COMPATIBILITY.mO();\r\n                        var contentLastUpdate = COMPATIBILITY.now();\r\n                        var mutationTarget;\r\n                        var mutationAttrName;\r\n                        var mutationIsClass;\r\n                        var oldMutationVal;\r\n                        var newClassVal;\r\n                        var hostClassNameRegex;\r\n                        var contentTimeout;\r\n                        var now;\r\n                        var sizeAuto;\r\n                        var action;\r\n\r\n                        _mutationObserverHostCallback = function (mutations) {\r\n\r\n                            var doUpdate = false;\r\n                            var doUpdateForce = false;\r\n                            var mutation;\r\n                            var mutatedAttrs = [];\r\n\r\n                            if (_initialized && !_sleeping) {\r\n                                each(mutations, function () {\r\n                                    mutation = this;\r\n                                    mutationTarget = mutation.target;\r\n                                    mutationAttrName = mutation.attributeName;\r\n                                    mutationIsClass = mutationAttrName === LEXICON.c;\r\n                                    oldMutationVal = mutation.oldValue;\r\n                                    newClassVal = mutationTarget.className;\r\n\r\n                                    if (_domExists && mutationIsClass && !doUpdateForce) {\r\n                                        // if old class value contains _classNameHostElementForeign and new class value doesn't\r\n                                        if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {\r\n                                            hostClassNameRegex = createHostClassNameRegExp(true);\r\n                                            _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {\r\n                                                return name.match(hostClassNameRegex);\r\n                                            })).join(_strSpace);\r\n                                            doUpdate = doUpdateForce = true;\r\n                                        }\r\n                                    }\r\n\r\n                                    if (!doUpdate) {\r\n                                        doUpdate = mutationIsClass\r\n                                            ? hostClassNamesChanged(oldMutationVal, newClassVal)\r\n                                            : mutationAttrName === LEXICON.s\r\n                                                ? oldMutationVal !== mutationTarget[LEXICON.s].cssText\r\n                                                : true;\r\n                                    }\r\n\r\n                                    mutatedAttrs.push(mutationAttrName);\r\n                                });\r\n\r\n                                updateViewportAttrsFromTarget(mutatedAttrs);\r\n\r\n                                if (doUpdate)\r\n                                    _base.update(doUpdateForce || _strAuto);\r\n                            }\r\n                            return doUpdate;\r\n                        };\r\n                        _mutationObserverContentCallback = function (mutations) {\r\n                            var doUpdate = false;\r\n                            var mutation;\r\n\r\n                            if (_initialized && !_sleeping) {\r\n                                each(mutations, function () {\r\n                                    mutation = this;\r\n                                    doUpdate = isUnknownMutation(mutation);\r\n                                    return !doUpdate;\r\n                                });\r\n\r\n                                if (doUpdate) {\r\n                                    now = COMPATIBILITY.now();\r\n                                    sizeAuto = (_heightAutoCache || _widthAutoCache);\r\n                                    action = function () {\r\n                                        if (!_destroyed) {\r\n                                            contentLastUpdate = now;\r\n\r\n                                            //if cols, rows or wrap attr was changed\r\n                                            if (_isTextarea)\r\n                                                textareaUpdate();\r\n\r\n                                            if (sizeAuto)\r\n                                                update();\r\n                                            else\r\n                                                _base.update(_strAuto);\r\n                                        }\r\n                                    };\r\n                                    clearTimeout(contentTimeout);\r\n                                    if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto)\r\n                                        action();\r\n                                    else\r\n                                        contentTimeout = setTimeout(action, mutationObserverContentLag);\r\n                                }\r\n                            }\r\n                            return doUpdate;\r\n                        }\r\n\r\n                        _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);\r\n                        _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Connects the MutationObservers if they are supported.\r\n                 */\r\n                function connectMutationObservers() {\r\n                    if (_supportMutationObserver && !_mutationObserversConnected) {\r\n                        _mutationObserverHost.observe(_hostElementNative, {\r\n                            attributes: true,\r\n                            attributeOldValue: true,\r\n                            attributeFilter: _mutationObserverAttrsHost\r\n                        });\r\n\r\n                        _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {\r\n                            attributes: true,\r\n                            attributeOldValue: true,\r\n                            subtree: !_isTextarea,\r\n                            childList: !_isTextarea,\r\n                            characterData: !_isTextarea,\r\n                            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost\r\n                        });\r\n\r\n                        _mutationObserversConnected = true;\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Disconnects the MutationObservers if they are supported.\r\n                 */\r\n                function disconnectMutationObservers() {\r\n                    if (_supportMutationObserver && _mutationObserversConnected) {\r\n                        _mutationObserverHost.disconnect();\r\n                        _mutationObserverContent.disconnect();\r\n\r\n                        _mutationObserversConnected = false;\r\n                    }\r\n                }\r\n\r\n\r\n                //==== Events of elements ====//\r\n\r\n                /**\r\n                 * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!\r\n                 * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.\r\n                 * If there are any size changes, the update method gets called.\r\n                 */\r\n                function hostOnResized() {\r\n                    if (!_sleeping) {\r\n                        var changed;\r\n                        var hostSize = {\r\n                            w: _sizeObserverElementNative[LEXICON.sW],\r\n                            h: _sizeObserverElementNative[LEXICON.sH]\r\n                        };\r\n\r\n                        changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);\r\n                        _hostElementSizeChangeDetectedCache = hostSize;\r\n                        if (changed)\r\n                            update({ _hostSizeChanged: true });\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * The mouse enter event of the host element. This event is only needed for the autoHide feature.\r\n                 */\r\n                function hostOnMouseEnter() {\r\n                    if (_scrollbarsAutoHideLeave)\r\n                        refreshScrollbarsAutoHide(true);\r\n                }\r\n\r\n                /**\r\n                 * The mouse leave event of the host element. This event is only needed for the autoHide feature.\r\n                 */\r\n                function hostOnMouseLeave() {\r\n                    if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging))\r\n                        refreshScrollbarsAutoHide(false);\r\n                }\r\n\r\n                /**\r\n                 * The mouse move event of the host element. This event is only needed for the autoHide \"move\" feature.\r\n                 */\r\n                function hostOnMouseMove() {\r\n                    if (_scrollbarsAutoHideMove) {\r\n                        refreshScrollbarsAutoHide(true);\r\n                        clearTimeout(_scrollbarsAutoHideMoveTimeoutId);\r\n                        _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {\r\n                            if (_scrollbarsAutoHideMove && !_destroyed)\r\n                                refreshScrollbarsAutoHide(false);\r\n                        }, 100);\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.\r\n                 * @param event The select start event.\r\n                 */\r\n                function documentOnSelectStart(event) {\r\n                    COMPATIBILITY.prvD(event);\r\n                    return false;\r\n                }\r\n\r\n                /**\t\r\n                 * A callback which will be called after a element has loaded.\t\r\n                 */\r\n                function updateOnLoadCallback(event) {\r\n                    var elm = FRAMEWORK(event.target);\r\n\r\n                    eachUpdateOnLoad(function (i, updateOnLoadSelector) {\r\n                        if (elm.is(updateOnLoadSelector)) {\r\n                            update({ _contentSizeChanged: true });\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /**\r\n                * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)\r\n                * @param destroy Indicates whether the events shall be added or removed.\r\n                */\r\n                function setupHostMouseTouchEvents(destroy) {\r\n                    if (!destroy)\r\n                        setupHostMouseTouchEvents(true);\r\n\r\n                    setupResponsiveEventListener(_hostElement,\r\n                        _strMouseTouchMoveEvent.split(_strSpace)[0],\r\n                        hostOnMouseMove,\r\n                        (!_scrollbarsAutoHideMove || destroy), true);\r\n                    setupResponsiveEventListener(_hostElement,\r\n                        [_strMouseEnter, _strMouseLeave],\r\n                        [hostOnMouseEnter, hostOnMouseLeave],\r\n                        (!_scrollbarsAutoHideLeave || destroy), true);\r\n\r\n                    //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible\r\n                    if (!_initialized && !destroy)\r\n                        _hostElement.one('mouseover', hostOnMouseEnter);\r\n                }\r\n\r\n\r\n                //==== Update Detection ====//\r\n\r\n                /**\r\n                 * Measures the min width and min height of the body element and refreshes the related cache.\r\n                 * @returns {boolean} True if the min width or min height has changed, false otherwise.\r\n                 */\r\n                function bodyMinSizeChanged() {\r\n                    var bodyMinSize = {};\r\n                    if (_isBody && _contentArrangeElement) {\r\n                        bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));\r\n                        bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));\r\n                        bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);\r\n                        bodyMinSize.f = true; //flag for \"measured at least once\"\r\n                    }\r\n                    _bodyMinSizeCache = bodyMinSize;\r\n                    return !!bodyMinSize.c;\r\n                }\r\n\r\n                /**\r\n                 * Returns true if the class names really changed (new class without plugin host prefix)\r\n                 * @param oldClassNames The old ClassName string or array.\r\n                 * @param newClassNames The new ClassName string or array.\r\n                 * @returns {boolean} True if the class names has really changed, false otherwise.\r\n                 */\r\n                function hostClassNamesChanged(oldClassNames, newClassNames) {\r\n                    var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];\r\n                    var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];\r\n                    var diff = getArrayDifferences(oldClasses, currClasses);\r\n\r\n                    // remove none theme from diff list to prevent update\r\n                    var idx = inArray(_classNameThemeNone, diff);\r\n                    var i;\r\n                    var regex;\r\n\r\n                    if (idx > -1)\r\n                        diff.splice(idx, 1);\r\n\r\n                    if (diff[LEXICON.l] > 0) {\r\n                        regex = createHostClassNameRegExp(true, true);\r\n                        for (i = 0; i < diff.length; i++) {\r\n                            if (!diff[i].match(regex)) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n                /**\r\n                 * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.\r\n                 * @param mutation The mutation which shall be checked.\r\n                 * @returns {boolean} True if the mutation is from a unknown element, false otherwise.\r\n                 */\r\n                function isUnknownMutation(mutation) {\r\n                    var attributeName = mutation.attributeName;\r\n                    var mutationTarget = mutation.target;\r\n                    var mutationType = mutation.type;\r\n                    var strClosest = 'closest';\r\n\r\n                    if (mutationTarget === _contentElementNative)\r\n                        return attributeName === null;\r\n                    if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {\r\n                        //ignore className changes by the plugin\t\r\n                        if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement))\r\n                            return hostClassNamesChanged(mutation.oldValue, mutationTarget.className);\r\n\r\n                        //only do it of browser support it natively\t\r\n                        if (typeof mutationTarget[strClosest] != TYPES.f)\r\n                            return true;\r\n                        if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null ||\r\n                            mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null ||\r\n                            mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null)\r\n                            return false;\r\n                    }\r\n                    return true;\r\n                }\r\n\r\n                /**\r\n                 * Returns true if the content size was changed since the last time this method was called.\r\n                 * @returns {boolean} True if the content size was changed, false otherwise.\r\n                 */\r\n                function updateAutoContentSizeChanged() {\r\n                    if (_sleeping)\r\n                        return false;\r\n\r\n                    var contentMeasureElement = getContentMeasureElement();\r\n                    var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;\r\n                    var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;\r\n                    var css = {};\r\n                    var float;\r\n                    var bodyMinSizeC;\r\n                    var changed;\r\n                    var contentElementScrollSize;\r\n\r\n                    if (setCSS) {\r\n                        float = _contentElement.css(_strFloat);\r\n                        css[_strFloat] = _isRTL ? _strRight : _strLeft;\r\n                        css[_strWidth] = _strAuto;\r\n                        _contentElement.css(css);\r\n                    }\r\n                    contentElementScrollSize = {\r\n                        w: contentMeasureElement[LEXICON.sW] + textareaValueLength,\r\n                        h: contentMeasureElement[LEXICON.sH] + textareaValueLength\r\n                    };\r\n                    if (setCSS) {\r\n                        css[_strFloat] = float;\r\n                        css[_strWidth] = _strHundredPercent;\r\n                        _contentElement.css(css);\r\n                    }\r\n\r\n                    bodyMinSizeC = bodyMinSizeChanged();\r\n                    changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);\r\n\r\n                    _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;\r\n\r\n                    return changed || bodyMinSizeC;\r\n                }\r\n\r\n                /**\r\n                 * Returns true when a attribute which the MutationObserver would observe has changed.  \r\n                 * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.\r\n                 */\r\n                function meaningfulAttrsChanged() {\r\n                    if (_sleeping || _mutationObserversConnected)\r\n                        return;\r\n\r\n                    var elem;\r\n                    var curr;\r\n                    var cache;\r\n                    var changedAttrs = [];\r\n                    var checks = [\r\n                        {\r\n                            _elem: _hostElement,\r\n                            _attrs: _mutationObserverAttrsHost.concat(':visible')\r\n                        },\r\n                        {\r\n                            _elem: _isTextarea ? _targetElement : undefined,\r\n                            _attrs: _mutationObserverAttrsTextarea\r\n                        }\r\n                    ];\r\n\r\n                    each(checks, function (index, check) {\r\n                        elem = check._elem;\r\n                        if (elem) {\r\n                            each(check._attrs, function (index, attr) {\r\n                                curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);\r\n                                cache = _updateAutoCache[attr];\r\n\r\n                                if (checkCache(curr, cache)) {\r\n                                    changedAttrs.push(attr);\r\n                                }\r\n\r\n                                _updateAutoCache[attr] = curr;\r\n                            });\r\n                        }\r\n                    });\r\n\r\n                    updateViewportAttrsFromTarget(changedAttrs);\r\n\r\n                    return changedAttrs[LEXICON.l] > 0;\r\n                }\r\n\r\n                /**\r\n                 * Checks is a CSS Property of a child element is affecting the scroll size of the content.\r\n                 * @param propertyName The CSS property name.\r\n                 * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.\r\n                 */\r\n                function isSizeAffectingCSSProperty(propertyName) {\r\n                    if (!_initialized)\r\n                        return true;\r\n                    var flexGrow = 'flex-grow';\r\n                    var flexShrink = 'flex-shrink';\r\n                    var flexBasis = 'flex-basis';\r\n                    var affectingPropsX = [\r\n                        _strWidth,\r\n                        _strMinMinus + _strWidth,\r\n                        _strMaxMinus + _strWidth,\r\n                        _strMarginMinus + _strLeft,\r\n                        _strMarginMinus + _strRight,\r\n                        _strLeft,\r\n                        _strRight,\r\n                        'font-weight',\r\n                        'word-spacing',\r\n                        flexGrow,\r\n                        flexShrink,\r\n                        flexBasis\r\n                    ];\r\n                    var affectingPropsXContentBox = [\r\n                        _strPaddingMinus + _strLeft,\r\n                        _strPaddingMinus + _strRight,\r\n                        _strBorderMinus + _strLeft + _strWidth,\r\n                        _strBorderMinus + _strRight + _strWidth\r\n                    ];\r\n                    var affectingPropsY = [\r\n                        _strHeight,\r\n                        _strMinMinus + _strHeight,\r\n                        _strMaxMinus + _strHeight,\r\n                        _strMarginMinus + _strTop,\r\n                        _strMarginMinus + _strBottom,\r\n                        _strTop,\r\n                        _strBottom,\r\n                        'line-height',\r\n                        flexGrow,\r\n                        flexShrink,\r\n                        flexBasis\r\n                    ];\r\n                    var affectingPropsYContentBox = [\r\n                        _strPaddingMinus + _strTop,\r\n                        _strPaddingMinus + _strBottom,\r\n                        _strBorderMinus + _strTop + _strWidth,\r\n                        _strBorderMinus + _strBottom + _strWidth\r\n                    ];\r\n                    var _strS = 's';\r\n                    var _strVS = 'v-s';\r\n                    var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;\r\n                    var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;\r\n                    var sizeIsAffected = false;\r\n                    var checkPropertyName = function (arr, name) {\r\n                        for (var i = 0; i < arr[LEXICON.l]; i++) {\r\n                            if (arr[i] === name)\r\n                                return true;\r\n                        }\r\n                        return false;\r\n                    };\r\n\r\n                    if (checkY) {\r\n                        sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);\r\n                        if (!sizeIsAffected && !_isBorderBox)\r\n                            sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);\r\n                    }\r\n                    if (checkX && !sizeIsAffected) {\r\n                        sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);\r\n                        if (!sizeIsAffected && !_isBorderBox)\r\n                            sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);\r\n                    }\r\n                    return sizeIsAffected;\r\n                }\r\n\r\n\r\n                //==== Update ====//\r\n\r\n                /**\r\n                 * Sets the attribute values of the viewport element to the values from the target element.\r\n                 * The value of a attribute is only set if the attribute is whitelisted.\r\n                 * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.\r\n                 */\r\n                function updateViewportAttrsFromTarget(attrs) {\r\n                    attrs = attrs || _viewportAttrsFromTarget;\r\n                    each(attrs, function (index, attr) {\r\n                        if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {\r\n                            var targetAttr = _targetElement.attr(attr);\r\n                            if (type(targetAttr) == TYPES.s) {\r\n                                _viewportElement.attr(attr, targetAttr);\r\n                            }\r\n                            else {\r\n                                _viewportElement.removeAttr(attr);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n\r\n                /**\r\n                 * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.\r\n                 */\r\n                function textareaUpdate() {\r\n                    if (!_sleeping) {\r\n                        var wrapAttrOff = !_textareaAutoWrappingCache;\r\n                        var minWidth = _viewportSize.w;\r\n                        var minHeight = _viewportSize.h;\r\n                        var css = {};\r\n                        var doMeasure = _widthAutoCache || wrapAttrOff;\r\n                        var origWidth;\r\n                        var width;\r\n                        var origHeight;\r\n                        var height;\r\n\r\n                        //reset min size\r\n                        css[_strMinMinus + _strWidth] = _strEmpty;\r\n                        css[_strMinMinus + _strHeight] = _strEmpty;\r\n\r\n                        //set width auto\r\n                        css[_strWidth] = _strAuto;\r\n                        _targetElement.css(css);\r\n\r\n                        //measure width\r\n                        origWidth = _targetElementNative[LEXICON.oW];\r\n                        width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;\r\n                        /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/\r\n\r\n                        //set measured width\r\n                        css[_strWidth] = _widthAutoCache ? _strAuto /*width*/ : _strHundredPercent;\r\n                        css[_strMinMinus + _strWidth] = _strHundredPercent;\r\n\r\n                        //set height auto\r\n                        css[_strHeight] = _strAuto;\r\n                        _targetElement.css(css);\r\n\r\n                        //measure height\r\n                        origHeight = _targetElementNative[LEXICON.oH];\r\n                        height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1);\r\n\r\n                        //append correct size values\r\n                        css[_strWidth] = width;\r\n                        css[_strHeight] = height;\r\n                        _textareaCoverElement.css(css);\r\n\r\n                        //apply min width / min height to prevent textarea collapsing\r\n                        css[_strMinMinus + _strWidth] = minWidth /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/;\r\n                        css[_strMinMinus + _strHeight] = minHeight /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/;\r\n                        _targetElement.css(css);\r\n\r\n                        return {\r\n                            _originalWidth: origWidth,\r\n                            _originalHeight: origHeight,\r\n                            _dynamicWidth: width,\r\n                            _dynamicHeight: height\r\n                        };\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Updates the plugin and DOM to the current options.\r\n                 * This method should only be called if a update is 100% required.\r\n                 * @param updateHints A objects which contains hints for this update:\r\n                 * {\r\n                 *   _hostSizeChanged : boolean,\r\n                 *   _contentSizeChanged : boolean,\r\n                 *   _force : boolean,                             == preventSwallowing\r\n                 *   _changedOptions : { },                        == preventSwallowing && preventSleep\r\n                *  }\r\n                 */\r\n                function update(updateHints) {\r\n                    clearTimeout(_swallowedUpdateTimeout);\r\n                    updateHints = updateHints || {};\r\n                    _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;\r\n                    _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;\r\n                    _swallowedUpdateHints._force |= updateHints._force;\r\n\r\n                    var now = COMPATIBILITY.now();\r\n                    var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;\r\n                    var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;\r\n                    var force = !!_swallowedUpdateHints._force;\r\n                    var changedOptions = updateHints._changedOptions;\r\n                    var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && (now - _lastUpdateTime) < _swallowUpdateLag && (!_heightAutoCache && !_widthAutoCache);\r\n                    var displayIsHidden;\r\n\r\n                    if (swallow)\r\n                        _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag);\r\n\r\n                    //abort update due to:\r\n                    //destroyed\r\n                    //swallowing\r\n                    //sleeping\r\n                    //host is hidden or has false display\r\n                    if (_destroyed || swallow || (_sleeping && !changedOptions) || (_initialized && !force && (displayIsHidden = _hostElement.is(':hidden'))) || _hostElement.css('display') === 'inline')\r\n                        return;\r\n\r\n                    _lastUpdateTime = now;\r\n                    _swallowedUpdateHints = {};\r\n\r\n                    //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.\r\n                    if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {\r\n                        //native scrollbars are hidden, so change the values to zero\r\n                        _nativeScrollbarSize.x = 0;\r\n                        _nativeScrollbarSize.y = 0;\r\n                    }\r\n                    else {\r\n                        //refresh native scrollbar size (in case of zoom)\r\n                        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);\r\n                    }\r\n\r\n                    // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.\r\n                    // The calculation: [scrollbar size +3 *3]\r\n                    // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)\r\n                    // (*3 because (1)increase / (2)decrease -button and (3)resize handle)\r\n                    _nativeScrollbarMinSize = {\r\n                        x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,\r\n                        y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3\r\n                    };\r\n\r\n                    changedOptions = changedOptions || {};\r\n                    //freezeResizeObserver(_sizeObserverElement, true);\r\n                    //freezeResizeObserver(_sizeAutoObserverElement, true);\r\n\r\n                    var checkCacheAutoForce = function () {\r\n                        return checkCache.apply(this, [].slice.call(arguments).concat([force]));\r\n                    };\r\n\r\n                    //save current scroll offset\r\n                    var currScroll = {\r\n                        x: _viewportElement[_strScrollLeft](),\r\n                        y: _viewportElement[_strScrollTop]()\r\n                    };\r\n\r\n                    var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;\r\n                    var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea;\r\n\r\n                    //scrollbars visibility:\r\n                    var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;\r\n                    var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache);\r\n\r\n                    //scrollbars autoHide:\r\n                    var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;\r\n                    var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache);\r\n\r\n                    //scrollbars click scrolling\r\n                    var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;\r\n                    var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache);\r\n\r\n                    //scrollbars drag scrolling\r\n                    var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;\r\n                    var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache);\r\n\r\n                    //className\r\n                    var className = _currentPreparedOptions.className;\r\n                    var classNameChanged = checkCacheAutoForce(className, _classNameCache);\r\n\r\n                    //resize\r\n                    var resize = _currentPreparedOptions.resize;\r\n                    var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.\r\n\r\n                    //paddingAbsolute\r\n                    var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;\r\n                    var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache);\r\n\r\n                    //clipAlways\r\n                    var clipAlways = _currentPreparedOptions.clipAlways;\r\n                    var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache);\r\n\r\n                    //sizeAutoCapable\r\n                    var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.\r\n                    var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache);\r\n\r\n                    //showNativeScrollbars\r\n                    var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;\r\n                    var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache);\r\n\r\n                    //autoUpdate\r\n                    var autoUpdate = _currentPreparedOptions.autoUpdate;\r\n                    var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache);\r\n\r\n                    //overflowBehavior\r\n                    var overflowBehavior = _currentPreparedOptions.overflowBehavior;\r\n                    var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force);\r\n\r\n                    //dynWidth:\r\n                    var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;\r\n                    var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth);\r\n\r\n                    //dynHeight:\r\n                    var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;\r\n                    var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight);\r\n\r\n                    //scrollbars visibility\r\n                    _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';\r\n                    _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';\r\n                    _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';\r\n                    _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l';\r\n\r\n                    //scrollbars autoHideDelay\r\n                    _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay;\r\n\r\n                    //old className\r\n                    _oldClassName = _classNameCache;\r\n\r\n                    //resize\r\n                    _resizeNone = resize === 'n';\r\n                    _resizeBoth = resize === 'b';\r\n                    _resizeHorizontal = resize === 'h';\r\n                    _resizeVertical = resize === 'v';\r\n\r\n                    //normalizeRTL\r\n                    _normalizeRTLCache = _currentPreparedOptions.normalizeRTL;\r\n\r\n                    //ignore overlay scrollbar hiding\r\n                    ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y);\r\n\r\n                    //refresh options cache\r\n                    _scrollbarsVisibilityCache = scrollbarsVisibility;\r\n                    _scrollbarsAutoHideCache = scrollbarsAutoHide;\r\n                    _scrollbarsClickScrollingCache = scrollbarsClickScrolling;\r\n                    _scrollbarsDragScrollingCache = scrollbarsDragScrolling;\r\n                    _classNameCache = className;\r\n                    _resizeCache = resize;\r\n                    _paddingAbsoluteCache = paddingAbsolute;\r\n                    _clipAlwaysCache = clipAlways;\r\n                    _sizeAutoCapableCache = sizeAutoCapable;\r\n                    _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;\r\n                    _autoUpdateCache = autoUpdate;\r\n                    _overflowBehaviorCache = extendDeep({}, overflowBehavior);\r\n                    _textareaDynWidthCache = textareaDynWidth;\r\n                    _textareaDynHeightCache = textareaDynHeight;\r\n                    _hasOverflowCache = _hasOverflowCache || { x: false, y: false };\r\n\r\n                    //set correct class name to the host element\r\n                    if (classNameChanged) {\r\n                        removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);\r\n                        addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);\r\n                    }\r\n\r\n                    //set correct auto Update\r\n                    if (autoUpdateChanged) {\r\n                        if (autoUpdate === true || (autoUpdate === null && _autoUpdateRecommended)) {\r\n                            disconnectMutationObservers();\r\n                            autoUpdateLoop.add(_base);\r\n                        }\r\n                        else {\r\n                            autoUpdateLoop.remove(_base);\r\n                            connectMutationObservers();\r\n                        }\r\n                    }\r\n\r\n                    //activate or deactivate size auto capability\r\n                    if (sizeAutoCapableChanged) {\r\n                        if (sizeAutoCapable) {\r\n                            if (_contentGlueElement) {\r\n                                _contentGlueElement.show();\r\n                            }\r\n                            else {\r\n                                _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));\r\n                                _paddingElement.before(_contentGlueElement);\r\n                            }\r\n                            if (_sizeAutoObserverAdded) {\r\n                                _sizeAutoObserverElement.show();\r\n                            }\r\n                            else {\r\n                                _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));\r\n                                _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];\r\n\r\n                                _contentGlueElement.before(_sizeAutoObserverElement);\r\n                                var oldSize = { w: -1, h: -1 };\r\n                                setupResizeObserver(_sizeAutoObserverElement, function () {\r\n                                    var newSize = {\r\n                                        w: _sizeAutoObserverElementNative[LEXICON.oW],\r\n                                        h: _sizeAutoObserverElementNative[LEXICON.oH]\r\n                                    };\r\n                                    if (checkCache(newSize, oldSize)) {\r\n                                        if (_initialized && (_heightAutoCache && newSize.h > 0) || (_widthAutoCache && newSize.w > 0)) {\r\n                                            update();\r\n                                        }\r\n                                        else if (_initialized && (!_heightAutoCache && newSize.h === 0) || (!_widthAutoCache && newSize.w === 0)) {\r\n                                            update();\r\n                                        }\r\n                                    }\r\n                                    oldSize = newSize;\r\n                                });\r\n                                _sizeAutoObserverAdded = true;\r\n                                //fix heightAuto detector bug if height is fixed but contentHeight is 0.\r\n                                //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.\r\n                                if (_cssCalc !== null)\r\n                                    _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (_sizeAutoObserverAdded)\r\n                                _sizeAutoObserverElement.hide();\r\n                            if (_contentGlueElement)\r\n                                _contentGlueElement.hide();\r\n                        }\r\n                    }\r\n\r\n                    //if force, update all resizeObservers too\r\n                    if (force) {\r\n                        _sizeObserverElement.find('*').trigger(_strScroll);\r\n                        if (_sizeAutoObserverAdded)\r\n                            _sizeAutoObserverElement.find('*').trigger(_strScroll);\r\n                    }\r\n\r\n                    //display hidden:\r\n                    displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden;\r\n\r\n                    //textarea AutoWrapping:\r\n                    var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;\r\n                    var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache);\r\n\r\n                    //detect direction:\r\n                    var cssDirection = _hostElement.css('direction');\r\n                    var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache);\r\n\r\n                    //detect box-sizing:\r\n                    var boxSizing = _hostElement.css('box-sizing');\r\n                    var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache);\r\n\r\n                    //detect padding:\r\n                    var padding = getTopRightBottomLeftHost(_strPaddingMinus);\r\n\r\n                    //width + height auto detecting var:\r\n                    var sizeAutoObserverElementBCRect;\r\n                    //exception occurs in IE8 sometimes (unknown exception)\r\n                    try {\r\n                        sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;\r\n                    } catch (ex) {\r\n                        return;\r\n                    }\r\n\r\n                    _isRTL = cssDirection === 'rtl';\r\n                    _isBorderBox = (boxSizing === 'border-box');\r\n                    var isRTLLeft = _isRTL ? _strLeft : _strRight;\r\n                    var isRTLRight = _isRTL ? _strRight : _strLeft;\r\n\r\n                    //detect width auto:\r\n                    var widthAutoResizeDetection = false;\r\n                    var widthAutoObserverDetection = (_sizeAutoObserverAdded && (_hostElement.css(_strFloat) !== 'none' /*|| _isTextarea */)) ? (MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0) && (!paddingAbsolute ? (_hostElementNative[LEXICON.cW] - _paddingX) > 0 : true) : false;\r\n                    if (sizeAutoCapable && !widthAutoObserverDetection) {\r\n                        var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];\r\n                        var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);\r\n                        _contentGlueElement.css(_strWidth, _strAuto);\r\n\r\n                        var tmpNewHostWidth = _hostElementNative[LEXICON.oW];\r\n                        _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);\r\n                        widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;\r\n                        if (!widthAutoResizeDetection) {\r\n                            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);\r\n                            tmpNewHostWidth = _hostElementNative[LEXICON.oW];\r\n                            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);\r\n                            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;\r\n                        }\r\n                    }\r\n                    var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;\r\n                    var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);\r\n                    var wasWidthAuto = !widthAuto && _widthAutoCache;\r\n\r\n                    //detect height auto:\r\n                    var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? (MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0) /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */ : false;\r\n                    var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);\r\n                    var wasHeightAuto = !heightAuto && _heightAutoCache;\r\n\r\n                    //detect border:\r\n                    //we need the border only if border box and auto size\r\n                    var updateBorderX = (widthAuto && _isBorderBox) || !_isBorderBox;\r\n                    var updateBorderY = (heightAuto && _isBorderBox) || !_isBorderBox;\r\n                    var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY)\r\n\r\n                    //detect margin:\r\n                    var margin = getTopRightBottomLeftHost(_strMarginMinus);\r\n\r\n                    //vars to apply correct css\r\n                    var contentElementCSS = {};\r\n                    var contentGlueElementCSS = {};\r\n\r\n                    //funcs\r\n                    var getHostSize = function () {\r\n                        //has to be clientSize because offsetSize respect borders\r\n                        return {\r\n                            w: _hostElementNative[LEXICON.cW],\r\n                            h: _hostElementNative[LEXICON.cH]\r\n                        };\r\n                    };\r\n                    var getViewportSize = function () {\r\n                        //viewport size is padding container because it never has padding, margin and a border\r\n                        //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height\r\n                        //if this happens add the difference to the viewportSize to compensate the rounding error\r\n                        return {\r\n                            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),\r\n                            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])\r\n                        };\r\n                    };\r\n\r\n                    //set info for padding\r\n                    var paddingAbsoluteX = _paddingX = padding.l + padding.r;\r\n                    var paddingAbsoluteY = _paddingY = padding.t + padding.b;\r\n                    paddingAbsoluteX *= paddingAbsolute ? 1 : 0;\r\n                    paddingAbsoluteY *= paddingAbsolute ? 1 : 0;\r\n                    padding.c = checkCacheAutoForce(padding, _cssPaddingCache);\r\n\r\n                    //set info for border\r\n                    _borderX = border.l + border.r;\r\n                    _borderY = border.t + border.b;\r\n                    border.c = checkCacheAutoForce(border, _cssBorderCache);\r\n\r\n                    //set info for margin\r\n                    _marginX = margin.l + margin.r;\r\n                    _marginY = margin.t + margin.b;\r\n                    margin.c = checkCacheAutoForce(margin, _cssMarginCache);\r\n\r\n                    //refresh cache\r\n                    _textareaAutoWrappingCache = textareaAutoWrapping;\r\n                    _cssDirectionCache = cssDirection;\r\n                    _cssBoxSizingCache = boxSizing;\r\n                    _widthAutoCache = widthAuto;\r\n                    _heightAutoCache = heightAuto;\r\n                    _cssPaddingCache = padding;\r\n                    _cssBorderCache = border;\r\n                    _cssMarginCache = margin;\r\n\r\n                    //IEFix direction changed\r\n                    if (cssDirectionChanged && _sizeAutoObserverAdded)\r\n                        _sizeAutoObserverElement.css(_strFloat, isRTLRight);\r\n\r\n                    //apply padding:\r\n                    if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {\r\n                        var paddingElementCSS = {};\r\n                        var textareaCSS = {};\r\n                        var paddingValues = [padding.t, padding.r, padding.b, padding.l];\r\n\r\n                        setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);\r\n                        if (paddingAbsolute) {\r\n                            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);\r\n                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);\r\n                        }\r\n                        else {\r\n                            setTopRightBottomLeft(paddingElementCSS, _strEmpty);\r\n                            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);\r\n                        }\r\n\r\n                        _paddingElement.css(paddingElementCSS);\r\n                        _targetElement.css(textareaCSS);\r\n                    }\r\n\r\n                    //viewport size is padding container because it never has padding, margin and a border.\r\n                    _viewportSize = getViewportSize();\r\n\r\n                    //update Textarea\r\n                    var textareaSize = _isTextarea ? textareaUpdate() : false;\r\n                    var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);\r\n                    var textareaDynOrigSize = _isTextarea && textareaSize ? {\r\n                        w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,\r\n                        h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight\r\n                    } : {};\r\n                    _textareaSizeCache = textareaSize;\r\n\r\n                    //fix height auto / width auto in cooperation with current padding & boxSizing behavior:\r\n                    if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {\r\n                        contentElementCSS[_strHeight] = _strAuto;\r\n                    }\r\n                    else if (heightAutoChanged || paddingAbsoluteChanged) {\r\n                        contentElementCSS[_strHeight] = _strHundredPercent;\r\n                    }\r\n                    if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {\r\n                        contentElementCSS[_strWidth] = _strAuto;\r\n                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix\r\n                    }\r\n                    else if (widthAutoChanged || paddingAbsoluteChanged) {\r\n                        contentElementCSS[_strWidth] = _strHundredPercent;\r\n                        contentElementCSS[_strFloat] = _strEmpty;\r\n                        contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix\r\n                    }\r\n                    if (widthAuto) {\r\n                        //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width\r\n                        contentGlueElementCSS[_strWidth] = _strAuto;\r\n\r\n                        contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;\r\n                        contentElementCSS[_strFloat] = isRTLRight;\r\n                    }\r\n                    else {\r\n                        contentGlueElementCSS[_strWidth] = _strEmpty;\r\n                    }\r\n                    if (heightAuto) {\r\n                        //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping\r\n                        contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];\r\n                    }\r\n                    else {\r\n                        contentGlueElementCSS[_strHeight] = _strEmpty;\r\n                    }\r\n                    if (sizeAutoCapable)\r\n                        _contentGlueElement.css(contentGlueElementCSS);\r\n                    _contentElement.css(contentElementCSS);\r\n\r\n                    //CHECKPOINT HERE ~\r\n                    contentElementCSS = {};\r\n                    contentGlueElementCSS = {};\r\n\r\n                    //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true\r\n                    if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {\r\n                        var strOverflow = 'overflow';\r\n                        var strOverflowX = strOverflow + '-x';\r\n                        var strOverflowY = strOverflow + '-y';\r\n                        var strHidden = 'hidden';\r\n                        var strVisible = 'visible';\r\n\r\n                        //Reset the viewport (very important for natively overlaid scrollbars and zoom change\r\n                        //don't change the overflow prop as it is very expensive and affects performance !A LOT!\r\n                        if (!_nativeScrollbarStyling) {\r\n                            var viewportElementResetCSS = {};\r\n                            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y) : 0;\r\n                            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? (_nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x) : 0;\r\n                            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);\r\n                            _viewportElement.css(viewportElementResetCSS);\r\n                        }\r\n\r\n                        //measure several sizes:\r\n                        var contentMeasureElement = getContentMeasureElement();\r\n                        //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid\r\n                        var contentSize = {\r\n                            //use clientSize because natively overlaidScrollbars add borders\r\n                            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],\r\n                            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]\r\n                        };\r\n                        var scrollSize = {\r\n                            w: contentMeasureElement[LEXICON.sW],\r\n                            h: contentMeasureElement[LEXICON.sH]\r\n                        };\r\n\r\n                        //apply the correct viewport style and measure viewport size\r\n                        if (!_nativeScrollbarStyling) {\r\n                            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;\r\n                            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;\r\n                            _viewportElement.css(viewportElementResetCSS);\r\n                        }\r\n                        _viewportSize = getViewportSize();\r\n\r\n                        //measure and correct several sizes\r\n                        var hostSize = getHostSize();\r\n                        var hostAbsoluteRectSize = {\r\n                            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),\r\n                            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)\r\n                        };\r\n                        var contentGlueSize = {\r\n                            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually\r\n                            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding\r\n                            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),\r\n                            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)\r\n                        };\r\n                        contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);\r\n                        _contentGlueSizeCache = contentGlueSize;\r\n\r\n                        //apply correct contentGlue size\r\n                        if (sizeAutoCapable) {\r\n                            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto\r\n                            if (contentGlueSize.c || (heightAuto || widthAuto)) {\r\n                                contentGlueElementCSS[_strWidth] = contentGlueSize.w;\r\n                                contentGlueElementCSS[_strHeight] = contentGlueSize.h;\r\n\r\n                                //textarea-sizes are already calculated correctly at this point\r\n                                if (!_isTextarea) {\r\n                                    contentSize = {\r\n                                        //use clientSize because natively overlaidScrollbars add borders\r\n                                        w: contentMeasureElement[LEXICON.cW],\r\n                                        h: contentMeasureElement[LEXICON.cH]\r\n                                    };\r\n                                }\r\n                            }\r\n                            var textareaCoverCSS = {};\r\n                            var setContentGlueElementCSSfunction = function (horizontal) {\r\n                                var scrollbarVars = getScrollbarVars(horizontal);\r\n                                var wh = scrollbarVars._w_h;\r\n                                var strWH = scrollbarVars._width_height;\r\n                                var autoSize = horizontal ? widthAuto : heightAuto;\r\n                                var borderSize = horizontal ? _borderX : _borderY;\r\n                                var paddingSize = horizontal ? _paddingX : _paddingY;\r\n                                var marginSize = horizontal ? _marginX : _marginY;\r\n                                var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize);\r\n\r\n                                //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks\r\n                                if (!autoSize || (!autoSize && border.c))\r\n                                    contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1;\r\n\r\n                                //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)\r\n                                if (autoSize && (contentSize[wh] < viewportSize) && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {\r\n                                    if (_isTextarea)\r\n                                        textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;\r\n                                    contentGlueElementCSS[strWH] -= 1;\r\n                                }\r\n\r\n                                //make sure content glue size is at least 1\r\n                                if (contentSize[wh] > 0)\r\n                                    contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);\r\n                            };\r\n                            setContentGlueElementCSSfunction(true);\r\n                            setContentGlueElementCSSfunction(false);\r\n\r\n                            if (_isTextarea)\r\n                                _textareaCoverElement.css(textareaCoverCSS);\r\n                            _contentGlueElement.css(contentGlueElementCSS);\r\n                        }\r\n                        if (widthAuto)\r\n                            contentElementCSS[_strWidth] = _strHundredPercent;\r\n                        if (widthAuto && !_isBorderBox && !_mutationObserversConnected)\r\n                            contentElementCSS[_strFloat] = 'none';\r\n\r\n                        //apply and reset content style\r\n                        _contentElement.css(contentElementCSS);\r\n                        contentElementCSS = {};\r\n\r\n                        //measure again, but this time all correct sizes:\r\n                        var contentScrollSize = {\r\n                            w: contentMeasureElement[LEXICON.sW],\r\n                            h: contentMeasureElement[LEXICON.sH],\r\n                        };\r\n                        contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);\r\n                        _contentScrollSizeCache = contentScrollSize;\r\n\r\n                        //refresh viewport size after correct measuring\r\n                        _viewportSize = getViewportSize();\r\n\r\n                        hostSize = getHostSize();\r\n                        hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);\r\n                        _hostSizeCache = hostSize;\r\n\r\n                        var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);\r\n                        var previousOverflowAmount = _overflowAmountCache;\r\n                        var overflowBehaviorIsVS = {};\r\n                        var overflowBehaviorIsVH = {};\r\n                        var overflowBehaviorIsS = {};\r\n                        var overflowAmount = {};\r\n                        var hasOverflow = {};\r\n                        var hideOverflow = {};\r\n                        var canScroll = {};\r\n                        var viewportRect = _paddingElementNative[LEXICON.bCR]();\r\n                        var setOverflowVariables = function (horizontal) {\r\n                            var scrollbarVars = getScrollbarVars(horizontal);\r\n                            var scrollbarVarsInverted = getScrollbarVars(!horizontal);\r\n                            var xyI = scrollbarVarsInverted._x_y;\r\n                            var xy = scrollbarVars._x_y;\r\n                            var wh = scrollbarVars._w_h;\r\n                            var widthHeight = scrollbarVars._width_height;\r\n                            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';\r\n                            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;\r\n                            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;\r\n                            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';\r\n                            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';\r\n                            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';\r\n                            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);\r\n                            overflowAmount[xy] *= (hideOverflowForceTextarea || (checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1)) ? 0 : 1;\r\n                            hasOverflow[xy] = overflowAmount[xy] > 0;\r\n\r\n                            //hideOverflow:\r\n                            //x || y : true === overflow is hidden by \"overflow: scroll\" OR \"overflow: hidden\"\r\n                            //xs || ys : true === overflow is hidden by \"overflow: scroll\"\r\n                            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? (hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI]) : hasOverflow[xy];\r\n                            hideOverflow[xy + 's'] = hideOverflow[xy] ? (overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy]) : false;\r\n\r\n                            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];\r\n                        };\r\n                        setOverflowVariables(true);\r\n                        setOverflowVariables(false);\r\n\r\n                        overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);\r\n                        _overflowAmountCache = overflowAmount;\r\n                        hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);\r\n                        _hasOverflowCache = hasOverflow;\r\n                        hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);\r\n                        _hideOverflowCache = hideOverflow;\r\n\r\n                        //if native scrollbar is overlay at x OR y axis, prepare DOM\r\n                        if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {\r\n                            var borderDesign = 'px solid transparent';\r\n                            var contentArrangeElementCSS = {};\r\n                            var arrangeContent = {};\r\n                            var arrangeChanged = force;\r\n                            var setContentElementCSS;\r\n\r\n                            if (hasOverflow.x || hasOverflow.y) {\r\n                                arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;\r\n                                arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;\r\n                                arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);\r\n                                _arrangeContentSizeCache = arrangeContent;\r\n                            }\r\n\r\n                            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {\r\n                                contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;\r\n                                setContentElementCSS = function (horizontal) {\r\n                                    var scrollbarVars = getScrollbarVars(horizontal);\r\n                                    var scrollbarVarsInverted = getScrollbarVars(!horizontal);\r\n                                    var xy = scrollbarVars._x_y;\r\n                                    var strDirection = horizontal ? _strBottom : isRTLLeft;\r\n                                    var invertedAutoSize = horizontal ? heightAuto : widthAuto;\r\n\r\n                                    if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {\r\n                                        contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? (ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy]) : _strEmpty;\r\n                                        contentElementCSS[_strBorderMinus + strDirection] = ((horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding) ? (_overlayScrollbarDummySize[xy] + borderDesign) : _strEmpty;\r\n                                    }\r\n                                    else {\r\n                                        arrangeContent[scrollbarVarsInverted._w_h] =\r\n                                            contentElementCSS[_strMarginMinus + strDirection] =\r\n                                            contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;\r\n                                        arrangeChanged = true;\r\n                                    }\r\n                                };\r\n\r\n                                if (_nativeScrollbarStyling) {\r\n                                    addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding)\r\n                                }\r\n                                else {\r\n                                    setContentElementCSS(true);\r\n                                    setContentElementCSS(false);\r\n                                }\r\n                            }\r\n                            if (ignoreOverlayScrollbarHiding) {\r\n                                arrangeContent.w = arrangeContent.h = _strEmpty;\r\n                                arrangeChanged = true;\r\n                            }\r\n                            if (arrangeChanged && !_nativeScrollbarStyling) {\r\n                                contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;\r\n                                contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;\r\n\r\n                                if (!_contentArrangeElement) {\r\n                                    _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));\r\n                                    _viewportElement.prepend(_contentArrangeElement);\r\n                                }\r\n                                _contentArrangeElement.css(contentArrangeElementCSS);\r\n                            }\r\n                            _contentElement.css(contentElementCSS);\r\n                        }\r\n\r\n                        var viewportElementCSS = {};\r\n                        var paddingElementCSS = {};\r\n                        var setViewportCSS;\r\n                        if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {\r\n                            viewportElementCSS[isRTLRight] = _strEmpty;\r\n                            setViewportCSS = function (horizontal) {\r\n                                var scrollbarVars = getScrollbarVars(horizontal);\r\n                                var scrollbarVarsInverted = getScrollbarVars(!horizontal);\r\n                                var xy = scrollbarVars._x_y;\r\n                                var XY = scrollbarVars._X_Y;\r\n                                var strDirection = horizontal ? _strBottom : isRTLLeft;\r\n\r\n                                var reset = function () {\r\n                                    viewportElementCSS[strDirection] = _strEmpty;\r\n                                    _contentBorderSize[scrollbarVarsInverted._w_h] = 0;\r\n                                };\r\n                                if (hasOverflow[xy] && hideOverflow[xy + 's']) {\r\n                                    viewportElementCSS[strOverflow + XY] = _strScroll;\r\n                                    if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {\r\n                                        reset();\r\n                                    }\r\n                                    else {\r\n                                        viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);\r\n                                        _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;\r\n                                    }\r\n                                } else {\r\n                                    viewportElementCSS[strOverflow + XY] = _strEmpty;\r\n                                    reset();\r\n                                }\r\n                            };\r\n                            setViewportCSS(true);\r\n                            setViewportCSS(false);\r\n\r\n                            // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible), \r\n                            // make viewport element greater in size (Firefox hide Scrollbars fix)\r\n                            // because firefox starts hiding scrollbars on too small elements\r\n                            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly\r\n                            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284\r\n                            if (!_nativeScrollbarStyling\r\n                                && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y)\r\n                                && ((hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x) || (hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y))) {\r\n                                viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;\r\n                                viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;\r\n\r\n                                viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;\r\n                                viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;\r\n                            }\r\n                            else {\r\n                                viewportElementCSS[_strPaddingMinus + _strTop] =\r\n                                    viewportElementCSS[_strMarginMinus + _strTop] =\r\n                                    viewportElementCSS[_strPaddingMinus + isRTLRight] =\r\n                                    viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;\r\n                            }\r\n                            viewportElementCSS[_strPaddingMinus + isRTLLeft] =\r\n                                viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty;\r\n\r\n                            //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible\r\n                            if ((hasOverflow.x && hideOverflow.x) || (hasOverflow.y && hideOverflow.y) || hideOverflowForceTextarea) {\r\n                                //only hide if is Textarea\r\n                                if (_isTextarea && hideOverflowForceTextarea) {\r\n                                    paddingElementCSS[strOverflowX] =\r\n                                        paddingElementCSS[strOverflowY] = strHidden;\r\n                                }\r\n                            }\r\n                            else {\r\n                                if (!clipAlways || (overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y)) {\r\n                                    //only un-hide if Textarea\r\n                                    if (_isTextarea) {\r\n                                        paddingElementCSS[strOverflowX] =\r\n                                            paddingElementCSS[strOverflowY] = _strEmpty;\r\n                                    }\r\n                                    viewportElementCSS[strOverflowX] =\r\n                                        viewportElementCSS[strOverflowY] = strVisible;\r\n                                }\r\n                            }\r\n\r\n                            _paddingElement.css(paddingElementCSS);\r\n                            _viewportElement.css(viewportElementCSS);\r\n                            viewportElementCSS = {};\r\n\r\n                            //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions\r\n                            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {\r\n                                var elementStyle = _contentElementNative[LEXICON.s];\r\n                                var dump;\r\n                                elementStyle.webkitTransform = 'scale(1)';\r\n                                elementStyle.display = 'run-in';\r\n                                dump = _contentElementNative[LEXICON.oH];\r\n                                elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify\r\n                                elementStyle.webkitTransform = _strEmpty;\r\n                            }\r\n                            /*\r\n                            //force hard redraw in webkit if native overlaid scrollbars shall appear\r\n                            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {\r\n                                _hostElement.hide();\r\n                                var dump = _hostElementNative[LEXICON.oH];\r\n                                _hostElement.show();\r\n                            }\r\n                            */\r\n                        }\r\n\r\n                        //change to direction RTL and width auto Bugfix in Webkit\r\n                        //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left\r\n                        contentElementCSS = {};\r\n                        if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {\r\n                            if (_isRTL && widthAuto) {\r\n                                var floatTmp = _contentElement.css(_strFloat);\r\n                                var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);\r\n                                _contentElement.css(_strFloat, floatTmp);\r\n                                var posLeftWithFloat = MATH.round(_contentElement.position().left);\r\n\r\n                                if (posLeftWithoutFloat !== posLeftWithFloat)\r\n                                    contentElementCSS[_strLeft] = posLeftWithoutFloat;\r\n                            }\r\n                            else {\r\n                                contentElementCSS[_strLeft] = _strEmpty;\r\n                            }\r\n                        }\r\n                        _contentElement.css(contentElementCSS);\r\n\r\n                        //handle scroll position\r\n                        if (_isTextarea && contentSizeChanged) {\r\n                            var textareaInfo = getTextareaInfo();\r\n                            if (textareaInfo) {\r\n                                var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;\r\n                                var cursorRow = textareaInfo._cursorRow;\r\n                                var cursorCol = textareaInfo._cursorColumn;\r\n                                var widestRow = textareaInfo._widestRow;\r\n                                var lastRow = textareaInfo._rows;\r\n                                var lastCol = textareaInfo._columns;\r\n                                var cursorPos = textareaInfo._cursorPosition;\r\n                                var cursorMax = textareaInfo._cursorMax;\r\n                                var cursorIsLastPosition = (cursorPos >= cursorMax && _textareaHasFocus);\r\n                                var textareaScrollAmount = {\r\n                                    x: (!textareaAutoWrapping && (cursorCol === lastCol && cursorRow === widestRow)) ? _overflowAmountCache.x : -1,\r\n                                    y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? (currScroll.y === previousOverflowAmount.y) : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1\r\n                                };\r\n                                currScroll.x = textareaScrollAmount.x > -1 ? (_isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x) : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.\r\n                                currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;\r\n                            }\r\n                            _textareaInfoCache = textareaInfo;\r\n                        }\r\n                        if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache)\r\n                            currScroll.x += _contentBorderSize.w || 0;\r\n                        if (widthAuto)\r\n                            _hostElement[_strScrollLeft](0);\r\n                        if (heightAuto)\r\n                            _hostElement[_strScrollTop](0);\r\n                        _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y);\r\n\r\n                        //scrollbars management:\r\n                        var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';\r\n                        var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';\r\n                        var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';\r\n                        var refreshScrollbarsVisibility = function (showX, showY) {\r\n                            showY = showY === undefined ? showX : showY;\r\n                            refreshScrollbarAppearance(true, showX, canScroll.x)\r\n                            refreshScrollbarAppearance(false, showY, canScroll.y)\r\n                        };\r\n\r\n                        //manage class name which indicates scrollable overflow\r\n                        addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);\r\n                        addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);\r\n                        addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y);\r\n\r\n                        //add or remove rtl class name for styling purposes except when its body, then the scrollbar stays\r\n                        if (cssDirectionChanged && !_isBody) {\r\n                            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);\r\n                        }\r\n\r\n                        //manage the resize feature (CSS3 resize \"polyfill\" for this plugin)\r\n                        if (_isBody)\r\n                            addClass(_hostElement, _classNameHostResizeDisabled);\r\n                        if (resizeChanged) {\r\n                            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);\r\n                            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);\r\n                        }\r\n\r\n                        //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)\r\n                        if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {\r\n                            if (ignoreOverlayScrollbarHiding) {\r\n                                if (ignoreOverlayScrollbarHidingChanged) {\r\n                                    removeClass(_hostElement, _classNameHostScrolling);\r\n                                    if (ignoreOverlayScrollbarHiding) {\r\n                                        refreshScrollbarsVisibility(false);\r\n                                    }\r\n                                }\r\n                            }\r\n                            else if (scrollbarsVisibilityAuto) {\r\n                                refreshScrollbarsVisibility(canScroll.x, canScroll.y);\r\n                            }\r\n                            else if (scrollbarsVisibilityVisible) {\r\n                                refreshScrollbarsVisibility(true);\r\n                            }\r\n                            else if (scrollbarsVisibilityHidden) {\r\n                                refreshScrollbarsVisibility(false);\r\n                            }\r\n                        }\r\n\r\n                        //manage the scrollbars auto hide feature (auto hide them after specific actions)\r\n                        if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {\r\n                            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);\r\n                            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);\r\n                        }\r\n\r\n                        //manage scrollbars handle length & offset - don't remove!\r\n                        if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {\r\n                            refreshScrollbarHandleLength(true);\r\n                            refreshScrollbarHandleOffset(true);\r\n                            refreshScrollbarHandleLength(false);\r\n                            refreshScrollbarHandleOffset(false);\r\n                        }\r\n\r\n                        //manage interactivity\r\n                        if (scrollbarsClickScrollingChanged)\r\n                            refreshScrollbarsInteractive(true, scrollbarsClickScrolling);\r\n                        if (scrollbarsDragScrollingChanged)\r\n                            refreshScrollbarsInteractive(false, scrollbarsDragScrolling);\r\n\r\n                        //callbacks:\r\n                        dispatchCallback('onDirectionChanged', {\r\n                            isRTL: _isRTL,\r\n                            dir: cssDirection\r\n                        }, cssDirectionChanged);\r\n                        dispatchCallback('onHostSizeChanged', {\r\n                            width: _hostSizeCache.w,\r\n                            height: _hostSizeCache.h\r\n                        }, hostSizeChanged);\r\n                        dispatchCallback('onContentSizeChanged', {\r\n                            width: _contentScrollSizeCache.w,\r\n                            height: _contentScrollSizeCache.h\r\n                        }, contentSizeChanged);\r\n                        dispatchCallback('onOverflowChanged', {\r\n                            x: hasOverflow.x,\r\n                            y: hasOverflow.y,\r\n                            xScrollable: hideOverflow.xs,\r\n                            yScrollable: hideOverflow.ys,\r\n                            clipped: hideOverflow.x || hideOverflow.y\r\n                        }, hasOverflow.c || hideOverflow.c);\r\n                        dispatchCallback('onOverflowAmountChanged', {\r\n                            x: overflowAmount.x,\r\n                            y: overflowAmount.y\r\n                        }, overflowAmount.c);\r\n                    }\r\n\r\n                    //fix body min size\r\n                    if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {\r\n                        //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.\r\n                        if (!_bodyMinSizeCache.f)\r\n                            bodyMinSizeChanged();\r\n                        if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x)\r\n                            _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);\r\n                        if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y)\r\n                            _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);\r\n                        _bodyMinSizeCache.c = false;\r\n                    }\r\n\r\n                    if (_initialized && changedOptions.updateOnLoad) {\r\n                        updateElementsOnLoad();\r\n                    }\r\n\r\n                    //freezeResizeObserver(_sizeObserverElement, false);\r\n                    //freezeResizeObserver(_sizeAutoObserverElement, false);\r\n\r\n                    dispatchCallback('onUpdated', { forced: force });\r\n                }\r\n\r\n                /**\r\n                 * Updates the found elements of which the load event shall be handled.\r\n                 */\r\n                function updateElementsOnLoad() {\r\n                    if (!_isTextarea) {\r\n                        eachUpdateOnLoad(function (i, updateOnLoadSelector) {\r\n                            _contentElement.find(updateOnLoadSelector).each(function (i, el) {\r\n                                // if element doesn't have a updateOnLoadCallback applied\r\n                                if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {\r\n                                    _updateOnLoadElms.push(el);\r\n                                    FRAMEWORK(el)\r\n                                        .off(_updateOnLoadEventName, updateOnLoadCallback)\r\n                                        .on(_updateOnLoadEventName, updateOnLoadCallback);\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n\r\n                //==== Options ====//\r\n\r\n                /**\r\n                 * Sets new options but doesn't call the update method.\r\n                 * @param newOptions The object which contains the new options.\r\n                 * @returns {*} A object which contains the changed options.\r\n                 */\r\n                function setOptions(newOptions) {\r\n                    var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions)\r\n\r\n                    _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);\r\n                    _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);\r\n\r\n                    return validatedOpts._prepared;\r\n                }\r\n\r\n\r\n                //==== Structure ====//\r\n\r\n                /**\r\n                 * Builds or destroys the wrapper and helper DOM elements.\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                /**\r\n                 * Builds or destroys the wrapper and helper DOM elements.\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                function setupStructureDOM(destroy) {\r\n                    var strParent = 'parent';\r\n                    var classNameResizeObserverHost = 'os-resize-observer-host';\r\n                    var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;\r\n                    var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;\r\n                    var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;\r\n                    var adoptAttrsMap = {};\r\n                    var applyAdoptedAttrs = function () {\r\n                        var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;\r\n                        each(adoptAttrsMap, function (key, value) {\r\n                            if (type(value) == TYPES.s) {\r\n                                if (key == LEXICON.c)\r\n                                    applyAdoptedAttrsElm.addClass(value);\r\n                                else\r\n                                    applyAdoptedAttrsElm.attr(key, value);\r\n                            }\r\n                        });\r\n                    };\r\n                    var hostElementClassNames = [\r\n                        _classNameHostElement,\r\n                        _classNameHostElementForeign,\r\n                        _classNameHostTextareaElement,\r\n                        _classNameHostResizeDisabled,\r\n                        _classNameHostRTL,\r\n                        _classNameHostScrollbarHorizontalHidden,\r\n                        _classNameHostScrollbarVerticalHidden,\r\n                        _classNameHostTransition,\r\n                        _classNameHostScrolling,\r\n                        _classNameHostOverflow,\r\n                        _classNameHostOverflowX,\r\n                        _classNameHostOverflowY,\r\n                        _classNameThemeNone,\r\n                        _classNameTextareaElement,\r\n                        _classNameTextInherit,\r\n                        _classNameCache].join(_strSpace);\r\n                    var hostElementCSS = {};\r\n\r\n                    //get host element as first element, because that's the most upper element and required for the other elements\r\n                    _hostElement = _hostElement || (_isTextarea ? (_domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement))) : _targetElement);\r\n                    _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);\r\n                    _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);\r\n                    _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);\r\n                    _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);\r\n                    _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined);\r\n\r\n                    //add this class to workaround class changing issues with UI frameworks especially Vue\r\n                    if (_domExists)\r\n                        addClass(_hostElement, _classNameHostElementForeign);\r\n\r\n                    //on destroy, remove all generated class names from the host element before collecting the adopted attributes \r\n                    //to prevent adopting generated class names\r\n                    if (destroy)\r\n                        removeClass(_hostElement, hostElementClassNames);\r\n\r\n                    //collect all adopted attributes\r\n                    adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;\r\n                    if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {\r\n                        each(adoptAttrs, function (i, v) {\r\n                            if (type(v) == TYPES.s) {\r\n                                adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    if (!destroy) {\r\n                        if (_isTextarea) {\r\n                            if (!_currentPreparedOptions.sizeAutoCapable) {\r\n                                hostElementCSS[_strWidth] = _targetElement.css(_strWidth);\r\n                                hostElementCSS[_strHeight] = _targetElement.css(_strHeight);\r\n                            }\r\n\r\n                            if (!_domExists)\r\n                                _targetElement.addClass(_classNameTextInherit).wrap(_hostElement);\r\n\r\n                            //jQuery clones elements in wrap functions, so we have to select them again\r\n                            _hostElement = _targetElement[strParent]().css(hostElementCSS);\r\n                        }\r\n\r\n                        if (!_domExists) {\r\n                            //add the correct class to the target element\r\n                            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement);\r\n\r\n                            //wrap the content into the generated elements to create the required DOM\r\n                            _hostElement.wrapInner(_contentElement)\r\n                                .wrapInner(_viewportElement)\r\n                                .wrapInner(_paddingElement)\r\n                                .prepend(_sizeObserverElement);\r\n\r\n                            //jQuery clones elements in wrap functions, so we have to select them again\r\n                            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);\r\n                            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);\r\n                            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);\r\n\r\n                            if (_isTextarea) {\r\n                                _contentElement.prepend(_textareaCoverElement);\r\n                                applyAdoptedAttrs();\r\n                            }\r\n                        }\r\n\r\n                        if (_nativeScrollbarStyling)\r\n                            addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);\r\n                        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)\r\n                            addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);\r\n                        if (_isBody)\r\n                            addClass(_htmlElement, _classNameHTMLElement);\r\n\r\n                        _sizeObserverElementNative = _sizeObserverElement[0];\r\n                        _hostElementNative = _hostElement[0];\r\n                        _paddingElementNative = _paddingElement[0];\r\n                        _viewportElementNative = _viewportElement[0];\r\n                        _contentElementNative = _contentElement[0];\r\n\r\n                        updateViewportAttrsFromTarget();\r\n                    }\r\n                    else {\r\n                        if (_domExists && _initialized) {\r\n                            //clear size observer\r\n                            _sizeObserverElement.children().remove();\r\n\r\n                            //remove the style property and classes from already generated elements\r\n                            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {\r\n                                if (elm) {\r\n                                    removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\r\n                                }\r\n                            });\r\n\r\n                            //add classes to the host element which was removed previously to match the expected DOM\r\n                            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);\r\n                        }\r\n                        else {\r\n                            //remove size observer\r\n                            remove(_sizeObserverElement);\r\n\r\n                            //unwrap the content to restore DOM\r\n                            _contentElement.contents()\r\n                                .unwrap()\r\n                                .unwrap()\r\n                                .unwrap();\r\n\r\n                            if (_isTextarea) {\r\n                                _targetElement.unwrap();\r\n                                remove(_hostElement);\r\n                                remove(_textareaCoverElement);\r\n                                applyAdoptedAttrs();\r\n                            }\r\n                        }\r\n\r\n                        if (_isTextarea)\r\n                            _targetElement.removeAttr(LEXICON.s);\r\n\r\n                        if (_isBody)\r\n                            removeClass(_htmlElement, _classNameHTMLElement);\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Adds or removes all wrapper elements interactivity events.\r\n                 * @param destroy Indicates whether the Events shall be added or removed.\r\n                 */\r\n                function setupStructureEvents() {\r\n                    var textareaKeyDownRestrictedKeyCodes = [\r\n                        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123,    //F1 to F12\r\n                        33, 34,                                                   //page up, page down\r\n                        37, 38, 39, 40,                                           //left, up, right, down arrows\r\n                        16, 17, 18, 19, 20, 144                                   //Shift, Ctrl, Alt, Pause, CapsLock, NumLock\r\n                    ];\r\n                    var textareaKeyDownKeyCodesList = [];\r\n                    var textareaUpdateIntervalID;\r\n                    var scrollStopTimeoutId;\r\n                    var scrollStopDelay = 175;\r\n                    var strFocus = 'focus';\r\n\r\n                    function updateTextarea(doClearInterval) {\r\n                        textareaUpdate();\r\n                        _base.update(_strAuto);\r\n                        if (doClearInterval && _autoUpdateRecommended)\r\n                            clearInterval(textareaUpdateIntervalID);\r\n                    }\r\n                    function textareaOnScroll(event) {\r\n                        _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);\r\n                        _targetElement[_strScrollTop](0);\r\n                        COMPATIBILITY.prvD(event);\r\n                        COMPATIBILITY.stpP(event);\r\n                        return false;\r\n                    }\r\n                    function textareaOnDrop(event) {\r\n                        setTimeout(function () {\r\n                            if (!_destroyed)\r\n                                updateTextarea();\r\n                        }, 50);\r\n                    }\r\n                    function textareaOnFocus() {\r\n                        _textareaHasFocus = true;\r\n                        addClass(_hostElement, strFocus);\r\n                    }\r\n                    function textareaOnFocusout() {\r\n                        _textareaHasFocus = false;\r\n                        textareaKeyDownKeyCodesList = [];\r\n                        removeClass(_hostElement, strFocus);\r\n                        updateTextarea(true);\r\n                    }\r\n                    function textareaOnKeyDown(event) {\r\n                        var keyCode = event.keyCode;\r\n\r\n                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {\r\n                            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {\r\n                                updateTextarea();\r\n                                textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);\r\n                            }\r\n                            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0)\r\n                                textareaKeyDownKeyCodesList.push(keyCode);\r\n                        }\r\n                    }\r\n                    function textareaOnKeyUp(event) {\r\n                        var keyCode = event.keyCode;\r\n                        var index = inArray(keyCode, textareaKeyDownKeyCodesList);\r\n\r\n                        if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {\r\n                            if (index > -1)\r\n                                textareaKeyDownKeyCodesList.splice(index, 1);\r\n                            if (!textareaKeyDownKeyCodesList[LEXICON.l])\r\n                                updateTextarea(true);\r\n                        }\r\n                    }\r\n                    function contentOnTransitionEnd(event) {\r\n                        if (_autoUpdateCache === true)\r\n                            return;\r\n                        event = event.originalEvent || event;\r\n                        if (isSizeAffectingCSSProperty(event.propertyName))\r\n                            _base.update(_strAuto);\r\n                    }\r\n                    function viewportOnScroll(event) {\r\n                        if (!_sleeping) {\r\n                            if (scrollStopTimeoutId !== undefined)\r\n                                clearTimeout(scrollStopTimeoutId);\r\n                            else {\r\n                                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                                    refreshScrollbarsAutoHide(true);\r\n\r\n                                if (!nativeOverlayScrollbarsAreActive())\r\n                                    addClass(_hostElement, _classNameHostScrolling);\r\n\r\n                                dispatchCallback('onScrollStart', event);\r\n                            }\r\n\r\n                            //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset\r\n                            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point\r\n                            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove\r\n                            if (!_scrollbarsHandlesDefineScrollPos) {\r\n                                refreshScrollbarHandleOffset(true);\r\n                                refreshScrollbarHandleOffset(false);\r\n                            }\r\n                            dispatchCallback('onScroll', event);\r\n\r\n                            scrollStopTimeoutId = setTimeout(function () {\r\n                                if (!_destroyed) {\r\n                                    //OnScrollStop:\r\n                                    clearTimeout(scrollStopTimeoutId);\r\n                                    scrollStopTimeoutId = undefined;\r\n\r\n                                    if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                                        refreshScrollbarsAutoHide(false);\r\n\r\n                                    if (!nativeOverlayScrollbarsAreActive())\r\n                                        removeClass(_hostElement, _classNameHostScrolling);\r\n\r\n                                    dispatchCallback('onScrollStop', event);\r\n                                }\r\n                            }, scrollStopDelay);\r\n                        }\r\n                    }\r\n\r\n\r\n                    if (_isTextarea) {\r\n                        if (_msieVersion > 9 || !_autoUpdateRecommended) {\r\n                            addDestroyEventListener(_targetElement, 'input', updateTextarea);\r\n                        }\r\n                        else {\r\n                            addDestroyEventListener(_targetElement,\r\n                                [_strKeyDownEvent, _strKeyUpEvent],\r\n                                [textareaOnKeyDown, textareaOnKeyUp]);\r\n                        }\r\n\r\n                        addDestroyEventListener(_targetElement,\r\n                            [_strScroll, 'drop', strFocus, strFocus + 'out'],\r\n                            [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);\r\n                    }\r\n                    else {\r\n                        addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);\r\n                    }\r\n                    addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);\r\n                }\r\n\r\n\r\n                //==== Scrollbars ====//\r\n\r\n                /**\r\n                 * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                function setupScrollbarsDOM(destroy) {\r\n                    var selectOrGenerateScrollbarDOM = function (isHorizontal) {\r\n                        var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;\r\n                        var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);\r\n                        var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);\r\n                        var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);\r\n\r\n                        if (!_domExists && !destroy) {\r\n                            scrollbar.append(track);\r\n                            track.append(handle);\r\n                        }\r\n\r\n                        return {\r\n                            _scrollbar: scrollbar,\r\n                            _track: track,\r\n                            _handle: handle\r\n                        };\r\n                    };\r\n                    function resetScrollbarDOM(isHorizontal) {\r\n                        var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                        var scrollbar = scrollbarVars._scrollbar;\r\n                        var track = scrollbarVars._track;\r\n                        var handle = scrollbarVars._handle;\r\n\r\n                        if (_domExists && _initialized) {\r\n                            each([scrollbar, track, handle], function (i, elm) {\r\n                                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\r\n                            });\r\n                        }\r\n                        else {\r\n                            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);\r\n                        }\r\n                    }\r\n                    var horizontalElements;\r\n                    var verticalElements;\r\n\r\n                    if (!destroy) {\r\n                        horizontalElements = selectOrGenerateScrollbarDOM(true);\r\n                        verticalElements = selectOrGenerateScrollbarDOM();\r\n\r\n                        _scrollbarHorizontalElement = horizontalElements._scrollbar;\r\n                        _scrollbarHorizontalTrackElement = horizontalElements._track;\r\n                        _scrollbarHorizontalHandleElement = horizontalElements._handle;\r\n                        _scrollbarVerticalElement = verticalElements._scrollbar;\r\n                        _scrollbarVerticalTrackElement = verticalElements._track;\r\n                        _scrollbarVerticalHandleElement = verticalElements._handle;\r\n\r\n                        if (!_domExists) {\r\n                            _paddingElement.after(_scrollbarVerticalElement);\r\n                            _paddingElement.after(_scrollbarHorizontalElement);\r\n                        }\r\n                    }\r\n                    else {\r\n                        resetScrollbarDOM(true);\r\n                        resetScrollbarDOM();\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)\r\n                 * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.\r\n                 */\r\n                function setupScrollbarEvents(isHorizontal) {\r\n                    var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                    var scrollbarVarsInfo = scrollbarVars._info;\r\n                    var insideIFrame = _windowElementNative.top !== _windowElementNative;\r\n                    var xy = scrollbarVars._x_y;\r\n                    var XY = scrollbarVars._X_Y;\r\n                    var scroll = _strScroll + scrollbarVars._Left_Top;\r\n                    var strActive = 'active';\r\n                    var strSnapHandle = 'snapHandle';\r\n                    var strClickEvent = 'click';\r\n                    var scrollDurationFactor = 1;\r\n                    var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl\r\n                    var trackTimeout;\r\n                    var mouseDownScroll;\r\n                    var mouseDownOffset;\r\n                    var mouseDownInvertedScale;\r\n\r\n                    function getPointerPosition(event) {\r\n                        return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.\r\n                    }\r\n                    function getPreparedScrollbarsOption(name) {\r\n                        return _currentPreparedOptions.scrollbars[name];\r\n                    }\r\n                    function increaseTrackScrollAmount() {\r\n                        scrollDurationFactor = 0.5;\r\n                    }\r\n                    function decreaseTrackScrollAmount() {\r\n                        scrollDurationFactor = 1;\r\n                    }\r\n                    function stopClickEventPropagation(event) {\r\n                        COMPATIBILITY.stpP(event);\r\n                    }\r\n                    function documentKeyDown(event) {\r\n                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)\r\n                            increaseTrackScrollAmount();\r\n                    }\r\n                    function documentKeyUp(event) {\r\n                        if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1)\r\n                            decreaseTrackScrollAmount();\r\n                    }\r\n                    function onMouseTouchDownContinue(event) {\r\n                        var originalEvent = event.originalEvent || event;\r\n                        var isTouchEvent = originalEvent.touches !== undefined;\r\n                        return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || (isTouchEvent && !getPreparedScrollbarsOption('touchSupport')) ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;\r\n                    }\r\n                    function documentDragMove(event) {\r\n                        if (onMouseTouchDownContinue(event)) {\r\n                            var trackLength = scrollbarVarsInfo._trackLength;\r\n                            var handleLength = scrollbarVarsInfo._handleLength;\r\n                            var scrollRange = scrollbarVarsInfo._maxScroll;\r\n                            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;\r\n                            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);\r\n                            var scrollDelta = (scrollRange * scrollDeltaPercent);\r\n                            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;\r\n                            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i)\r\n                                scrollDelta *= -1;\r\n\r\n                            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));\r\n\r\n                            if (_scrollbarsHandlesDefineScrollPos)\r\n                                refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);\r\n\r\n                            if (!_supportPassiveEvents)\r\n                                COMPATIBILITY.prvD(event);\r\n                        }\r\n                        else\r\n                            documentMouseTouchUp(event);\r\n                    }\r\n                    function documentMouseTouchUp(event) {\r\n                        event = event || event.originalEvent;\r\n\r\n                        setupResponsiveEventListener(_documentElement,\r\n                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],\r\n                            [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart],\r\n                            true);\r\n                        COMPATIBILITY.rAF()(function() {\r\n                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, true, { _capture: true });\r\n                        });\r\n                        \r\n                            \r\n                        if (_scrollbarsHandlesDefineScrollPos)\r\n                            refreshScrollbarHandleOffset(isHorizontal, true);\r\n\r\n                        _scrollbarsHandlesDefineScrollPos = false;\r\n                        removeClass(_bodyElement, _classNameDragging);\r\n                        removeClass(scrollbarVars._handle, strActive);\r\n                        removeClass(scrollbarVars._track, strActive);\r\n                        removeClass(scrollbarVars._scrollbar, strActive);\r\n\r\n                        mouseDownScroll = undefined;\r\n                        mouseDownOffset = undefined;\r\n                        mouseDownInvertedScale = 1;\r\n\r\n                        decreaseTrackScrollAmount();\r\n\r\n                        if (trackTimeout !== undefined) {\r\n                            _base.scrollStop();\r\n                            clearTimeout(trackTimeout);\r\n                            trackTimeout = undefined;\r\n                        }\r\n\r\n                        if (event) {\r\n                            var rect = _hostElementNative[LEXICON.bCR]();\r\n                            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom;\r\n\r\n                            //if mouse is outside host element\r\n                            if (!mouseInsideHost)\r\n                                hostOnMouseLeave();\r\n\r\n                            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                                refreshScrollbarsAutoHide(false);\r\n                        }\r\n                    }\r\n                    function onHandleMouseTouchDown(event) {\r\n                        if (onMouseTouchDownContinue(event))\r\n                            onHandleMouseTouchDownAction(event);\r\n                    }\r\n                    function onHandleMouseTouchDownAction(event) {\r\n                        mouseDownScroll = _viewportElement[scroll]();\r\n                        mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;\r\n                        if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL)\r\n                            mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;\r\n\r\n                        mouseDownInvertedScale = getHostElementInvertedScale()[xy];\r\n                        mouseDownOffset = getPointerPosition(event);\r\n\r\n                        _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);\r\n                        addClass(_bodyElement, _classNameDragging);\r\n                        addClass(scrollbarVars._handle, strActive);\r\n                        addClass(scrollbarVars._scrollbar, strActive);\r\n\r\n                        setupResponsiveEventListener(_documentElement,\r\n                            [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent],\r\n                            [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);\r\n                        COMPATIBILITY.rAF()(function() {\r\n                            setupResponsiveEventListener(_documentElement, strClickEvent, stopClickEventPropagation, false, { _capture: true });\r\n                        });\r\n                        \r\n\r\n                        if (_msieVersion || !_documentMixed)\r\n                            COMPATIBILITY.prvD(event);\r\n                        COMPATIBILITY.stpP(event);\r\n                    }\r\n                    function onTrackMouseTouchDown(event) {\r\n                        if (onMouseTouchDownContinue(event)) {\r\n                            var handleToViewportRatio = scrollbarVars._info._handleLength / Math.round(MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]) * scrollbarVars._info._trackLength);\r\n                            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h] * handleToViewportRatio);\r\n                            var scrollBaseDuration = 270 * handleToViewportRatio;\r\n                            var scrollFirstIterationDelay = 400 * handleToViewportRatio;\r\n                            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];\r\n                            var ctrlKey = event.ctrlKey;\r\n                            var instantScroll = event.shiftKey;\r\n                            var instantScrollTransition = instantScroll && ctrlKey;\r\n                            var isFirstIteration = true;\r\n                            var easing = 'linear';\r\n                            var decreaseScroll;\r\n                            var finishedCondition;\r\n                            var scrollActionFinsished = function (transition) {\r\n                                if (_scrollbarsHandlesDefineScrollPos)\r\n                                    refreshScrollbarHandleOffset(isHorizontal, transition);\r\n                            };\r\n                            var scrollActionInstantFinished = function () {\r\n                                scrollActionFinsished();\r\n                                onHandleMouseTouchDownAction(event);\r\n                            };\r\n                            var scrollAction = function () {\r\n                                if (!_destroyed) {\r\n                                    var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;\r\n                                    var handleOffset = scrollbarVarsInfo._handleOffset;\r\n                                    var trackLength = scrollbarVarsInfo._trackLength;\r\n                                    var handleLength = scrollbarVarsInfo._handleLength;\r\n                                    var scrollRange = scrollbarVarsInfo._maxScroll;\r\n                                    var currScroll = scrollbarVarsInfo._currentScroll;\r\n                                    var scrollDuration = scrollBaseDuration * scrollDurationFactor;\r\n                                    var timeoutDelay = isFirstIteration ? MATH.max(scrollFirstIterationDelay, scrollDuration) : scrollDuration;\r\n                                    var instantScrollPosition = scrollRange * ((mouseOffset - (handleLength / 2)) / (trackLength - handleLength)); // 100% * positionPercent\r\n                                    var rtlIsNormal = _isRTL && isHorizontal && ((!_rtlScrollBehavior.i && !_rtlScrollBehavior.n) || _normalizeRTLCache);\r\n                                    var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;\r\n                                    var scrollObj = {};\r\n                                    var animationObj = {\r\n                                        easing: easing,\r\n                                        step: function (now) {\r\n                                            if (_scrollbarsHandlesDefineScrollPos) {\r\n                                                _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340\r\n                                                refreshScrollbarHandleOffset(isHorizontal, now);\r\n                                            }\r\n                                        }\r\n                                    };\r\n                                    instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;\r\n                                    instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;\r\n\r\n                                    //_base.scrollStop();\r\n\r\n                                    if (instantScroll) {\r\n                                        _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position\r\n                                        if (instantScrollTransition) {\r\n                                            //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position\r\n                                            //and the animation stops at the correct point\r\n                                            instantScrollPosition = _viewportElement[scroll]();\r\n                                            //scroll back to the position before instant scrolling so animation can be performed\r\n                                            _viewportElement[scroll](currScroll);\r\n\r\n                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? (scrollRange - instantScrollPosition) : instantScrollPosition;\r\n                                            instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;\r\n\r\n                                            scrollObj[xy] = instantScrollPosition;\r\n                                            _base.scroll(scrollObj, extendDeep(animationObj, {\r\n                                                duration: 130,\r\n                                                complete: scrollActionInstantFinished\r\n                                            }));\r\n                                        }\r\n                                        else\r\n                                            scrollActionInstantFinished();\r\n                                    }\r\n                                    else {\r\n                                        decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;\r\n                                        finishedCondition = rtlIsNormal\r\n                                            ? (decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset)\r\n                                            : (decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset);\r\n\r\n                                        if (finishedCondition) {\r\n                                            clearTimeout(trackTimeout);\r\n                                            _base.scrollStop();\r\n                                            trackTimeout = undefined;\r\n                                            scrollActionFinsished(true);\r\n                                        }\r\n                                        else {\r\n                                            trackTimeout = setTimeout(scrollAction, timeoutDelay);\r\n\r\n                                            scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;\r\n                                            _base.scroll(scrollObj, extendDeep(animationObj, {\r\n                                                duration: scrollDuration\r\n                                            }));\r\n                                        }\r\n                                        isFirstIteration = false;\r\n                                    }\r\n                                }\r\n                            };\r\n                            if (ctrlKey)\r\n                                increaseTrackScrollAmount();\r\n\r\n                            mouseDownInvertedScale = getHostElementInvertedScale()[xy];\r\n                            mouseDownOffset = COMPATIBILITY.page(event)[xy];\r\n\r\n                            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);\r\n                            addClass(_bodyElement, _classNameDragging);\r\n                            addClass(scrollbarVars._track, strActive);\r\n                            addClass(scrollbarVars._scrollbar, strActive);\r\n\r\n                            setupResponsiveEventListener(_documentElement,\r\n                                [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent],\r\n                                [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);\r\n\r\n                            scrollAction();\r\n                            COMPATIBILITY.prvD(event);\r\n                            COMPATIBILITY.stpP(event);\r\n                        }\r\n                    }\r\n                    function onTrackMouseTouchEnter(event) {\r\n                        //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is \"scroll\" or \"move\".\r\n                        _scrollbarsHandleHovered = true;\r\n                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                            refreshScrollbarsAutoHide(true);\r\n                    }\r\n                    function onTrackMouseTouchLeave(event) {\r\n                        _scrollbarsHandleHovered = false;\r\n                        if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove)\r\n                            refreshScrollbarsAutoHide(false);\r\n                    }\r\n                    function onScrollbarMouseTouchDown(event) {\r\n                        COMPATIBILITY.stpP(event);\r\n                    }\r\n\r\n                    addDestroyEventListener(scrollbarVars._handle,\r\n                        _strMouseTouchDownEvent,\r\n                        onHandleMouseTouchDown);\r\n                    addDestroyEventListener(scrollbarVars._track,\r\n                        [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave],\r\n                        [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);\r\n                    addDestroyEventListener(scrollbarVars._scrollbar,\r\n                        _strMouseTouchDownEvent,\r\n                        onScrollbarMouseTouchDown);\r\n\r\n                    if (_supportTransition) {\r\n                        addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {\r\n                            if (event.target !== scrollbarVars._scrollbar[0])\r\n                                return;\r\n                            refreshScrollbarHandleLength(isHorizontal);\r\n                            refreshScrollbarHandleOffset(isHorizontal);\r\n                        });\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.\r\n                 * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.\r\n                 * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.\r\n                 * @param canScroll True if the scrollbar is scrollable, false otherwise.\r\n                 */\r\n                function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {\r\n                    var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;\r\n                    var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;\r\n\r\n                    addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);\r\n                    addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);\r\n                }\r\n\r\n                /**\r\n                 * Autoshows / autohides both scrollbars with.\r\n                 * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.\r\n                 * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.\r\n                 */\r\n                function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {\r\n                    clearTimeout(_scrollbarsAutoHideTimeoutId);\r\n                    if (shallBeVisible) {\r\n                        //if(_hasOverflowCache.x && _hideOverflowCache.xs)\r\n                        removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);\r\n                        //if(_hasOverflowCache.y && _hideOverflowCache.ys)\r\n                        removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);\r\n                    }\r\n                    else {\r\n                        var anyActive;\r\n                        var strActive = 'active';\r\n                        var hide = function () {\r\n                            if (!_scrollbarsHandleHovered && !_destroyed) {\r\n                                anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);\r\n                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))\r\n                                    addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);\r\n                                if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave))\r\n                                    addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);\r\n                            }\r\n                        };\r\n                        if (_scrollbarsAutoHideDelay > 0 && delayfree !== true)\r\n                            _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);\r\n                        else\r\n                            hide();\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Refreshes the handle length of the given scrollbar.\r\n                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.\r\n                 */\r\n                function refreshScrollbarHandleLength(isHorizontal) {\r\n                    var handleCSS = {};\r\n                    var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                    var scrollbarVarsInfo = scrollbarVars._info;\r\n                    var digit = 1000000;\r\n                    //get and apply intended handle length\r\n                    var handleRatio = MATH.min(1, _viewportSize[scrollbarVars._w_h] / _contentScrollSizeCache[scrollbarVars._w_h]);\r\n                    handleCSS[scrollbarVars._width_height] = (MATH.floor(handleRatio * 100 * digit) / digit) + '%'; //the last * digit / digit is for flooring to the 4th digit\r\n\r\n                    if (!nativeOverlayScrollbarsAreActive())\r\n                        scrollbarVars._handle.css(handleCSS);\r\n\r\n                    //measure the handle length to respect min & max length\r\n                    scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];\r\n                    scrollbarVarsInfo._handleLengthRatio = handleRatio;\r\n                }\r\n\r\n                /**\r\n                 * Refreshes the handle offset of the given scrollbar.\r\n                 * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.\r\n                 * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)\r\n                 */\r\n                function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {\r\n                    var transition = type(scrollOrTransition) == TYPES.b;\r\n                    var transitionDuration = 250;\r\n                    var isRTLisHorizontal = _isRTL && isHorizontal;\r\n                    var scrollbarVars = getScrollbarVars(isHorizontal);\r\n                    var scrollbarVarsInfo = scrollbarVars._info;\r\n                    var strTranslateBrace = 'translate(';\r\n                    var strTransform = VENDORS._cssProperty('transform');\r\n                    var strTransition = VENDORS._cssProperty('transition');\r\n                    var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();\r\n                    var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition;\r\n\r\n                    //measure the handle length to respect min & max length\r\n                    var handleLength = scrollbarVarsInfo._handleLength;\r\n                    var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];\r\n                    var handleTrackDiff = trackLength - handleLength;\r\n                    var handleCSS = {};\r\n                    var transformOffset;\r\n                    var translateValue;\r\n\r\n                    //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'\r\n                    // because its a bit behind during the small delay when content size updates\r\n                    //(delay = mutationObserverContentLag, if its 0 then this var could be used)\r\n                    var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative\r\n                    var getScrollRatio = function (base) {\r\n                        return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));\r\n                    };\r\n                    var getHandleOffset = function (scrollRatio) {\r\n                        var offset = handleTrackDiff * scrollRatio;\r\n                        offset = isNaN(offset) ? 0 : offset;\r\n                        offset = (isRTLisHorizontal && !_rtlScrollBehavior.i) ? (trackLength - handleLength - offset) : offset;\r\n                        offset = MATH.max(0, offset);\r\n                        return offset;\r\n                    };\r\n                    var scrollRatio = getScrollRatio(nativeScroll);\r\n                    var unsnappedScrollRatio = getScrollRatio(currentScroll);\r\n                    var handleOffset = getHandleOffset(unsnappedScrollRatio);\r\n                    var snappedHandleOffset = getHandleOffset(scrollRatio);\r\n\r\n                    scrollbarVarsInfo._maxScroll = maxScroll;\r\n                    scrollbarVarsInfo._currentScroll = nativeScroll;\r\n                    scrollbarVarsInfo._currentScrollRatio = scrollRatio;\r\n\r\n                    if (_supportTransform) {\r\n                        transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px\r\n                        //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %\r\n                        translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';\r\n\r\n                        handleCSS[strTransform] = translateValue;\r\n\r\n                        //apply or clear up transition\r\n                        if (_supportTransition)\r\n                            handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;\r\n                    }\r\n                    else\r\n                        handleCSS[scrollbarVars._left_top] = handleOffset;\r\n\r\n\r\n                    //only apply css if offset has changed and overflow exists.\r\n                    if (!nativeOverlayScrollbarsAreActive()) {\r\n                        scrollbarVars._handle.css(handleCSS);\r\n\r\n                        //clear up transition\r\n                        if (_supportTransform && _supportTransition && transition) {\r\n                            scrollbarVars._handle.one(_strTransitionEndEvent, function () {\r\n                                if (!_destroyed)\r\n                                    scrollbarVars._handle.css(strTransition, _strEmpty);\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    scrollbarVarsInfo._handleOffset = handleOffset;\r\n                    scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;\r\n                    scrollbarVarsInfo._trackLength = trackLength;\r\n                }\r\n\r\n                /**\r\n                 * Refreshes the interactivity of the given scrollbar element.\r\n                 * @param isTrack True if the track element is the target, false if the handle element is the target.\r\n                 * @param value True for interactivity false for no interactivity.\r\n                 */\r\n                function refreshScrollbarsInteractive(isTrack, value) {\r\n                    var action = value ? 'removeClass' : 'addClass';\r\n                    var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;\r\n                    var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;\r\n                    var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;\r\n\r\n                    element1[action](className);\r\n                    element2[action](className);\r\n                }\r\n\r\n                /**\r\n                 * Returns a object which is used for fast access for specific variables.\r\n                 * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.\r\n                 * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}\r\n                 */\r\n                function getScrollbarVars(isHorizontal) {\r\n                    return {\r\n                        _width_height: isHorizontal ? _strWidth : _strHeight,\r\n                        _Width_Height: isHorizontal ? 'Width' : 'Height',\r\n                        _left_top: isHorizontal ? _strLeft : _strTop,\r\n                        _Left_Top: isHorizontal ? 'Left' : 'Top',\r\n                        _x_y: isHorizontal ? _strX : _strY,\r\n                        _X_Y: isHorizontal ? 'X' : 'Y',\r\n                        _w_h: isHorizontal ? 'w' : 'h',\r\n                        _l_t: isHorizontal ? 'l' : 't',\r\n                        _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,\r\n                        _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,\r\n                        _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,\r\n                        _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo\r\n                    };\r\n                }\r\n\r\n\r\n                //==== Scrollbar Corner ====//\r\n\r\n                /**\r\n                 * Builds or destroys the scrollbar corner DOM element.\r\n                 * @param destroy Indicates whether the DOM shall be build or destroyed.\r\n                 */\r\n                function setupScrollbarCornerDOM(destroy) {\r\n                    _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);\r\n\r\n                    if (!destroy) {\r\n                        if (!_domExists) {\r\n                            _hostElement.append(_scrollbarCornerElement);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (_domExists && _initialized) {\r\n                            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);\r\n                        }\r\n                        else {\r\n                            remove(_scrollbarCornerElement);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                /**\r\n                 * Initializes all scrollbar corner interactivity events.\r\n                 */\r\n                function setupScrollbarCornerEvents() {\r\n                    var insideIFrame = _windowElementNative.top !== _windowElementNative;\r\n                    var mouseDownPosition = {};\r\n                    var mouseDownSize = {};\r\n                    var mouseDownInvertedScale = {};\r\n                    var reconnectMutationObserver;\r\n\r\n                    function documentDragMove(event) {\r\n                        if (onMouseTouchDownContinue(event)) {\r\n                            var pageOffset = getCoordinates(event);\r\n                            var hostElementCSS = {};\r\n                            if (_resizeHorizontal || _resizeBoth)\r\n                                hostElementCSS[_strWidth] = (mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x);\r\n                            if (_resizeVertical || _resizeBoth)\r\n                                hostElementCSS[_strHeight] = (mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y);\r\n                            _hostElement.css(hostElementCSS);\r\n                            COMPATIBILITY.stpP(event);\r\n                        }\r\n                        else {\r\n                            documentMouseTouchUp(event);\r\n                        }\r\n                    }\r\n                    function documentMouseTouchUp(event) {\r\n                        var eventIsTrusted = event !== undefined;\r\n\r\n                        setupResponsiveEventListener(_documentElement,\r\n                            [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],\r\n                            [documentOnSelectStart, documentDragMove, documentMouseTouchUp],\r\n                            true);\r\n\r\n                        removeClass(_bodyElement, _classNameDragging);\r\n                        if (_scrollbarCornerElement.releaseCapture)\r\n                            _scrollbarCornerElement.releaseCapture();\r\n\r\n                        if (eventIsTrusted) {\r\n                            if (reconnectMutationObserver)\r\n                                connectMutationObservers();\r\n                            _base.update(_strAuto);\r\n                        }\r\n                        reconnectMutationObserver = false;\r\n                    }\r\n                    function onMouseTouchDownContinue(event) {\r\n                        var originalEvent = event.originalEvent || event;\r\n                        var isTouchEvent = originalEvent.touches !== undefined;\r\n                        return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;\r\n                    }\r\n                    function getCoordinates(event) {\r\n                        return _msieVersion && insideIFrame ? { x: event.screenX, y: event.screenY } : COMPATIBILITY.page(event);\r\n                    }\r\n\r\n                    addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {\r\n                        if (onMouseTouchDownContinue(event) && !_resizeNone) {\r\n                            if (_mutationObserversConnected) {\r\n                                reconnectMutationObserver = true;\r\n                                disconnectMutationObservers();\r\n                            }\r\n\r\n                            mouseDownPosition = getCoordinates(event);\r\n\r\n                            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);\r\n                            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);\r\n                            mouseDownInvertedScale = getHostElementInvertedScale();\r\n\r\n                            setupResponsiveEventListener(_documentElement,\r\n                                [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent],\r\n                                [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);\r\n\r\n                            addClass(_bodyElement, _classNameDragging);\r\n                            if (_scrollbarCornerElement.setCapture)\r\n                                _scrollbarCornerElement.setCapture();\r\n\r\n                            COMPATIBILITY.prvD(event);\r\n                            COMPATIBILITY.stpP(event);\r\n                        }\r\n                    });\r\n                }\r\n\r\n\r\n                //==== Utils ====//\r\n\r\n                /**\r\n                 * Calls the callback with the given name. The Context of this callback is always _base (this).\r\n                 * @param name The name of the target which shall be called.\r\n                 * @param args The args with which the callback shall be called.\r\n                 * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a \"true\" value.\r\n                 */\r\n                function dispatchCallback(name, args, dependent) {\r\n                    if (dependent === false)\r\n                        return;\r\n                    if (_initialized) {\r\n                        var callback = _currentPreparedOptions.callbacks[name];\r\n                        var extensionOnName = name;\r\n                        var ext;\r\n\r\n                        if (extensionOnName.substr(0, 2) === 'on')\r\n                            extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);\r\n\r\n                        if (type(callback) == TYPES.f)\r\n                            callback.call(_base, args);\r\n\r\n                        each(_extensions, function () {\r\n                            ext = this;\r\n                            if (type(ext.on) == TYPES.f)\r\n                                ext.on(extensionOnName, args);\r\n                        });\r\n                    }\r\n                    else if (!_destroyed)\r\n                        _callbacksInitQeueue.push({ n: name, a: args });\r\n                }\r\n\r\n                /**\r\n                 * Sets the \"top, right, bottom, left\" properties, with a given prefix, of the given css object.\r\n                 * @param targetCSSObject The css object to which the values shall be applied.\r\n                 * @param prefix The prefix of the \"top, right, bottom, left\" css properties. (example: 'padding-' is a valid prefix)\r\n                 * @param values A array of values which shall be applied to the \"top, right, bottom, left\" -properties. The array order is [top, right, bottom, left].\r\n                 * If this argument is undefined the value '' (empty string) will be applied to all properties.\r\n                 */\r\n                function setTopRightBottomLeft(targetCSSObject, prefix, values) {\r\n                    prefix = prefix || _strEmpty;\r\n                    values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];\r\n\r\n                    targetCSSObject[prefix + _strTop] = values[0];\r\n                    targetCSSObject[prefix + _strRight] = values[1];\r\n                    targetCSSObject[prefix + _strBottom] = values[2];\r\n                    targetCSSObject[prefix + _strLeft] = values[3];\r\n                }\r\n\r\n                /**\r\n                 * Gets the \"top, right, bottom, left\" CSS properties of the CSS property with the given prefix from the host element.\r\n                 * @param prefix The prefix of the \"top, right, bottom, left\" css properties. (example: 'padding-' is a valid prefix)\r\n                 * @param suffix The suffix of the \"top, right, bottom, left\" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)\r\n                 * @param zeroX True if the x axis shall be 0.\r\n                 * @param zeroY True if the y axis shall be 0.\r\n                 * @returns {{}} The object which contains the numbers of the read CSS properties.\r\n                 */\r\n                function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {\r\n                    suffix = suffix || _strEmpty;\r\n                    prefix = prefix || _strEmpty;\r\n                    return {\r\n                        t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),\r\n                        r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),\r\n                        b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),\r\n                        l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))\r\n                    };\r\n                }\r\n\r\n                /**\r\n                 * Returns the computed CSS transition string from the given element.\r\n                 * @param element The element from which the transition string shall be returned.\r\n                 * @returns {string} The CSS transition string from the given element.\r\n                 */\r\n                function getCSSTransitionString(element) {\r\n                    var transitionStr = VENDORS._cssProperty('transition');\r\n                    var assembledValue = element.css(transitionStr);\r\n                    if (assembledValue)\r\n                        return assembledValue;\r\n                    var regExpString = '\\\\s*(' + '([^,(]+(\\\\(.+?\\\\))?)+' + ')[\\\\s,]*';\r\n                    var regExpMain = new RegExp(regExpString);\r\n                    var regExpValidate = new RegExp('^(' + regExpString + ')+$');\r\n                    var properties = 'property duration timing-function delay'.split(' ');\r\n                    var result = [];\r\n                    var strResult;\r\n                    var valueArray;\r\n                    var i = 0;\r\n                    var j;\r\n                    var splitCssStyleByComma = function (str) {\r\n                        strResult = [];\r\n                        if (!str.match(regExpValidate))\r\n                            return str;\r\n                        while (str.match(regExpMain)) {\r\n                            strResult.push(RegExp.$1);\r\n                            str = str.replace(regExpMain, _strEmpty);\r\n                        }\r\n\r\n                        return strResult;\r\n                    };\r\n                    for (; i < properties[LEXICON.l]; i++) {\r\n                        valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));\r\n                        for (j = 0; j < valueArray[LEXICON.l]; j++)\r\n                            result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];\r\n                    }\r\n                    return result.join(', ');\r\n                }\r\n\r\n                /**\r\n                 * Generates a Regular Expression which matches with a string which starts with 'os-host'.\r\n                 * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).\r\n                 * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).\r\n                 */\r\n                function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {\r\n                    var i;\r\n                    var split;\r\n                    var appendix;\r\n                    var appendClasses = function (classes, condition) {\r\n                        appendix = '';\r\n                        if (condition && typeof classes == TYPES.s) {\r\n                            split = classes.split(_strSpace);\r\n                            for (i = 0; i < split[LEXICON.l]; i++)\r\n                                appendix += '|' + split[i] + '$';\r\n                            // split[i].replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&') for escaping regex characters\r\n                        }\r\n                        return appendix;\r\n                    };\r\n\r\n                    return new RegExp(\r\n                        '(^' + _classNameHostElement + '([-_].+|)$)' +\r\n                        appendClasses(_classNameCache, withCurrClassNameOption) +\r\n                        appendClasses(_oldClassName, withOldClassNameOption), 'g');\r\n                }\r\n\r\n                /**\r\n                 * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)\r\n                 * @returns {{x: number, y: number}} The scale of the host-element.\r\n                 */\r\n                function getHostElementInvertedScale() {\r\n                    var rect = _paddingElementNative[LEXICON.bCR]();\r\n                    return {\r\n                        x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,\r\n                        y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1\r\n                    };\r\n                }\r\n\r\n                /**\r\n                 * Checks whether the given object is a HTMLElement.\r\n                 * @param o The object which shall be checked.\r\n                 * @returns {boolean} True the given object is a HTMLElement, false otherwise.\r\n                 */\r\n                function isHTMLElement(o) {\r\n                    var strOwnerDocument = 'ownerDocument';\r\n                    var strHTMLElement = 'HTMLElement';\r\n                    var wnd = o && o[strOwnerDocument] ? (o[strOwnerDocument].parentWindow || window) : window;\r\n                    return (\r\n                        typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2\r\n                            o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s\r\n                    );\r\n                }\r\n\r\n                /**\r\n                 * Compares 2 arrays and returns the differences between them as a array.\r\n                 * @param a1 The first array which shall be compared.\r\n                 * @param a2 The second array which shall be compared.\r\n                 * @returns {Array} The differences between the two arrays.\r\n                 */\r\n                function getArrayDifferences(a1, a2) {\r\n                    var a = [];\r\n                    var diff = [];\r\n                    var i;\r\n                    var k;\r\n                    for (i = 0; i < a1.length; i++)\r\n                        a[a1[i]] = true;\r\n                    for (i = 0; i < a2.length; i++) {\r\n                        if (a[a2[i]])\r\n                            delete a[a2[i]];\r\n                        else\r\n                            a[a2[i]] = true;\r\n                    }\r\n                    for (k in a)\r\n                        diff.push(k);\r\n                    return diff;\r\n                }\r\n\r\n                /**\r\n                 * Returns Zero or the number to which the value can be parsed.\r\n                 * @param value The value which shall be parsed.\r\n                 * @param toFloat Indicates whether the number shall be parsed to a float.\r\n                 */\r\n                function parseToZeroOrNumber(value, toFloat) {\r\n                    var num = toFloat ? parseFloat(value) : parseInt(value, 10);\r\n                    return isNaN(num) ? 0 : num;\r\n                }\r\n\r\n                /**\r\n                 * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.\r\n                 * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.\r\n                 */\r\n                function getTextareaInfo() {\r\n                    //read needed values\r\n                    var textareaCursorPosition = _targetElementNative.selectionStart;\r\n                    if (textareaCursorPosition === undefined)\r\n                        return;\r\n\r\n                    var textareaValue = _targetElement.val();\r\n                    var textareaLength = textareaValue[LEXICON.l];\r\n                    var textareaRowSplit = textareaValue.split('\\n');\r\n                    var textareaLastRow = textareaRowSplit[LEXICON.l];\r\n                    var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\\n');\r\n                    var widestRow = 0;\r\n                    var textareaLastCol = 0;\r\n                    var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];\r\n                    var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];\r\n                    var rowCols;\r\n                    var i;\r\n\r\n                    //get widest Row and the last column of the textarea\r\n                    for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {\r\n                        rowCols = textareaRowSplit[i][LEXICON.l];\r\n                        if (rowCols > textareaLastCol) {\r\n                            widestRow = i + 1;\r\n                            textareaLastCol = rowCols;\r\n                        }\r\n                    }\r\n\r\n                    return {\r\n                        _cursorRow: cursorRow, //cursorRow\r\n                        _cursorColumn: cursorCol, //cursorCol\r\n                        _rows: textareaLastRow, //rows\r\n                        _columns: textareaLastCol, //cols\r\n                        _widestRow: widestRow, //wRow\r\n                        _cursorPosition: textareaCursorPosition, //pos\r\n                        _cursorMax: textareaLength //max\r\n                    };\r\n                }\r\n\r\n                /**\r\n                 * Determines whether native overlay scrollbars are active.\r\n                 * @returns {boolean} True if native overlay scrollbars are active, false otherwise.\r\n                 */\r\n                function nativeOverlayScrollbarsAreActive() {\r\n                    return (_ignoreOverlayScrollbarHidingCache && (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y));\r\n                }\r\n\r\n                /**\r\n                 * Gets the element which is used to measure the content size.\r\n                 * @returns {*} TextareaCover if target element is textarea else the ContentElement.\r\n                 */\r\n                function getContentMeasureElement() {\r\n                    return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;\r\n                }\r\n\r\n                /**\r\n                 * Generates a string which represents a HTML div with the given classes or attributes.\r\n                 * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as \"className\".)\r\n                 * @param content The content of the div as string.\r\n                 * @returns {string} The concated string which represents a HTML div and its content.\r\n                 */\r\n                function generateDiv(classesOrAttrs, content) {\r\n                    return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ?\r\n                        'class=\"' + classesOrAttrs + '\"' :\r\n                        (function () {\r\n                            var key;\r\n                            var attrs = _strEmpty;\r\n                            if (FRAMEWORK.isPlainObject(classesOrAttrs)) {\r\n                                for (key in classesOrAttrs)\r\n                                    attrs += (key === 'c' ? 'class' : key) + '=\"' + classesOrAttrs[key] + '\" ';\r\n                            }\r\n                            return attrs;\r\n                        })() :\r\n                        _strEmpty) +\r\n                        '>' +\r\n                        (content || _strEmpty) +\r\n                        '</div>';\r\n                }\r\n\r\n                /**\r\n                 * Selects or generates a div with the given class attribute.\r\n                 * @param className The class names (divided by spaces) of the div which shall be selected or generated.\r\n                 * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)\r\n                 * If its a boolean it decides whether only the children of the host element shall be selected.\r\n                 * @returns {*} The generated or selected element.\r\n                 */\r\n                function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {\r\n                    var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;\r\n                    var selectParent = onlyChildren ? _hostElement : (selectParentOrOnlyChildren || _hostElement);\r\n\r\n                    return (_domExists && !selectParent[LEXICON.l])\r\n                        ? null\r\n                        : _domExists\r\n                            ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\\s/g, _strDot)).eq(0)\r\n                            : FRAMEWORK(generateDiv(className))\r\n                }\r\n\r\n                /**\r\n                 * Gets the value of the given property from the given object.\r\n                 * @param obj The object from which the property value shall be got.\r\n                 * @param path The property of which the value shall be got.\r\n                 * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.\r\n                 */\r\n                function getObjectPropVal(obj, path) {\r\n                    var splits = path.split(_strDot);\r\n                    var i = 0;\r\n                    var val;\r\n                    for (; i < splits.length; i++) {\r\n                        if (!obj[LEXICON.hOP](splits[i]))\r\n                            return;\r\n                        val = obj[splits[i]];\r\n                        if (i < splits.length && type(val) == TYPES.o)\r\n                            obj = val;\r\n                    }\r\n                    return val;\r\n                }\r\n\r\n                /**\r\n                 * Sets the value of the given property from the given object.\r\n                 * @param obj The object from which the property value shall be set.\r\n                 * @param path The property of which the value shall be set.\r\n                 * @param val The value of the property which shall be set.\r\n                 */\r\n                function setObjectPropVal(obj, path, val) {\r\n                    var splits = path.split(_strDot);\r\n                    var splitsLength = splits.length;\r\n                    var i = 0;\r\n                    var extendObj = {};\r\n                    var extendObjRoot = extendObj;\r\n                    for (; i < splitsLength; i++)\r\n                        extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;\r\n                    FRAMEWORK.extend(obj, extendObjRoot, true);\r\n                }\r\n\r\n                /**\t\r\n                 * Runs a action for each selector inside the updateOnLoad option.\t\r\n                 * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).\t\r\n                 */\r\n                function eachUpdateOnLoad(action) {\r\n                    var updateOnLoad = _currentPreparedOptions.updateOnLoad;\r\n                    updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;\r\n\r\n                    if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {\r\n                        each(updateOnLoad, action);\r\n                    }\r\n                }\r\n\r\n\r\n                //==== Utils Cache ====//\r\n\r\n                /**\r\n                 * Compares two values or objects and returns true if they aren't equal.\r\n                 * @param current The first value or object which shall be compared.\r\n                 * @param cache The second value or object which shall be compared.\r\n                 * @param force If true the returned value is always true.\r\n                 * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.\r\n                 */\r\n                function checkCache(current, cache, force) {\r\n                    if (force)\r\n                        return force;\r\n                    if (type(current) == TYPES.o && type(cache) == TYPES.o) {\r\n                        for (var prop in current) {\r\n                            if (prop !== 'c') {\r\n                                if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {\r\n                                    if (checkCache(current[prop], cache[prop]))\r\n                                        return true;\r\n                                }\r\n                                else {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        return current !== cache;\r\n                    }\r\n                    return false;\r\n                }\r\n\r\n\r\n                //==== Shortcuts ====//\r\n\r\n                /**\r\n                 * jQuery extend method shortcut with a appended \"true\" as first argument.\r\n                 */\r\n                function extendDeep() {\r\n                    return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));\r\n                }\r\n\r\n                /**\r\n                 * jQuery addClass method shortcut.\r\n                 */\r\n                function addClass(el, classes) {\r\n                    return _frameworkProto.addClass.call(el, classes);\r\n                }\r\n\r\n                /**\r\n                 * jQuery removeClass method shortcut.\r\n                 */\r\n                function removeClass(el, classes) {\r\n                    return _frameworkProto.removeClass.call(el, classes);\r\n                }\r\n\r\n                /**\r\n                 * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.\r\n                 */\r\n                function addRemoveClass(el, classes, doAdd) {\r\n                    return doAdd ? addClass(el, classes) : removeClass(el, classes);\r\n                }\r\n\r\n                /**\r\n                 * jQuery remove method shortcut.\r\n                 */\r\n                function remove(el) {\r\n                    return _frameworkProto.remove.call(el);\r\n                }\r\n\r\n                /**\r\n                 * Finds the first child element with the given selector of the given element.\r\n                 * @param el The root element from which the selector shall be valid.\r\n                 * @param selector The selector of the searched element.\r\n                 * @returns {*} The first element which is a child of the given element and matches the givens selector.\r\n                 */\r\n                function findFirst(el, selector) {\r\n                    return _frameworkProto.find.call(el, selector).eq(0);\r\n                }\r\n\r\n\r\n                //==== API ====//\r\n\r\n                /**\r\n                 * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.\r\n                 * This behavior can be reset by calling the update method.\r\n                 */\r\n                _base.sleep = function () {\r\n                    _sleeping = true;\r\n                };\r\n\r\n                /**\r\n                 * Updates the plugin and DOM to the current options.\r\n                 * This method should only be called if a update is 100% required.\r\n                 * @param force True if every property shall be updated and the cache shall be ignored.\r\n                 * !INTERNAL USAGE! : force can be a string \"auto\", \"sync\" or \"zoom\" too\r\n                 * if \"auto\" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.\r\n                 * if \"sync\" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.\r\n                 * if \"zoom\" then a update takes place where it's assumed that content and host size changed\r\n                 * @returns {boolean|undefined} \r\n                 * If force is \"sync\" then a boolean is returned which indicates whether a update was needed due to pending changes.\r\n                 * If force is \"auto\" then a boolean is returned whether a update was needed due to attribute or size changes.\r\n                 * undefined otherwise.\r\n                 */\r\n                _base.update = function (force) {\r\n                    if (_destroyed)\r\n                        return;\r\n\r\n                    var attrsChanged;\r\n                    var contentSizeC;\r\n                    var isString = type(force) == TYPES.s;\r\n                    var doUpdateAuto;\r\n                    var mutHost;\r\n                    var mutContent;\r\n\r\n                    if (isString) {\r\n                        if (force === _strAuto) {\r\n                            attrsChanged = meaningfulAttrsChanged();\r\n                            contentSizeC = updateAutoContentSizeChanged();\r\n                            doUpdateAuto = attrsChanged || contentSizeC;\r\n                            if (doUpdateAuto) {\r\n                                update({\r\n                                    _contentSizeChanged: contentSizeC,\r\n                                    _changedOptions: _initialized ? undefined : _currentPreparedOptions\r\n                                });\r\n                            }\r\n                        }\r\n                        else if (force === _strSync) {\r\n                            if (_mutationObserversConnected) {\r\n                                mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());\r\n                                mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());\r\n                            }\r\n                            else {\r\n                                mutHost = _base.update(_strAuto);\r\n                            }\r\n                        }\r\n                        else if (force === 'zoom') {\r\n                            update({\r\n                                _hostSizeChanged: true,\r\n                                _contentSizeChanged: true\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        force = _sleeping || force;\r\n                        _sleeping = false;\r\n                        if (!_base.update(_strSync) || force)\r\n                            update({ _force: force });\r\n                    }\r\n\r\n                    updateElementsOnLoad();\r\n\r\n                    return doUpdateAuto || mutHost || mutContent;\r\n                };\r\n\r\n                /**\r\n                 Gets or sets the current options. The update method will be called automatically if new options were set.\r\n                 * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.\r\n                 * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.\r\n                 * @returns {*}\r\n                 */\r\n                _base.options = function (newOptions, value) {\r\n                    var option = {};\r\n                    var changedOps;\r\n\r\n                    //return current options if newOptions are undefined or empty\r\n                    if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {\r\n                        if (type(newOptions) == TYPES.s) {\r\n                            if (arguments.length > 1) {\r\n                                setObjectPropVal(option, newOptions, value);\r\n                                changedOps = setOptions(option);\r\n                            }\r\n                            else\r\n                                return getObjectPropVal(_currentOptions, newOptions);\r\n                        }\r\n                        else\r\n                            return _currentOptions;\r\n                    }\r\n                    else {\r\n                        changedOps = setOptions(newOptions);\r\n                    }\r\n\r\n                    if (!FRAMEWORK.isEmptyObject(changedOps)) {\r\n                        update({ _changedOptions: changedOps });\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.\r\n                 */\r\n                _base.destroy = function () {\r\n                    if (_destroyed)\r\n                        return;\r\n\r\n                    //remove this instance from auto update loop\r\n                    autoUpdateLoop.remove(_base);\r\n\r\n                    //disconnect all mutation observers\r\n                    disconnectMutationObservers();\r\n\r\n                    //remove all resize observers\r\n                    setupResizeObserver(_sizeObserverElement);\r\n                    setupResizeObserver(_sizeAutoObserverElement);\r\n\r\n                    //remove all extensions\r\n                    for (var extName in _extensions)\r\n                        _base.removeExt(extName);\r\n\r\n                    //remove all 'destroy' events\r\n                    while (_destroyEvents[LEXICON.l] > 0)\r\n                        _destroyEvents.pop()();\r\n\r\n                    //remove all events from host element\r\n                    setupHostMouseTouchEvents(true);\r\n\r\n                    //remove all helper / detection elements\r\n                    if (_contentGlueElement)\r\n                        remove(_contentGlueElement);\r\n                    if (_contentArrangeElement)\r\n                        remove(_contentArrangeElement);\r\n                    if (_sizeAutoObserverAdded)\r\n                        remove(_sizeAutoObserverElement);\r\n\r\n                    //remove all generated DOM\r\n                    setupScrollbarsDOM(true);\r\n                    setupScrollbarCornerDOM(true);\r\n                    setupStructureDOM(true);\r\n\r\n                    //remove all generated image load events\r\n                    for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++)\r\n                        FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);\r\n                    _updateOnLoadElms = undefined;\r\n\r\n                    _destroyed = true;\r\n                    _sleeping = true;\r\n\r\n                    //remove this instance from the instances list\r\n                    INSTANCES(pluginTargetElement, 0);\r\n                    dispatchCallback('onDestroyed');\r\n\r\n                    //remove all properties and methods\r\n                    //for (var property in _base)\r\n                    //    delete _base[property];\r\n                    //_base = undefined;\r\n                };\r\n\r\n                /**\r\n                 * Scrolls to a given position or element.\r\n                 * @param coordinates\r\n                 * 1. Can be \"coordinates\" which looks like:\r\n                 *    { x : ?, y : ? } OR          Object with x and y properties\r\n                 *    { left : ?, top : ? } OR     Object with left and top properties\r\n                 *    { l : ?, t : ? } OR          Object with l and t properties\r\n                 *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)\r\n                 *    ?                            A single value which stays for both axis\r\n                 *    A value can be a number, a string or a calculation.\r\n                 *\r\n                 *    Operators:\r\n                 *    [NONE]  The current scroll will be overwritten by the value.\r\n                 *    '+='    The value will be added to the current scroll offset\r\n                 *    '-='    The value will be subtracted from the current scroll offset\r\n                 *    '*='    The current scroll wil be multiplicated by the value.\r\n                 *    '/='    The current scroll wil be divided by the value.\r\n                 *\r\n                 *    Units:\r\n                 *    [NONE]  The value is the final scroll amount.                   final = (value * 1)\r\n                 *    'px'    Same as none\r\n                 *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)\r\n                 *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)\r\n                 *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)\r\n                 *\r\n                 *    example final values:\r\n                 *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'\r\n                 *\r\n                 * 2. Can be a HTML or jQuery element:\r\n                 *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.\r\n                 *\r\n                 * 3. Can be a object with a HTML or jQuery element with additional settings:\r\n                 *    {\r\n                 *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.\r\n                 *      scroll : [string, array, object],               Default value is 'always'.\r\n                 *      block : [string, array, object],                Default value is 'begin'.\r\n                 *      margin : [number, boolean, array, object]       Default value is false.\r\n                 *    }\r\n                 *\r\n                 *    Possible scroll settings are:\r\n                 *    'always'      Scrolls always.\r\n                 *    'ifneeded'    Scrolls only if the element isnt fully in view.\r\n                 *    'never'       Scrolls never.\r\n                 *\r\n                 *    Possible block settings are:\r\n                 *    'begin'   Both axis shall be docked to the \"begin\" edge. - The element will be docked to the top and left edge of the viewport.\r\n                 *    'end'     Both axis shall be docked to the \"end\" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)\r\n                 *    'center'  Both axis shall be docked to \"center\". - The element will be centered in the viewport.\r\n                 *    'nearest' The element will be docked to the nearest edge(s).\r\n                 *\r\n                 *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.\r\n                 *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.\r\n                 *    [NUMBER]                                          The margin will be used for all edges.\r\n                 *\r\n                 * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.\r\n                 * @param easing The animation easing.\r\n                 * @param complete The animation complete callback.\r\n                 * @returns {{\r\n                 *   position: {x: number, y: number},\r\n                 *   ratio: {x: number, y: number},\r\n                 *   max: {x: number, y: number},\r\n                 *   handleOffset: {x: number, y: number},\r\n                 *   handleLength: {x: number, y: number},\r\n                 *   handleLengthRatio: {x: number, y: number}, t\r\n                 *   rackLength: {x: number, y: number},\r\n                 *   isRTL: boolean,\r\n                 *   isRTLNormalized: boolean\r\n                 *  }}\r\n                 */\r\n                _base.scroll = function (coordinates, duration, easing, complete) {\r\n                    if (arguments.length === 0 || coordinates === undefined) {\r\n                        var infoX = _scrollHorizontalInfo;\r\n                        var infoY = _scrollVerticalInfo;\r\n                        var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;\r\n                        var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;\r\n                        var scrollX = infoX._currentScroll;\r\n                        var scrollXRatio = infoX._currentScrollRatio;\r\n                        var maxScrollX = infoX._maxScroll;\r\n                        scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;\r\n                        scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;\r\n                        scrollX *= normalizeNegate ? -1 : 1;\r\n                        maxScrollX *= normalizeNegate ? -1 : 1;\r\n\r\n                        return {\r\n                            position: {\r\n                                x: scrollX,\r\n                                y: infoY._currentScroll\r\n                            },\r\n                            ratio: {\r\n                                x: scrollXRatio,\r\n                                y: infoY._currentScrollRatio\r\n                            },\r\n                            max: {\r\n                                x: maxScrollX,\r\n                                y: infoY._maxScroll\r\n                            },\r\n                            handleOffset: {\r\n                                x: infoX._handleOffset,\r\n                                y: infoY._handleOffset\r\n                            },\r\n                            handleLength: {\r\n                                x: infoX._handleLength,\r\n                                y: infoY._handleLength\r\n                            },\r\n                            handleLengthRatio: {\r\n                                x: infoX._handleLengthRatio,\r\n                                y: infoY._handleLengthRatio\r\n                            },\r\n                            trackLength: {\r\n                                x: infoX._trackLength,\r\n                                y: infoY._trackLength\r\n                            },\r\n                            snappedHandleOffset: {\r\n                                x: infoX._snappedHandleOffset,\r\n                                y: infoY._snappedHandleOffset\r\n                            },\r\n                            isRTL: _isRTL,\r\n                            isRTLNormalized: _normalizeRTLCache\r\n                        };\r\n                    }\r\n\r\n                    _base.update(_strSync);\r\n\r\n                    var normalizeRTL = _normalizeRTLCache;\r\n                    var coordinatesXAxisProps = [_strX, _strLeft, 'l'];\r\n                    var coordinatesYAxisProps = [_strY, _strTop, 't'];\r\n                    var coordinatesOperators = ['+=', '-=', '*=', '/='];\r\n                    var durationIsObject = type(duration) == TYPES.o;\r\n                    var completeCallback = durationIsObject ? duration.complete : complete;\r\n                    var i;\r\n                    var finalScroll = {};\r\n                    var specialEasing = {};\r\n                    var doScrollLeft;\r\n                    var doScrollTop;\r\n                    var animationOptions;\r\n                    var strEnd = 'end';\r\n                    var strBegin = 'begin';\r\n                    var strCenter = 'center';\r\n                    var strNearest = 'nearest';\r\n                    var strAlways = 'always';\r\n                    var strNever = 'never';\r\n                    var strIfNeeded = 'ifneeded';\r\n                    var strLength = LEXICON.l;\r\n                    var settingsAxis;\r\n                    var settingsScroll;\r\n                    var settingsBlock;\r\n                    var settingsMargin;\r\n                    var finalElement;\r\n                    var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];\r\n                    var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];\r\n                    var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];\r\n                    var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');\r\n                    var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;\r\n                    var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;\r\n                    var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);\r\n                    var updateScrollbarInfos = function () {\r\n                        if (doScrollLeft)\r\n                            refreshScrollbarHandleOffset(true);\r\n                        if (doScrollTop)\r\n                            refreshScrollbarHandleOffset(false);\r\n                    };\r\n                    var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {\r\n                        updateScrollbarInfos();\r\n                        completeCallback();\r\n                    };\r\n                    function checkSettingsStringValue(currValue, allowedValues) {\r\n                        for (i = 0; i < allowedValues[strLength]; i++) {\r\n                            if (currValue === allowedValues[i])\r\n                                return true;\r\n                        }\r\n                        return false;\r\n                    }\r\n                    function getRawScroll(isX, coordinates) {\r\n                        var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;\r\n                        coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;\r\n\r\n                        if (COMPATIBILITY.isA(coordinates))\r\n                            return isX ? coordinates[0] : coordinates[1];\r\n                        else if (type(coordinates) == TYPES.o) {\r\n                            //decides RTL normalization \"hack\" with .n\r\n                            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL; \r\n                            for (i = 0; i < coordinateProps[strLength]; i++)\r\n                                if (coordinateProps[i] in coordinates)\r\n                                    return coordinates[coordinateProps[i]];\r\n                        }\r\n                    }\r\n                    function getFinalScroll(isX, rawScroll) {\r\n                        var isString = type(rawScroll) == TYPES.s;\r\n                        var operator;\r\n                        var amount;\r\n                        var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;\r\n                        var currScroll = scrollInfo._currentScroll;\r\n                        var maxScroll = scrollInfo._maxScroll;\r\n                        var mult = ' * ';\r\n                        var finalValue;\r\n                        var isRTLisX = _isRTL && isX;\r\n                        var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;\r\n                        var strReplace = 'replace';\r\n                        var evalFunc = eval;\r\n                        var possibleOperator;\r\n                        if (isString) {\r\n                            //check operator\r\n                            if (rawScroll[strLength] > 2) {\r\n                                possibleOperator = rawScroll.substr(0, 2);\r\n                                if (inArray(possibleOperator, coordinatesOperators) > -1)\r\n                                    operator = possibleOperator;\r\n                            }\r\n\r\n                            //calculate units and shortcuts\r\n                            rawScroll = operator ? rawScroll.substr(2) : rawScroll;\r\n                            rawScroll = rawScroll\r\n                            [strReplace](/min/g, 0) //'min' = 0%\r\n                            [strReplace](/</g, 0)   //'<'   = 0%\r\n                            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)    //'max' = 100%\r\n                            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent)      //'>'   = 100%\r\n                            [strReplace](/px/g, _strEmpty)\r\n                            [strReplace](/%/g, mult + (maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0))\r\n                            [strReplace](/vw/g, mult + _viewportSize.w)\r\n                            [strReplace](/vh/g, mult + _viewportSize.h);\r\n                            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);\r\n                        }\r\n                        else {\r\n                            amount = rawScroll;\r\n                        }\r\n\r\n                        if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {\r\n                            var normalizeIsRTLisX = normalizeRTL && isRTLisX;\r\n                            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);\r\n                            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;\r\n                            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;\r\n                            operatorCurrScroll = invert ? (maxScroll - operatorCurrScroll) : operatorCurrScroll;\r\n                            switch (operator) {\r\n                                case '+=':\r\n                                    finalValue = operatorCurrScroll + amount;\r\n                                    break;\r\n                                case '-=':\r\n                                    finalValue = operatorCurrScroll - amount;\r\n                                    break;\r\n                                case '*=':\r\n                                    finalValue = operatorCurrScroll * amount;\r\n                                    break;\r\n                                case '/=':\r\n                                    finalValue = operatorCurrScroll / amount;\r\n                                    break;\r\n                                default:\r\n                                    finalValue = amount;\r\n                                    break;\r\n                            }\r\n                            finalValue = invert ? maxScroll - finalValue : finalValue;\r\n                            finalValue *= negate ? -1 : 1;\r\n                            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));\r\n                        }\r\n                        return finalValue === currScroll ? undefined : finalValue;\r\n                    }\r\n                    function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {\r\n                        var resultDefault = [defaultValue, defaultValue];\r\n                        var valueType = type(value);\r\n                        var valueArrLength;\r\n                        var valueArrItem;\r\n\r\n                        //value can be [ string, or array of two strings ]\r\n                        if (valueType == valueInternalType) {\r\n                            value = [value, value];\r\n                        }\r\n                        else if (valueType == TYPES.a) {\r\n                            valueArrLength = value[strLength];\r\n                            if (valueArrLength > 2 || valueArrLength < 1)\r\n                                value = resultDefault;\r\n                            else {\r\n                                if (valueArrLength === 1)\r\n                                    value[1] = defaultValue;\r\n                                for (i = 0; i < valueArrLength; i++) {\r\n                                    valueArrItem = value[i];\r\n                                    if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {\r\n                                        value = resultDefault;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        else if (valueType == TYPES.o)\r\n                            value = [value[_strX] || defaultValue, value[_strY] || defaultValue];\r\n                        else\r\n                            value = resultDefault;\r\n                        return { x: value[0], y: value[1] };\r\n                    }\r\n                    function generateMargin(marginTopRightBottomLeftArray) {\r\n                        var result = [];\r\n                        var currValue;\r\n                        var currValueType;\r\n                        var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];\r\n                        for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {\r\n                            if (i === valueDirections[strLength])\r\n                                break;\r\n                            currValue = marginTopRightBottomLeftArray[i];\r\n                            currValueType = type(currValue);\r\n                            if (currValueType == TYPES.b)\r\n                                result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);\r\n                            else\r\n                                result.push(currValueType == TYPES.n ? currValue : 0);\r\n                        }\r\n                        return result;\r\n                    }\r\n\r\n                    if (possibleElementIsJQuery || possibleElementIsHTMLElement) {\r\n                        //get settings\r\n                        var margin = coordinatesIsElementObj ? coordinates.margin : 0;\r\n                        var axis = coordinatesIsElementObj ? coordinates.axis : 0;\r\n                        var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;\r\n                        var block = coordinatesIsElementObj ? coordinates.block : 0;\r\n                        var marginDefault = [0, 0, 0, 0];\r\n                        var marginType = type(margin);\r\n                        var marginLength;\r\n                        finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);\r\n\r\n                        if (finalElement[strLength] > 0) {\r\n                            //margin can be [ boolean, number, array of 2, array of 4, object ]\r\n                            if (marginType == TYPES.n || marginType == TYPES.b)\r\n                                margin = generateMargin([margin, margin, margin, margin]);\r\n                            else if (marginType == TYPES.a) {\r\n                                marginLength = margin[strLength];\r\n                                if (marginLength === 2)\r\n                                    margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);\r\n                                else if (marginLength >= 4)\r\n                                    margin = generateMargin(margin);\r\n                                else\r\n                                    margin = marginDefault;\r\n                            }\r\n                            else if (marginType == TYPES.o)\r\n                                margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);\r\n                            else\r\n                                margin = marginDefault;\r\n\r\n                            //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;\r\n                            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';\r\n                            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);\r\n                            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);\r\n                            settingsMargin = margin;\r\n\r\n                            var viewportScroll = {\r\n                                l: _scrollHorizontalInfo._currentScroll,\r\n                                t: _scrollVerticalInfo._currentScroll\r\n                            };\r\n                            // use padding element instead of viewport element because padding element has never padding, margin or position applied.\r\n                            var viewportOffset = _paddingElement.offset();\r\n\r\n                            //get coordinates\r\n                            var elementOffset = finalElement.offset();\r\n                            var doNotScroll = {\r\n                                x: settingsScroll.x == strNever || settingsAxis == _strY,\r\n                                y: settingsScroll.y == strNever || settingsAxis == _strX\r\n                            };\r\n                            elementOffset[_strTop] -= settingsMargin[0];\r\n                            elementOffset[_strLeft] -= settingsMargin[3];\r\n                            var elementScrollCoordinates = {\r\n                                x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),\r\n                                y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)\r\n                            };\r\n                            if (_isRTL) {\r\n                                if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i)\r\n                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);\r\n                                if (_rtlScrollBehavior.n && normalizeRTL)\r\n                                    elementScrollCoordinates.x *= -1;\r\n                                if (_rtlScrollBehavior.i && normalizeRTL)\r\n                                    elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));\r\n                            }\r\n\r\n                            //measuring is required\r\n                            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {\r\n                                var measuringElm = finalElement[0];\r\n                                var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {\r\n                                    width: measuringElm[LEXICON.oW],\r\n                                    height: measuringElm[LEXICON.oH]\r\n                                };\r\n                                var elementSize = {\r\n                                    w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],\r\n                                    h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]\r\n                                };\r\n                                var finalizeBlock = function (isX) {\r\n                                    var vars = getScrollbarVars(isX);\r\n                                    var wh = vars._w_h;\r\n                                    var lt = vars._left_top;\r\n                                    var xy = vars._x_y;\r\n                                    var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);\r\n                                    var blockIsCenter = settingsBlock[xy] == strCenter;\r\n                                    var blockIsNearest = settingsBlock[xy] == strNearest;\r\n                                    var scrollNever = settingsScroll[xy] == strNever;\r\n                                    var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;\r\n                                    var vpSize = _viewportSize[wh];\r\n                                    var vpOffset = viewportOffset[lt];\r\n                                    var elSize = elementSize[wh];\r\n                                    var elOffset = elementOffset[lt];\r\n                                    var divide = blockIsCenter ? 2 : 1;\r\n                                    var elementCenterOffset = elOffset + (elSize / 2);\r\n                                    var viewportCenterOffset = vpOffset + (vpSize / 2);\r\n                                    var isInView =\r\n                                        elSize <= vpSize\r\n                                        && elOffset >= vpOffset\r\n                                        && elOffset + elSize <= vpOffset + vpSize;\r\n\r\n                                    if (scrollNever)\r\n                                        doNotScroll[xy] = true;\r\n                                    else if (!doNotScroll[xy]) {\r\n                                        if (blockIsNearest || scrollIfNeeded) {\r\n                                            doNotScroll[xy] = scrollIfNeeded ? isInView : false;\r\n                                            blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;\r\n                                        }\r\n                                        elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? ((vpSize / divide) - (elSize / divide)) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;\r\n                                    }\r\n                                };\r\n                                finalizeBlock(true);\r\n                                finalizeBlock(false);\r\n                            }\r\n\r\n                            if (doNotScroll.y)\r\n                                delete elementScrollCoordinates.y;\r\n                            if (doNotScroll.x)\r\n                                delete elementScrollCoordinates.x;\r\n\r\n                            coordinates = elementScrollCoordinates;\r\n                        }\r\n                    }\r\n\r\n                    finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));\r\n                    finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));\r\n                    doScrollLeft = finalScroll[_strScrollLeft] !== undefined;\r\n                    doScrollTop = finalScroll[_strScrollTop] !== undefined;\r\n\r\n                    if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {\r\n                        if (durationIsObject) {\r\n                            duration.complete = proxyCompleteCallback;\r\n                            _viewportElement.animate(finalScroll, duration);\r\n                        }\r\n                        else {\r\n                            animationOptions = {\r\n                                duration: duration,\r\n                                complete: proxyCompleteCallback\r\n                            };\r\n                            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {\r\n                                specialEasing[_strScrollLeft] = easing[0] || easing.x;\r\n                                specialEasing[_strScrollTop] = easing[1] || easing.y;\r\n                                animationOptions.specialEasing = specialEasing;\r\n                            }\r\n                            else {\r\n                                animationOptions.easing = easing;\r\n                            }\r\n                            _viewportElement.animate(finalScroll, animationOptions);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (doScrollLeft)\r\n                            _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);\r\n                        if (doScrollTop)\r\n                            _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);\r\n                        updateScrollbarInfos();\r\n                    }\r\n                };\r\n\r\n                /**\r\n                 * Stops all scroll animations.\r\n                 * @returns {*} The current OverlayScrollbars instance (for chaining).\r\n                 */\r\n                _base.scrollStop = function (param1, param2, param3) {\r\n                    _viewportElement.stop(param1, param2, param3);\r\n                    return _base;\r\n                };\r\n\r\n                /**\r\n                 * Returns all relevant elements.\r\n                 * @param elementName The name of the element which shall be returned.\r\n                 * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}\r\n                 */\r\n                _base.getElements = function (elementName) {\r\n                    var obj = {\r\n                        target: _targetElementNative,\r\n                        host: _hostElementNative,\r\n                        padding: _paddingElementNative,\r\n                        viewport: _viewportElementNative,\r\n                        content: _contentElementNative,\r\n                        scrollbarHorizontal: {\r\n                            scrollbar: _scrollbarHorizontalElement[0],\r\n                            track: _scrollbarHorizontalTrackElement[0],\r\n                            handle: _scrollbarHorizontalHandleElement[0]\r\n                        },\r\n                        scrollbarVertical: {\r\n                            scrollbar: _scrollbarVerticalElement[0],\r\n                            track: _scrollbarVerticalTrackElement[0],\r\n                            handle: _scrollbarVerticalHandleElement[0]\r\n                        },\r\n                        scrollbarCorner: _scrollbarCornerElement[0]\r\n                    };\r\n                    return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;\r\n                };\r\n\r\n                /**\r\n                 * Returns a object which describes the current state of this instance.\r\n                 * @param stateProperty A specific property from the state object which shall be returned.\r\n                 * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}\r\n                 */\r\n                _base.getState = function (stateProperty) {\r\n                    function prepare(obj) {\r\n                        if (!FRAMEWORK.isPlainObject(obj))\r\n                            return obj;\r\n                        var extended = extendDeep({}, obj);\r\n                        var changePropertyName = function (from, to) {\r\n                            if (extended[LEXICON.hOP](from)) {\r\n                                extended[to] = extended[from];\r\n                                delete extended[from];\r\n                            }\r\n                        };\r\n                        changePropertyName('w', _strWidth); //change w to width\r\n                        changePropertyName('h', _strHeight); //change h to height\r\n                        delete extended.c; //delete c (the 'changed' prop)\r\n                        return extended;\r\n                    };\r\n                    var obj = {\r\n                        destroyed: !!prepare(_destroyed),\r\n                        sleeping: !!prepare(_sleeping),\r\n                        autoUpdate: prepare(!_mutationObserversConnected),\r\n                        widthAuto: prepare(_widthAutoCache),\r\n                        heightAuto: prepare(_heightAutoCache),\r\n                        padding: prepare(_cssPaddingCache),\r\n                        overflowAmount: prepare(_overflowAmountCache),\r\n                        hideOverflow: prepare(_hideOverflowCache),\r\n                        hasOverflow: prepare(_hasOverflowCache),\r\n                        contentScrollSize: prepare(_contentScrollSizeCache),\r\n                        viewportSize: prepare(_viewportSize),\r\n                        hostSize: prepare(_hostSizeCache),\r\n                        documentMixed: prepare(_documentMixed)\r\n                    };\r\n                    return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;\r\n                };\r\n\r\n                /**\r\n                 * Gets all or specific extension instance.\r\n                 * @param extName The name of the extension from which the instance shall be got.\r\n                 * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.\r\n                 */\r\n                _base.ext = function (extName) {\r\n                    var result;\r\n                    var privateMethods = _extensionsPrivateMethods.split(' ');\r\n                    var i = 0;\r\n                    if (type(extName) == TYPES.s) {\r\n                        if (_extensions[LEXICON.hOP](extName)) {\r\n                            result = extendDeep({}, _extensions[extName]);\r\n                            for (; i < privateMethods.length; i++)\r\n                                delete result[privateMethods[i]];\r\n                        }\r\n                    }\r\n                    else {\r\n                        result = {};\r\n                        for (i in _extensions)\r\n                            result[i] = extendDeep({}, _base.ext(i));\r\n                    }\r\n                    return result;\r\n                };\r\n\r\n                /**\r\n                 * Adds a extension to this instance.\r\n                 * @param extName The name of the extension which shall be added.\r\n                 * @param extensionOptions The extension options which shall be used.\r\n                 * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.\r\n                 */\r\n                _base.addExt = function (extName, extensionOptions) {\r\n                    var registeredExtensionObj = _plugin.extension(extName);\r\n                    var instance;\r\n                    var instanceAdded;\r\n                    var instanceContract;\r\n                    var contractResult;\r\n                    var contractFulfilled = true;\r\n                    if (registeredExtensionObj) {\r\n                        if (!_extensions[LEXICON.hOP](extName)) {\r\n                            instance = registeredExtensionObj.extensionFactory.call(_base,\r\n                                extendDeep({}, registeredExtensionObj.defaultOptions),\r\n                                FRAMEWORK,\r\n                                COMPATIBILITY);\r\n\r\n                            if (instance) {\r\n                                instanceContract = instance.contract;\r\n                                if (type(instanceContract) == TYPES.f) {\r\n                                    contractResult = instanceContract(window);\r\n                                    contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;\r\n                                }\r\n                                if (contractFulfilled) {\r\n                                    _extensions[extName] = instance;\r\n                                    instanceAdded = instance.added;\r\n                                    if (type(instanceAdded) == TYPES.f)\r\n                                        instanceAdded(extensionOptions);\r\n\r\n                                    return _base.ext(extName);\r\n                                }\r\n                            }\r\n                        }\r\n                        else\r\n                            return _base.ext(extName);\r\n                    }\r\n                    else\r\n                        console.warn(\"A extension with the name \\\"\" + extName + \"\\\" isn't registered.\");\r\n                };\r\n\r\n                /**\r\n                 * Removes a extension from this instance.\r\n                 * @param extName The name of the extension which shall be removed.\r\n                 * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.\r\n                 */\r\n                _base.removeExt = function (extName) {\r\n                    var instance = _extensions[extName];\r\n                    var instanceRemoved;\r\n                    if (instance) {\r\n                        delete _extensions[extName];\r\n\r\n                        instanceRemoved = instance.removed;\r\n                        if (type(instanceRemoved) == TYPES.f)\r\n                            instanceRemoved();\r\n\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                };\r\n\r\n                /**\r\n                 * Constructs the plugin.\r\n                 * @param targetElement The element to which the plugin shall be applied.\r\n                 * @param options The initial options of the plugin.\r\n                 * @param extensions The extension(s) which shall be added right after the initialization.\r\n                 * @returns {boolean} True if the plugin was successfully initialized, false otherwise.\r\n                 */\r\n                function construct(targetElement, options, extensions) {\r\n                    _defaultOptions = globals.defaultOptions;\r\n                    _nativeScrollbarStyling = globals.nativeScrollbarStyling;\r\n                    _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);\r\n                    _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);\r\n                    _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);\r\n                    _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior);\r\n\r\n                    //parse & set options but don't update\r\n                    setOptions(extendDeep({}, _defaultOptions, options));\r\n\r\n                    _cssCalc = globals.cssCalc;\r\n                    _msieVersion = globals.msie;\r\n                    _autoUpdateRecommended = globals.autoUpdateRecommended;\r\n                    _supportTransition = globals.supportTransition;\r\n                    _supportTransform = globals.supportTransform;\r\n                    _supportPassiveEvents = globals.supportPassiveEvents;\r\n                    _supportResizeObserver = globals.supportResizeObserver;\r\n                    _supportMutationObserver = globals.supportMutationObserver;\r\n                    _restrictedMeasuring = globals.restrictedMeasuring;\r\n                    _documentElement = FRAMEWORK(targetElement.ownerDocument);\r\n                    _documentElementNative = _documentElement[0];\r\n                    _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);\r\n                    _windowElementNative = _windowElement[0];\r\n                    _htmlElement = findFirst(_documentElement, 'html');\r\n                    _bodyElement = findFirst(_htmlElement, 'body');\r\n                    _targetElement = FRAMEWORK(targetElement);\r\n                    _targetElementNative = _targetElement[0];\r\n                    _isTextarea = _targetElement.is('textarea');\r\n                    _isBody = _targetElement.is('body');\r\n                    _documentMixed = _documentElementNative !== document;\r\n\r\n                    /* On a div Element The if checks only whether:\r\n                     * - the targetElement has the class \"os-host\"\r\n                     * - the targetElement has a a child with the class \"os-padding\"\r\n                     * \r\n                     * If that's the case, its assumed the DOM has already the following structure:\r\n                     * (The \".os-host\" element is the targetElement)\r\n                     *\r\n                     *  <div class=\"os-host\">\r\n                     *      <div class=\"os-resize-observer-host\"></div>\r\n                     *      <div class=\"os-padding\">\r\n                     *          <div class=\"os-viewport\">\r\n                     *              <div class=\"os-content\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-horizontal \">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-vertical\">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar-corner\"></div>\r\n                     *  </div>\r\n                     *\r\n                     * =====================================================================================\r\n                     * \r\n                     * On a Textarea Element The if checks only whether:\r\n                     * - the targetElement has the class \"os-textarea\" \r\n                     * - the targetElement is inside a element with the class \"os-content\" \r\n                     * \r\n                     * If that's the case, its assumed the DOM has already the following structure:\r\n                     * (The \".os-textarea\" (textarea) element is the targetElement)\r\n                     *\r\n                     *  <div class=\"os-host-textarea\">\r\n                     *      <div class=\"os-resize-observer-host\"></div>\r\n                     *      <div class=\"os-padding os-text-inherit\">\r\n                     *          <div class=\"os-viewport os-text-inherit\">\r\n                     *              <div class=\"os-content os-text-inherit\">\r\n                     *                  <div class=\"os-textarea-cover\"></div>\r\n                     *                  <textarea class=\"os-textarea os-text-inherit\"></textarea>\r\n                     *              </div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-horizontal \">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar os-scrollbar-vertical\">\r\n                     *          <div class=\"os-scrollbar-track\">\r\n                     *              <div class=\"os-scrollbar-handle\"></div>\r\n                     *          </div>\r\n                     *      </div>\r\n                     *      <div class=\"os-scrollbar-corner\"></div>\r\n                     *  </div>\r\n                     */\r\n                    _domExists = _isTextarea\r\n                        ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement)\r\n                        : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];\r\n\r\n                    var initBodyScroll;\r\n                    var bodyMouseTouchDownListener;\r\n\r\n                    //check if the plugin hasn't to be initialized\r\n                    if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {\r\n                        dispatchCallback('onInitializationWithdrawn');\r\n                        if (_domExists) {\r\n                            setupStructureDOM(true);\r\n                            setupScrollbarsDOM(true);\r\n                            setupScrollbarCornerDOM(true);\r\n                        }\r\n\r\n                        _destroyed = true;\r\n                        _sleeping = true;\r\n\r\n                        return _base;\r\n                    }\r\n\r\n                    if (_isBody) {\r\n                        initBodyScroll = {};\r\n                        initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());\r\n                        initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());\r\n\r\n                        bodyMouseTouchDownListener = function () {\r\n                            _viewportElement.removeAttr(LEXICON.ti);\r\n                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);\r\n                        }\r\n                    }\r\n\r\n                    //build OverlayScrollbars DOM\r\n                    setupStructureDOM();\r\n                    setupScrollbarsDOM();\r\n                    setupScrollbarCornerDOM();\r\n\r\n                    //create OverlayScrollbars events\r\n                    setupStructureEvents();\r\n                    setupScrollbarEvents(true);\r\n                    setupScrollbarEvents(false);\r\n                    setupScrollbarCornerEvents();\r\n\r\n                    //create mutation observers\r\n                    createMutationObservers();\r\n\r\n                    //build resize observer for the host element\r\n                    setupResizeObserver(_sizeObserverElement, hostOnResized);\r\n\r\n                    if (_isBody) {\r\n                        //apply the body scroll to handle it right in the update method\r\n                        _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t);\r\n\r\n                        //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling\r\n                        if (document.activeElement == targetElement && _viewportElementNative.focus) {\r\n                            //set a tabindex to make the viewportElement focusable\r\n                            _viewportElement.attr(LEXICON.ti, '-1');\r\n                            _viewportElementNative.focus();\r\n\r\n                            /* the tabindex has to be removed due to;\r\n                             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too\r\n                             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex\r\n                             */\r\n                            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);\r\n                        }\r\n                    }\r\n\r\n                    //update for the first time & initialize cache\r\n                    _base.update(_strAuto);\r\n\r\n                    //the plugin is initialized now!\r\n                    _initialized = true;\r\n                    dispatchCallback('onInitialized');\r\n\r\n                    //call all callbacks which would fire before the initialized was complete\r\n                    each(_callbacksInitQeueue, function (index, value) { dispatchCallback(value.n, value.a); });\r\n                    _callbacksInitQeueue = [];\r\n\r\n                    //add extensions\r\n                    if (type(extensions) == TYPES.s)\r\n                        extensions = [extensions];\r\n                    if (COMPATIBILITY.isA(extensions))\r\n                        each(extensions, function (index, value) { _base.addExt(value); });\r\n                    else if (FRAMEWORK.isPlainObject(extensions))\r\n                        each(extensions, function (key, value) { _base.addExt(key, value); });\r\n\r\n                    //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)\r\n                    setTimeout(function () {\r\n                        if (_supportTransition && !_destroyed)\r\n                            addClass(_hostElement, _classNameHostTransition);\r\n                    }, 333);\r\n\r\n                    return _base;\r\n                }\r\n\r\n                if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {\r\n                    INSTANCES(pluginTargetElement, _base);\r\n                }\r\n\r\n                return _base;\r\n            }\r\n\r\n            /**\r\n             * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.\r\n             * @param pluginTargetElements The elements to which the Plugin shall be initialized.\r\n             * @param options The custom options with which the plugin shall be initialized.\r\n             * @param extensions The extension(s) which shall be added right after initialization.\r\n             * @returns {*}\r\n             */\r\n            _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {\r\n                if (arguments[LEXICON.l] === 0)\r\n                    return this;\r\n\r\n                var arr = [];\r\n                var optsIsPlainObj = FRAMEWORK.isPlainObject(options);\r\n                var inst;\r\n                var result;\r\n\r\n                //pluginTargetElements is null or undefined\r\n                if (!pluginTargetElements)\r\n                    return optsIsPlainObj || !options ? result : arr;\r\n\r\n                /*\r\n                   pluginTargetElements will be converted to:\r\n                   1. A jQueryElement Array\r\n                   2. A HTMLElement Array\r\n                   3. A Array with a single HTML Element\r\n                   so pluginTargetElements is always a array.\r\n                */\r\n                pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];\r\n                initOverlayScrollbarsStatics();\r\n\r\n                if (pluginTargetElements[LEXICON.l] > 0) {\r\n                    if (optsIsPlainObj) {\r\n                        FRAMEWORK.each(pluginTargetElements, function (i, v) {\r\n                            inst = v;\r\n                            if (inst !== undefined)\r\n                                arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));\r\n                        });\r\n                    }\r\n                    else {\r\n                        FRAMEWORK.each(pluginTargetElements, function (i, v) {\r\n                            inst = INSTANCES(v);\r\n                            if ((options === '!' && _plugin.valid(inst)) || (COMPATIBILITY.type(options) == TYPES.f && options(v, inst)))\r\n                                arr.push(inst);\r\n                            else if (options === undefined)\r\n                                arr.push(inst);\r\n                        });\r\n                    }\r\n                    result = arr[LEXICON.l] === 1 ? arr[0] : arr;\r\n                }\r\n                return result;\r\n            };\r\n\r\n            /**\r\n             * Returns a object which contains global information about the plugin and each instance of it.\r\n             * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.\r\n             */\r\n            _plugin.globals = function () {\r\n                initOverlayScrollbarsStatics();\r\n                var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);\r\n                delete globals['msie'];\r\n                return globals;\r\n            };\r\n\r\n            /**\r\n             * Gets or Sets the default options for each new plugin initialization.\r\n             * @param newDefaultOptions The object with which the default options shall be extended.\r\n             */\r\n            _plugin.defaultOptions = function (newDefaultOptions) {\r\n                initOverlayScrollbarsStatics();\r\n                var currDefaultOptions = _pluginsGlobals.defaultOptions;\r\n                if (newDefaultOptions === undefined)\r\n                    return FRAMEWORK.extend(true, {}, currDefaultOptions);\r\n\r\n                //set the new default options\r\n                _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);\r\n            };\r\n\r\n            /**\r\n             * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.\r\n             * @param osInstance The potential OverlayScrollbars instance which shall be checked.\r\n             * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.\r\n             */\r\n            _plugin.valid = function (osInstance) {\r\n                return osInstance instanceof _plugin && !osInstance.getState().destroyed;\r\n            };\r\n\r\n            /**\r\n             * Registers, Unregisters or returns a extension.\r\n             * Register: Pass the name and the extension. (defaultOptions is optional)\r\n             * Unregister: Pass the name and anything except a function as extension parameter.\r\n             * Get extension: Pass the name of the extension which shall be got.\r\n             * Get all extensions: Pass no arguments.\r\n             * @param extensionName The name of the extension which shall be registered, unregistered or returned.\r\n             * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.\r\n             * @param defaultOptions The default options which shall be used for the registered extension.\r\n             */\r\n            _plugin.extension = function (extensionName, extension, defaultOptions) {\r\n                var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;\r\n                var argLen = arguments[LEXICON.l];\r\n                var i = 0;\r\n                if (argLen < 1 || !extNameTypeString) {\r\n                    //return a copy of all extension objects\r\n                    return FRAMEWORK.extend(true, { length: _pluginsExtensions[LEXICON.l] }, _pluginsExtensions);\r\n                }\r\n                else if (extNameTypeString) {\r\n                    if (COMPATIBILITY.type(extension) == TYPES.f) {\r\n                        //register extension\r\n                        _pluginsExtensions.push({\r\n                            name: extensionName,\r\n                            extensionFactory: extension,\r\n                            defaultOptions: defaultOptions\r\n                        });\r\n                    }\r\n                    else {\r\n                        for (; i < _pluginsExtensions[LEXICON.l]; i++) {\r\n                            if (_pluginsExtensions[i].name === extensionName) {\r\n                                if (argLen > 1)\r\n                                    _pluginsExtensions.splice(i, 1); //remove extension\r\n                                else\r\n                                    return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            return _plugin;\r\n        })();\r\n\r\n        if (JQUERY && JQUERY.fn) {\r\n            /**\r\n             * The jQuery initialization interface.\r\n             * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.\r\n             * @param extensions The extension(s) which shall be added right after initialization.\r\n             * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.\r\n             */\r\n            JQUERY.fn.overlayScrollbars = function (options, extensions) {\r\n                var _elements = this;\r\n                if (JQUERY.isPlainObject(options)) {\r\n                    JQUERY.each(_elements, function () { PLUGIN(this, options, extensions); });\r\n                    return _elements;\r\n                }\r\n                else\r\n                    return PLUGIN(_elements, options);\r\n            };\r\n        }\r\n        return PLUGIN;\r\n    }\r\n));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy9Vc2Vycy9hbGVqYW5kcm9zYW5kb3ZhbC9zcGFjZS93b3JsZF9lc2VycC93ZWIvbm9kZV9tb2R1bGVzL292ZXJsYXlzY3JvbGxiYXJzL2pzL092ZXJsYXlTY3JvbGxiYXJzLmpzP2U2NmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLG1DQUFPLGFBQWEsb0RBQW9ELEVBQUU7QUFBQSxvR0FBQztBQUNuRixTQUFTLEVBRzJDO0FBQ3BELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLDhCQUE4QjtBQUN4RCw4QkFBOEIscUNBQXFDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNq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QUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG1DQUFtQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBQ2pDLDZDQUE2QztBQUM3Qyx5Q0FBeUM7QUFDekMsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEMsMkNBQTJDO0FBQzNDLHdDQUF3QztBQUN4QywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLDhCQUE4QiwyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscURBQXFEO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtFQUFrRSxnQkFBZ0I7QUFDbko7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7O0FBRW5JO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEY7O0FBRTlGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RkFBOEY7QUFDOUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLDhEQUE4RDs7QUFFOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsV0FBVztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTEFBZ0w7QUFDaEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1ELGdCQUFnQjtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixFQUFFO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQ7QUFDbkQsMkRBQTJEOztBQUUzRDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3Q0FBd0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0Esb0VBQW9FLHlCQUF5QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUNBQW1DLEVBQUU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9vdmVybGF5c2Nyb2xsYmFycy9qcy9PdmVybGF5U2Nyb2xsYmFycy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiBPdmVybGF5U2Nyb2xsYmFyc1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vS2luZ1NvcmEvT3ZlcmxheVNjcm9sbGJhcnNcclxuICpcclxuICogVmVyc2lvbjogMS4xMy4wXHJcbiAqXHJcbiAqIENvcHlyaWdodCBLaW5nU29yYSB8IFJlbmUgSGFhcy5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhXHJcbiAqXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuICogRGF0ZTogMDIuMDguMjAyMFxyXG4gKi9cclxuXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxyXG4gICAgICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBmYWN0b3J5KGdsb2JhbCwgZ2xvYmFsLmRvY3VtZW50LCB1bmRlZmluZWQpOyB9KTtcclxuICAgIGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KGdsb2JhbCwgZ2xvYmFsLmRvY3VtZW50LCB1bmRlZmluZWQpO1xyXG4gICAgZWxzZVxyXG4gICAgICAgIGZhY3RvcnkoZ2xvYmFsLCBnbG9iYWwuZG9jdW1lbnQsIHVuZGVmaW5lZCk7XHJcbn0odHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLFxyXG4gICAgZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG4gICAgICAgICd1c2Ugc3RyaWN0JztcclxuICAgICAgICB2YXIgUExVR0lOTkFNRSA9ICdPdmVybGF5U2Nyb2xsYmFycyc7XHJcbiAgICAgICAgdmFyIFRZUEVTID0ge1xyXG4gICAgICAgICAgICBvOiAnb2JqZWN0JyxcclxuICAgICAgICAgICAgZjogJ2Z1bmN0aW9uJyxcclxuICAgICAgICAgICAgYTogJ2FycmF5JyxcclxuICAgICAgICAgICAgczogJ3N0cmluZycsXHJcbiAgICAgICAgICAgIGI6ICdib29sZWFuJyxcclxuICAgICAgICAgICAgbjogJ251bWJlcicsXHJcbiAgICAgICAgICAgIHU6ICd1bmRlZmluZWQnLFxyXG4gICAgICAgICAgICB6OiAnbnVsbCdcclxuICAgICAgICAgICAgLy9kIDogJ2RhdGUnLFxyXG4gICAgICAgICAgICAvL2UgOiAnZXJyb3InLFxyXG4gICAgICAgICAgICAvL3IgOiAncmVnZXhwJyxcclxuICAgICAgICAgICAgLy95IDogJ3N5bWJvbCdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBMRVhJQ09OID0ge1xyXG4gICAgICAgICAgICBjOiAnY2xhc3MnLFxyXG4gICAgICAgICAgICBzOiAnc3R5bGUnLFxyXG4gICAgICAgICAgICBpOiAnaWQnLFxyXG4gICAgICAgICAgICBsOiAnbGVuZ3RoJyxcclxuICAgICAgICAgICAgcDogJ3Byb3RvdHlwZScsXHJcbiAgICAgICAgICAgIHRpOiAndGFiaW5kZXgnLFxyXG4gICAgICAgICAgICBvSDogJ29mZnNldEhlaWdodCcsXHJcbiAgICAgICAgICAgIGNIOiAnY2xpZW50SGVpZ2h0JyxcclxuICAgICAgICAgICAgc0g6ICdzY3JvbGxIZWlnaHQnLFxyXG4gICAgICAgICAgICBvVzogJ29mZnNldFdpZHRoJyxcclxuICAgICAgICAgICAgY1c6ICdjbGllbnRXaWR0aCcsXHJcbiAgICAgICAgICAgIHNXOiAnc2Nyb2xsV2lkdGgnLFxyXG4gICAgICAgICAgICBoT1A6ICdoYXNPd25Qcm9wZXJ0eScsXHJcbiAgICAgICAgICAgIGJDUjogJ2dldEJvdW5kaW5nQ2xpZW50UmVjdCdcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBWRU5ET1JTID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L1ZlbmRvcl9QcmVmaXhcclxuICAgICAgICAgICAgdmFyIGpzQ2FjaGUgPSB7fTtcclxuICAgICAgICAgICAgdmFyIGNzc0NhY2hlID0ge307XHJcbiAgICAgICAgICAgIHZhciBjc3NQcmVmaXhlcyA9IFsnLXdlYmtpdC0nLCAnLW1vei0nLCAnLW8tJywgJy1tcy0nXTtcclxuICAgICAgICAgICAgdmFyIGpzUHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNUyddO1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmaXJzdExldHRlclRvVXBwZXIoc3RyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgX2Nzc1ByZWZpeGVzOiBjc3NQcmVmaXhlcyxcclxuICAgICAgICAgICAgICAgIF9qc1ByZWZpeGVzOiBqc1ByZWZpeGVzLFxyXG4gICAgICAgICAgICAgICAgX2Nzc1Byb3BlcnR5OiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjc3NDYWNoZVtuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NhY2hlW0xFWElDT04uaE9QXShuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVwcGVyY2FzZWROYW1lID0gZmlyc3RMZXR0ZXJUb1VwcGVyKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbG1TdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpW0xFWElDT04uc107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdFBvc3NpYmlsaXRpZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJyVmVuZG9yV2l0aG91dERhc2hlcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjc3NQcmVmaXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyVmVuZG9yV2l0aG91dERhc2hlcyA9IGNzc1ByZWZpeGVzW2ldLnJlcGxhY2UoLy0vZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRQb3NzaWJpbGl0aWVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSwgLy90cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NQcmVmaXhlc1tpXSArIG5hbWUsIC8vLXdlYmtpdC10cmFuc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVmVuZG9yV2l0aG91dERhc2hlcyArIHVwcGVyY2FzZWROYW1lLCAvL3dlYmtpdFRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0TGV0dGVyVG9VcHBlcihjdXJyVmVuZG9yV2l0aG91dERhc2hlcykgKyB1cHBlcmNhc2VkTmFtZSAvL1dlYmtpdFRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2ID0gMDsgdiA8IHJlc3VsdFBvc3NpYmlsaXRpZXNbTEVYSUNPTi5sXTsgdisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWxtU3R5bGVbcmVzdWx0UG9zc2liaWxpdGllc1t2XV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFBvc3NpYmlsaXRpZXNbdl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNzc0NhY2hlW25hbWVdID0gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2Nzc1Byb3BlcnR5VmFsdWU6IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdmFsdWVzLCBzdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByb3BlcnR5ICsgJyAnICsgdmFsdWVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBjc3NDYWNoZVtuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0NhY2hlW0xFWElDT04uaE9QXShuYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVtMRVhJQ09OLnNdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzYmxlVmFsdWVzID0gdmFsdWVzLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXBhcmVkU3VmZml4ID0gc3VmZml4IHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHBvc3NibGVWYWx1ZXNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyB2IDwgVkVORE9SUy5fY3NzUHJlZml4ZXNbTEVYSUNPTi5sXTsgdisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wID0gdiA8IDAgPyBwb3NzYmxlVmFsdWVzW2ldIDogVkVORE9SUy5fY3NzUHJlZml4ZXNbdl0gKyBwb3NzYmxlVmFsdWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVtbXlTdHlsZS5jc3NUZXh0ID0gcHJvcGVydHkgKyAnOicgKyBwcm9wICsgcHJlcGFyZWRTdWZmaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVtbXlTdHlsZVtMRVhJQ09OLmxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2FjaGVbbmFtZV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBfanNBUEk6IGZ1bmN0aW9uIChuYW1lLCBpc0ludGVyZmFjZSwgZmFsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGpzQ2FjaGVbbmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghanNDYWNoZVtMRVhJQ09OLmhPUF0obmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93W25hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGpzUHJlZml4ZXNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IHdpbmRvd1soaXNJbnRlcmZhY2UgPyBqc1ByZWZpeGVzW2ldIDoganNQcmVmaXhlc1tpXS50b0xvd2VyQ2FzZSgpKSArIGZpcnN0TGV0dGVyVG9VcHBlcihuYW1lKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzQ2FjaGVbbmFtZV0gPSByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgZmFsbGJhY2s7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHZhciBDT01QQVRJQklMSVRZID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZnVuY3Rpb24gd2luZG93U2l6ZSh4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geCA/IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtMRVhJQ09OLmNXXSB8fCBkb2N1bWVudC5ib2R5W0xFWElDT04uY1ddIDogd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtMRVhJQ09OLmNIXSB8fCBkb2N1bWVudC5ib2R5W0xFWElDT04uY0hdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJpbmQoZnVuYywgdGhpc09iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFRZUEVTLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkNhbid0IGJpbmQgZnVuY3Rpb24hXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50ZXJuYWwgSXNDYWxsYWJsZSBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGUnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBwcm90byA9IExFWElDT04ucDtcclxuICAgICAgICAgICAgICAgIHZhciBhQXJncyA9IEFycmF5W3Byb3RvXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICAgICAgICAgICAgICB2YXIgZk5PUCA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAgICAgICAgIHZhciBmQm91bmQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jLmFwcGx5KHRoaXMgaW5zdGFuY2VvZiBmTk9QID8gdGhpcyA6IHRoaXNPYmosIGFBcmdzLmNvbmNhdChBcnJheVtwcm90b10uc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7IH07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGZ1bmNbcHJvdG9dKVxyXG4gICAgICAgICAgICAgICAgICAgIGZOT1BbcHJvdG9dID0gZnVuY1twcm90b107IC8vIEZ1bmN0aW9uLnByb3RvdHlwZSBkb2Vzbid0IGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHlcclxuICAgICAgICAgICAgICAgIGZCb3VuZFtwcm90b10gPSBuZXcgZk5PUCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmQm91bmQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGN1cnJlbnQgd2luZG93IHdpZHRoLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge051bWJlcnxudW1iZXJ9IFRoZSBjdXJyZW50IHdpbmRvdyB3aWR0aCBpbiBwaXhlbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgd1c6IGJpbmQod2luZG93U2l6ZSwgMCwgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHdpbmRvdyBoZWlnaHQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7TnVtYmVyfG51bWJlcn0gVGhlIGN1cnJlbnQgd2luZG93IGhlaWdodCBpbiBwaXhlbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgd0g6IGJpbmQod2luZG93U2l6ZSwgMCksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBNdXRhdGlvbk9ic2VydmVyIE9iamVjdCBvciB1bmRlZmluZWQgaWYgbm90IHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtNdXRhdGlvbk9ic2VydmVyfCp8dW5kZWZpbmVkfSBUaGUgTXV0YXRpb25zT2JzZXJ2ZXIgT2JqZWN0IG9yIHVuZGVmaW5lZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbU86IGJpbmQoVkVORE9SUy5fanNBUEksIDAsICdNdXRhdGlvbk9ic2VydmVyJywgdHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBSZXNpemVPYnNlcnZlciBPYmplY3Qgb3IgdW5kZWZpbmVkIGlmIG5vdCBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7TXV0YXRpb25PYnNlcnZlcnwqfHVuZGVmaW5lZH0gVGhlIFJlc2l6ZU9ic2VydmVyIE9iamVjdCBvciB1bmRlZmluZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHJPOiBiaW5kKFZFTkRPUlMuX2pzQVBJLCAwLCAnUmVzaXplT2JzZXJ2ZXInLCB0cnVlKSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZSBtZXRob2Qgb3IgaXQncyBjb3JyZXNwb25kaW5nIHBvbHlmaWxsLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp8RnVuY3Rpb259IFRoZSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgbWV0aG9kIG9yIGl0J3MgY29ycmVzcG9uZGluZyBwb2x5ZmlsbC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgckFGOiBiaW5kKFZFTkRPUlMuX2pzQVBJLCAwLCAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgZmFsc2UsIGZ1bmN0aW9uIChmdW5jKSB7IHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmdW5jLCAxMDAwIC8gNjApOyB9KSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIENhbmNlbEFuaW1hdGlvbkZyYW1lIG1ldGhvZCBvciBpdCdzIGNvcnJlc3BvbmRpbmcgcG9seWZpbGwuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7KnxGdW5jdGlvbn0gVGhlIENhbmNlbEFuaW1hdGlvbkZyYW1lIG1ldGhvZCBvciBpdCdzIGNvcnJlc3BvbmRpbmcgcG9seWZpbGwuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGNBRjogYmluZChWRU5ET1JTLl9qc0FQSSwgMCwgJ2NhbmNlbEFuaW1hdGlvbkZyYW1lJywgZmFsc2UsIGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gd2luZG93LmNsZWFyVGltZW91dChpZCk7IH0pLFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgY3VycmVudCB0aW1lLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGN1cnJlbnQgdGltZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbm93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERhdGUubm93ICYmIERhdGUubm93KCkgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3RvcHMgdGhlIHByb3BhZ2F0aW9uIG9mIHRoZSBnaXZlbiBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgb2Ygd2hpY2ggdGhlIHByb3BhZ2F0aW9uIHNoYWxsIGJlIHN0b3BlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgc3RwUDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGFjdGlvbiBvZiB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IG9mIHdoaWNoIHRoZSBkZWZhdWx0IGFjdGlvbiBzaGFsbCBiZSBwcmV2ZW50ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHBydkQ6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5jYW5jZWxhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBwYWdlWCBhbmQgcGFnZVkgdmFsdWVzIG9mIHRoZSBnaXZlbiBtb3VzZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgbW91c2UgZXZlbnQgb2Ygd2hpY2ggdGhlIHBhZ2VYIGFuZCBwYWdlWCBzaGFsbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0geCA9IHBhZ2VYIHZhbHVlLCB5ID0gcGFnZVkgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHBhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clBhZ2UgPSAncGFnZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckNsaWVudCA9ICdjbGllbnQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJYID0gJ1gnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJZID0gJ1knO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCB8fCBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnREb2MgPSB0YXJnZXQub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gZXZlbnREb2MuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gZXZlbnREb2MuYm9keTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiB0b3VjaCBldmVudCByZXR1cm4gcmV0dXJuIHBhZ2VYL1kgb2YgaXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiB0b3VjaFtzdHJQYWdlICsgc3RyWF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiB0b3VjaFtzdHJQYWdlICsgc3RyWV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBhZ2VYL1kgaWYgbm90IG5hdGl2ZSBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50W3N0clBhZ2UgKyBzdHJYXSAmJiBldmVudFtzdHJDbGllbnQgKyBzdHJYXSAmJiBldmVudFtzdHJDbGllbnQgKyBzdHJYXSAhPSBudWxsKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZXZlbnRbc3RyQ2xpZW50ICsgc3RyWF0gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBldmVudFtzdHJDbGllbnQgKyBzdHJZXSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvYyAmJiBkb2Muc2Nyb2xsVG9wIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgfHwgMCkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkb2MgJiYgZG9jLmNsaWVudFRvcCB8fCBib2R5ICYmIGJvZHkuY2xpZW50VG9wIHx8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogZXZlbnRbc3RyUGFnZSArIHN0clhdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBldmVudFtzdHJQYWdlICsgc3RyWV1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdldHMgdGhlIGNsaWNrZWQgbW91c2UgYnV0dG9uIG9mIHRoZSBnaXZlbiBtb3VzZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgbW91c2UgZXZlbnQgb2Ygd2hpY2ggdGhlIGNsaWNrZWQgYnV0dG9uIHNoYWwgYmUgZ290LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB0aGUgY2xpY2tlZCBtb3VzZSBidXR0b24uICgwIDogbm9uZSB8IDEgOiBsZWZ0QnV0dG9uIHwgMiA6IG1pZGRsZUJ1dHRvbiB8IDMgOiByaWdodEJ1dHRvbilcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgbUJ0bjogZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGJ1dHRvbiAmIDEgPyAxIDogKGJ1dHRvbiAmIDIgPyAzIDogKGJ1dHRvbiAmIDQgPyAyIDogMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBldmVudC53aGljaDtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBhIGl0ZW0gaXMgaW4gdGhlIGdpdmVuIGFycmF5IGFuZCByZXR1cm5zIGl0cyBpbmRleC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtIFRoZSBpdGVtIG9mIHdoaWNoIHRoZSBwb3NpdGlvbiBpbiB0aGUgYXJyYXkgc2hhbGwgYmUgZGV0ZXJtaW5lZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhcnIgVGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHplcm8gYmFzZWQgaW5kZXggb2YgdGhlIGl0ZW0gb3IgLTEgaWYgdGhlIGl0ZW0gaXNuJ3QgaW4gdGhlIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBpbkE6IGZ1bmN0aW9uIChpdGVtLCBhcnIpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycltMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU29tZXRpZW1zIGluIElFIGEgXCJTQ1JJUFQ3MFwiIFBlcm1pc3Npb24gZGVuaWVkIGVycm9yIG9jY3VycyBpZiBIVE1MIGVsZW1lbnRzIGluIGEgaUZyYW1lIGFyZSBjb21wYXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhcnIgVGhlIHBvdGVudGlhbCBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGlzQTogZnVuY3Rpb24gKGFycikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBBcnJheS5pc0FycmF5O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWYgPyBkZWYoYXJyKSA6IHRoaXMudHlwZShhcnIpID09IFRZUEVTLmE7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogRGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCBKYXZhU2NyaXB0IFtbQ2xhc3NdXSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IG9mIHdoaWNoIHRoZSB0eXBlIHNoYWxsIGJlIGRldGVybWluZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHlwZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqICsgJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iaiArICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3RbTEVYSUNPTi5wXS50b1N0cmluZy5jYWxsKG9iaikucmVwbGFjZSgvXlxcW29iamVjdCAoLispXFxdJC8sICckMScpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBiaW5kOiBiaW5kXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSB2ZW5kb3ItcHJlZml4ZWQgQ1NTIHByb3BlcnR5IGJ5IHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgICAgICAgICAgICAgICogRm9yIGV4YW1wbGUgdGhlIGdpdmVuIG5hbWUgaXMgXCJ0cmFuc2Zvcm1cIiBhbmQgeW91J3JlIHVzaW5nIGEgb2xkIEZpcmVmb3ggYnJvd3NlciB0aGVuIHRoZSByZXR1cm5lZCB2YWx1ZSB3b3VsZCBiZSBcIi1tb3otdHJhbnNmb3JtXCIuXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IG5lZWQgYSB2ZW5kb3ItcHJlZml4LCB0aGVuIHRoZSByZXR1cm5lZCBzdHJpbmcgaXMgdGhlIGdpdmVuIG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIGdpdmVuIHByb3BlcnR5IG5hbWUgYXQgYWxsIChub3QgZXZlbiB3aXRoIGEgdmVuZG9yLXByZWZpeCkgdGhlIHJldHVybmVkIHZhbHVlIGlzIG51bGwuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcHJvcE5hbWUgVGhlIHVucHJlZml4ZWQgQ1NTIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSB2ZW5kb3ItcHJlZml4ZWQgQ1NTIHByb3BlcnR5IG9yIG51bGwgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXHJcblxyXG4gICAgICAgICAgICAgICAgY3NzUHJvcDogZnVuY3Rpb24ocHJvcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVkVORE9SUy5fY3NzUHJvcGVydHkocHJvcE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcblxyXG5cclxuICAgICAgICB2YXIgTUFUSCA9IE1hdGg7XHJcbiAgICAgICAgdmFyIEpRVUVSWSA9IHdpbmRvdy5qUXVlcnk7XHJcbiAgICAgICAgdmFyIEVBU0lORyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfZWFzaW5nc01hdGggPSB7XHJcbiAgICAgICAgICAgICAgICBwOiBNQVRILlBJLFxyXG4gICAgICAgICAgICAgICAgYzogTUFUSC5jb3MsXHJcbiAgICAgICAgICAgICAgICBzOiBNQVRILnNpbixcclxuICAgICAgICAgICAgICAgIHc6IE1BVEgucG93LFxyXG4gICAgICAgICAgICAgICAgdDogTUFUSC5zcXJ0LFxyXG4gICAgICAgICAgICAgICAgbjogTUFUSC5hc2luLFxyXG4gICAgICAgICAgICAgICAgYTogTUFUSC5hYnMsXHJcbiAgICAgICAgICAgICAgICBvOiAxLjcwMTU4XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgeCA6IGN1cnJlbnQgcGVyY2VudCAoMCAtIDEpLFxyXG4gICAgICAgICAgICAgdCA6IGN1cnJlbnQgdGltZSAoZHVyYXRpb24gKiBwZXJjZW50KSxcclxuICAgICAgICAgICAgIGIgOiBzdGFydCB2YWx1ZSAoZnJvbSksXHJcbiAgICAgICAgICAgICBjIDogZW5kIHZhbHVlICh0byksXHJcbiAgICAgICAgICAgICBkIDogZHVyYXRpb25cclxuXHJcbiAgICAgICAgICAgICBlYXNpbmdOYW1lIDogZnVuY3Rpb24oeCwgdCwgYiwgYywgZCkgeyByZXR1cm4gZWFzZWRWYWx1ZTsgfVxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzd2luZzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC41IC0gX2Vhc2luZ3NNYXRoLmMoeCAqIF9lYXNpbmdzTWF0aC5wKSAvIDI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgbGluZWFyOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJblF1YWQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAtYyAqICh0IC89IGQpICogKHQgLSAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0UXVhZDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiB0ICogdCArIGIgOiAtYyAvIDIgKiAoKC0tdCkgKiAodCAtIDIpIC0gMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbkN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dEN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICsgMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEN1YmljOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyBjIC8gMiAqIHQgKiB0ICogdCArIGIgOiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICsgMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJblF1YXJ0OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRRdWFydDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0IC0gMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dFF1YXJ0OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHQgLz0gZCAvIDIpIDwgMSkgPyBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKyBiIDogLWMgLyAyICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMikgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJblF1aW50OiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCAqIHQgKiB0ICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0UXVpbnQ6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKiB0ICogdCArIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5PdXRRdWludDogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiB0ICogdCAqIHQgKiB0ICogdCArIGIgOiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluU2luZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgKiBfZWFzaW5nc01hdGguYyh0IC8gZCAqIChfZWFzaW5nc01hdGgucCAvIDIpKSArIGMgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRTaW5lOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjICogX2Vhc2luZ3NNYXRoLnModCAvIGQgKiAoX2Vhc2luZ3NNYXRoLnAgLyAyKSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dFNpbmU6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC1jIC8gMiAqIChfZWFzaW5nc01hdGguYyhfZWFzaW5nc01hdGgucCAqIHQgLyBkKSAtIDEpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5FeHBvOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodCA9PSAwKSA/IGIgOiBjICogX2Vhc2luZ3NNYXRoLncoMiwgMTAgKiAodCAvIGQgLSAxKSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VPdXRFeHBvOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAodCA9PSBkKSA/IGIgKyBjIDogYyAqICgtX2Vhc2luZ3NNYXRoLncoMiwgLTEwICogdCAvIGQpICsgMSkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEV4cG86IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gMCkgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gZCkgcmV0dXJuIGIgKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSByZXR1cm4gYyAvIDIgKiBfZWFzaW5nc01hdGgudygyLCAxMCAqICh0IC0gMSkpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAvIDIgKiAoLV9lYXNpbmdzTWF0aC53KDIsIC0xMCAqIC0tdCkgKyAyKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluQ2lyYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLWMgKiAoX2Vhc2luZ3NNYXRoLnQoMSAtICh0IC89IGQpICogdCkgLSAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZU91dENpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiBfZWFzaW5nc01hdGgudCgxIC0gKHQgPSB0IC8gZCAtIDEpICogdCkgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dENpcmM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgodCAvPSBkIC8gMikgPCAxKSA/IC1jIC8gMiAqIChfZWFzaW5nc01hdGgudCgxIC0gdCAqIHQpIC0gMSkgKyBiIDogYyAvIDIgKiAoX2Vhc2luZ3NNYXRoLnQoMSAtICh0IC09IDIpICogdCkgKyAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluRWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IF9lYXNpbmdzTWF0aC5vOyB2YXIgcCA9IDA7IHZhciBhID0gYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSAwKSByZXR1cm4gYjsgaWYgKCh0IC89IGQpID09IDEpIHJldHVybiBiICsgYzsgaWYgKCFwKSBwID0gZCAqIC4zO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgX2Vhc2luZ3NNYXRoLmEoYykpIHsgYSA9IGM7IHMgPSBwIC8gNDsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgcyA9IHAgLyAoMiAqIF9lYXNpbmdzTWF0aC5wKSAqIF9lYXNpbmdzTWF0aC5uKGMgLyBhKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLShhICogX2Vhc2luZ3NNYXRoLncoMiwgMTAgKiAodCAtPSAxKSkgKiBfZWFzaW5nc01hdGgucygodCAqIGQgLSBzKSAqICgyICogX2Vhc2luZ3NNYXRoLnApIC8gcCkpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0RWxhc3RpYzogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IF9lYXNpbmdzTWF0aC5vOyB2YXIgcCA9IDA7IHZhciBhID0gYztcclxuICAgICAgICAgICAgICAgICAgICBpZiAodCA9PSAwKSByZXR1cm4gYjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKHQgLz0gZCkgPT0gMSkgcmV0dXJuIGIgKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcCkgcCA9IGQgKiAuMztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYSA8IF9lYXNpbmdzTWF0aC5hKGMpKSB7IGEgPSBjOyBzID0gcCAvIDQ7IH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHMgPSBwIC8gKDIgKiBfZWFzaW5nc01hdGgucCkgKiBfZWFzaW5nc01hdGgubihjIC8gYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEgKiBfZWFzaW5nc01hdGgudygyLCAtMTAgKiB0KSAqIF9lYXNpbmdzTWF0aC5zKCh0ICogZCAtIHMpICogKDIgKiBfZWFzaW5nc01hdGgucCkgLyBwKSArIGMgKyBiO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEVsYXN0aWM6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSBfZWFzaW5nc01hdGgubzsgdmFyIHAgPSAwOyB2YXIgYSA9IGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgPT0gMCkgcmV0dXJuIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0IC89IGQgLyAyKSA9PSAyKSByZXR1cm4gYiArIGM7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwKSBwID0gZCAqICguMyAqIDEuNSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEgPCBfZWFzaW5nc01hdGguYShjKSkgeyBhID0gYzsgcyA9IHAgLyA0OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBzID0gcCAvICgyICogX2Vhc2luZ3NNYXRoLnApICogX2Vhc2luZ3NNYXRoLm4oYyAvIGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0IDwgMSkgcmV0dXJuIC0uNSAqIChhICogX2Vhc2luZ3NNYXRoLncoMiwgMTAgKiAodCAtPSAxKSkgKiBfZWFzaW5nc01hdGgucygodCAqIGQgLSBzKSAqICgyICogX2Vhc2luZ3NNYXRoLnApIC8gcCkpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSAqIF9lYXNpbmdzTWF0aC53KDIsIC0xMCAqICh0IC09IDEpKSAqIF9lYXNpbmdzTWF0aC5zKCh0ICogZCAtIHMpICogKDIgKiBfZWFzaW5nc01hdGgucCkgLyBwKSAqIC41ICsgYyArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluQmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBfZWFzaW5nc01hdGgubztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0QmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBfZWFzaW5nc01hdGgubztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZWFzZUluT3V0QmFjazogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQsIHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyB8fCBfZWFzaW5nc01hdGgubztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCh0IC89IGQgLyAyKSA8IDEpID8gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpICsgYiA6IGMgLyAyICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlSW5Cb3VuY2U6IGZ1bmN0aW9uICh4LCB0LCBiLCBjLCBkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgLSB0aGlzLmVhc2VPdXRCb3VuY2UoeCwgZCAtIHQsIDAsIGMsIGQpICsgYjtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbiAoeCwgdCwgYiwgYywgZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvID0gNy41NjI1O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgodCAvPSBkKSA8ICgxIC8gMi43NSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAobyAqIHQgKiB0KSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0IDwgKDIgLyAyLjc1KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYyAqIChvICogKHQgLT0gKDEuNSAvIDIuNzUpKSAqIHQgKyAuNzUpICsgYjtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHQgPCAoMi41IC8gMi43NSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAobyAqICh0IC09ICgyLjI1IC8gMi43NSkpICogdCArIC45Mzc1KSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGMgKiAobyAqICh0IC09ICgyLjYyNSAvIDIuNzUpKSAqIHQgKyAuOTg0Mzc1KSArIGI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGVhc2VJbk91dEJvdW5jZTogZnVuY3Rpb24gKHgsIHQsIGIsIGMsIGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHQgPCBkIC8gMikgPyB0aGlzLmVhc2VJbkJvdW5jZSh4LCB0ICogMiwgMCwgYywgZCkgKiAuNSArIGIgOiB0aGlzLmVhc2VPdXRCb3VuY2UoeCwgdCAqIDIgLSBkLCAwLCBjLCBkKSAqIC41ICsgYyAqIC41ICsgYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVEVSTVMgT0YgVVNFIC0gRUFTSU5HIEVRVUFUSU9OU1xyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogT3BlbiBzb3VyY2UgdW5kZXIgdGhlIEJTRCBMaWNlbnNlLiBcclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIENvcHlyaWdodCDDgsKpIDIwMDEgUm9iZXJ0IFBlbm5lclxyXG4gICAgICAgICAgICAgKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgXHJcbiAgICAgICAgICAgICAqIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcclxuICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIFxyXG4gICAgICAgICAgICAgKiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXHJcbiAgICAgICAgICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IFxyXG4gICAgICAgICAgICAgKiBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBcclxuICAgICAgICAgICAgICogcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxyXG4gICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgYXV0aG9yIG5vciB0aGUgbmFtZXMgb2YgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2UgXHJcbiAgICAgICAgICAgICAqIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXHJcbiAgICAgICAgICAgICAqIFxyXG4gICAgICAgICAgICAgKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIFxyXG4gICAgICAgICAgICAgKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcclxuICAgICAgICAgICAgICogTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXHJcbiAgICAgICAgICAgICAqICBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsXHJcbiAgICAgICAgICAgICAqICBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEVcclxuICAgICAgICAgICAgICogIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBcclxuICAgICAgICAgICAgICogQU5EIE9OIEFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcclxuICAgICAgICAgICAgICogIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIFxyXG4gICAgICAgICAgICAgKiBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuIFxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICB9KSgpO1xyXG4gICAgICAgIHZhciBGUkFNRVdPUksgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3Jub3RodG1sd2hpdGUgPSAoL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nKTtcclxuICAgICAgICAgICAgdmFyIF9zdHJTcGFjZSA9ICcgJztcclxuICAgICAgICAgICAgdmFyIF9zdHJFbXB0eSA9ICcnO1xyXG4gICAgICAgICAgICB2YXIgX3N0clNjcm9sbExlZnQgPSAnc2Nyb2xsTGVmdCc7XHJcbiAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsVG9wID0gJ3Njcm9sbFRvcCc7XHJcbiAgICAgICAgICAgIHZhciBfYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgX3R5cGUgPSBDT01QQVRJQklMSVRZLnR5cGU7XHJcbiAgICAgICAgICAgIHZhciBfY3NzTnVtYmVyID0ge1xyXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5Db3VudDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZmxleEdyb3c6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBmbGV4U2hyaW5rOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgb3JkZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBvcnBoYW5zOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd2lkb3dzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgem9vbTogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNyYywgY29weUlzQXJyYXksIGNvcHksIG5hbWUsIG9wdGlvbnMsIGNsb25lLCB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzW0xFWElDT04ubF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVlcCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cclxuICAgICAgICAgICAgICAgIGlmIChfdHlwZSh0YXJnZXQpID09IFRZUEVTLmIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWVwID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXHJcbiAgICAgICAgICAgICAgICBpZiAoX3R5cGUodGFyZ2V0KSAhPSBUWVBFUy5vICYmICFfdHlwZSh0YXJnZXQpID09IFRZUEVTLmYpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBleHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSBGYWtlalF1ZXJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIC0taTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmMgPSB0YXJnZXRbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5ID0gb3B0aW9uc1tuYW1lXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBjb3B5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChpc1BsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IENPTVBBVElCSUxJVFkuaXNBKGNvcHkpKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29weUlzQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgQ09NUEFUSUJJTElUWS5pc0Eoc3JjKSA/IHNyYyA6IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZSA9IHNyYyAmJiBpc1BsYWluT2JqZWN0KHNyYykgPyBzcmMgOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGV4dGVuZChkZWVwLCBjbG9uZSwgY29weSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gY29weTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGluQXJyYXkoaXRlbSwgYXJyLCBmcm9tSW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXggfHwgMDsgaSA8IGFycltMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gaXRlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3R5cGUob2JqKSA9PSBUWVBFUy5mO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNFbXB0eU9iamVjdChvYmopIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG5hbWUgaW4gb2JqKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcclxuICAgICAgICAgICAgICAgIGlmICghb2JqIHx8IF90eXBlKG9iaikgIT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgICAgIHZhciBwcm90byA9IExFWElDT04ucDtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdFtwcm90b10uaGFzT3duUHJvcGVydHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzT3duQ29uc3RydWN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgJ2NvbnN0cnVjdG9yJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGFzSXNQcm90b3R5cGVPZiA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3JbcHJvdG9dICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yW3Byb3RvXSwgJ2lzUHJvdG90eXBlT2YnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7IC8qKi8gfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBfdHlwZShrZXkpID09IFRZUEVTLnUgfHwgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgb2JqW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChvYmpbaV0sIGksIG9ialtpXSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiBvYmo7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpc0FycmF5TGlrZShvYmopIHtcclxuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSAhIW9iaiAmJiBbTEVYSUNPTi5sXSBpbiBvYmogJiYgb2JqW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IF90eXBlKG9iaik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGdW5jdGlvbih0KSA/IGZhbHNlIDogKHQgPT0gVFlQRVMuYSB8fCBsZW5ndGggPT09IDAgfHwgX3R5cGUobGVuZ3RoKSA9PSBUWVBFUy5uICYmIGxlbmd0aCA+IDAgJiYgKGxlbmd0aCAtIDEpIGluIG9iaik7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zLmpvaW4oX3N0clNwYWNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gbWF0Y2hlcyhlbGVtLCBzZWxlY3Rvcikge1xyXG4gICAgICAgICAgICAgICAgdmFyIG5vZGVMaXN0ID0gKGVsZW0ucGFyZW50Tm9kZSB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgfHwgW107XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG5vZGVMaXN0W0xFWElDT04ubF07XHJcblxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGktLSlcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUxpc3RbaV0gPT0gZWxlbSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbnNlcnRBZGphY2VudEVsZW1lbnQoZWwsIHN0cmF0ZWd5LCBjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRBZGphY2VudEVsZW1lbnQoZWwsIHN0cmF0ZWd5LCBjaGlsZFtpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdHlwZShjaGlsZCkgPT0gVFlQRVMucylcclxuICAgICAgICAgICAgICAgICAgICBlbC5pbnNlcnRBZGphY2VudEhUTUwoc3RyYXRlZ3ksIGNoaWxkKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBlbC5pbnNlcnRBZGphY2VudEVsZW1lbnQoc3RyYXRlZ3ksIGNoaWxkLm5vZGVUeXBlID8gY2hpbGQgOiBjaGlsZFswXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNldENTU1ZhbChlbCwgcHJvcCwgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbFtMRVhJQ09OLnNdW3Byb3BdICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW0xFWElDT04uc11bcHJvcF0gPSBwYXJzZUNTU1ZhbChwcm9wLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlQ1NTVmFsKHByb3AsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfY3NzTnVtYmVyW3Byb3AudG9Mb3dlckNhc2UoKV0gJiYgX3R5cGUodmFsKSA9PSBUWVBFUy5uKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhbCArPSAncHgnO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmosIHJlbW92ZUZyb21RKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dEFuaW07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlRnJvbVEgIT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1PYmoucS5zcGxpY2UoMCwgMSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYW5pbU9iai5xW0xFWElDT04ubF0gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dEFuaW0gPSBhbmltT2JqLnFbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZShhbmltT2JqLmVsLCBuZXh0QW5pbS5wcm9wcywgbmV4dEFuaW0uZHVyYXRpb24sIG5leHRBbmltLmVhc2luZywgbmV4dEFuaW0uY29tcGxldGUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpbkFycmF5KGFuaW1PYmosIF9hbmltYXRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2FuaW1hdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0QW5pbWF0aW9uVmFsdWUoZWwsIHByb3AsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gX3N0clNjcm9sbExlZnQgfHwgcHJvcCA9PT0gX3N0clNjcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICBlbFtwcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldENTU1ZhbChlbCwgcHJvcCwgdmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBhbmltYXRlKGVsLCBwcm9wcywgb3B0aW9ucywgZWFzaW5nLCBjb21wbGV0ZSwgZ3VhcmFudGVlZE5leHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBoYXNPcHRpb25zID0gaXNQbGFpbk9iamVjdChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYW5pbU9iajtcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcztcclxuICAgICAgICAgICAgICAgIHZhciBzdGVwO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNwZWNpYWxFYXNpbmc7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gb3B0aW9ucy5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IG9wdGlvbnMucHJvZ3Jlc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RlcCA9IG9wdGlvbnMuc3RlcDtcclxuICAgICAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nID0gb3B0aW9ucy5zcGVjaWFsRWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcclxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBvcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgc3BlY2lhbEVhc2luZyA9IHNwZWNpYWxFYXNpbmcgfHwge307XHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDQwMDtcclxuICAgICAgICAgICAgICAgIGVhc2luZyA9IGVhc2luZyB8fCAnc3dpbmcnO1xyXG4gICAgICAgICAgICAgICAgZ3VhcmFudGVlZE5leHQgPSBndWFyYW50ZWVkTmV4dCB8fCBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IF9hbmltYXRpb25zW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfYW5pbWF0aW9uc1tpXS5lbCA9PT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbU9iaiA9IF9hbmltYXRpb25zW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFhbmltT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5pbU9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxOiBbXVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgX2FuaW1hdGlvbnMucHVzaChhbmltT2JqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IF9zdHJTY3JvbGxMZWZ0IHx8IGtleSA9PT0gX3N0clNjcm9sbFRvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVtrZXldID0gZWxba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21ba2V5XSA9IEZha2VqUXVlcnkoZWwpLmNzcyhrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGZyb20pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbVtrZXldICE9PSBwcm9wc1trZXldICYmIHByb3BzW2tleV0gIT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgdG9ba2V5XSA9IHByb3BzW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHRvKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lTm93O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcmNlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21WYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRvVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlYXNlZFZhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGltZVN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxhcHNlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcVBvcyA9IGd1YXJhbnRlZWROZXh0ID8gMCA6IGluQXJyYXkocU9iaiwgYW5pbU9iai5xKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcU9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHRvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogaGFzT3B0aW9ucyA/IG9wdGlvbnMgOiBkdXJhdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHFQb3MgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFQb3MgPSBhbmltT2JqLnFbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5pbU9iai5xLnB1c2gocU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAocVBvcyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lU3RhcnQgPSBDT01QQVRJQklMSVRZLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZU5vdyA9IENPTVBBVElCSUxJVFkubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxhcHNlZCA9ICh0aW1lTm93IC0gdGltZVN0YXJ0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBxT2JqLnN0b3AgfHwgZWxhcHNlZCA+PSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZXJjZW50ID0gMSAtICgoTUFUSC5tYXgoMCwgdGltZVN0YXJ0ICsgZHVyYXRpb24gLSB0aW1lTm93KSAvIGR1cmF0aW9uKSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gdG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVZhbCA9IHBhcnNlRmxvYXQoZnJvbVtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9WYWwgPSBwYXJzZUZsb2F0KHRvW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNlZFZhbCA9ICh0b1ZhbCAtIGZyb21WYWwpICogRUFTSU5HW3NwZWNpYWxFYXNpbmdba2V5XSB8fCBlYXNpbmddKHBlcmNlbnQsIHBlcmNlbnQgKiBkdXJhdGlvbiwgMCwgMSwgZHVyYXRpb24pICsgZnJvbVZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0QW5pbWF0aW9uVmFsdWUoZWwsIGtleSwgZWFzZWRWYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihzdGVwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcChlYXNlZFZhbCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW06IGVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3A6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogZnJvbVZhbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3c6IGVhc2VkVmFsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogdG9WYWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwZXJjZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiBlYXNpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwZWFjaWFsRWFzaW5nOiBzcGVjaWFsRWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogc3RlcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lOiB0aW1lU3RhcnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9ncmVzcykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzKHt9LCBwZXJjZW50LCBNQVRILm1heCgwLCBkdXJhdGlvbiAtIGVsYXBzZWQpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5leHRBbmltYXRpb25JblEoYW5pbU9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNvbXBsZXRlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcU9iai5mcmFtZSA9IENPTVBBVElCSUxJVFkuckFGKCkoZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFPYmouZnJhbWUgPSBDT01QQVRJQklMSVRZLnJBRigpKGZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblZhbHVlKGVsLCBrZXksIHRvW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZ3VhcmFudGVlZE5leHQpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnROZXh0QW5pbWF0aW9uSW5RKGFuaW1PYmopO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdG9wKGVsLCBjbGVhclEsIGp1bXBUb0VuZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFuaW1PYmo7XHJcbiAgICAgICAgICAgICAgICB2YXIgcU9iajtcclxuICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IF9hbmltYXRpb25zW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGFuaW1PYmogPSBfYW5pbWF0aW9uc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbU9iai5lbCA9PT0gZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1PYmoucVtMRVhJQ09OLmxdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcU9iaiA9IGFuaW1PYmoucVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHFPYmouc3RvcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLmNBRigpKHFPYmouZnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbU9iai5xLnNwbGljZSgwLCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoanVtcFRvRW5kKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIHFPYmoucHJvcHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblZhbHVlKGVsLCBrZXksIHFPYmoucHJvcHNba2V5XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsZWFyUSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltT2JqLnEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFydE5leHRBbmltYXRpb25JblEoYW5pbU9iaiwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gZWxlbWVudElzVmlzaWJsZShlbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsW0xFWElDT04ub1ddIHx8IGVsW0xFWElDT04ub0hdIHx8IGVsLmdldENsaWVudFJlY3RzKClbTEVYSUNPTi5sXSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIEZha2VqUXVlcnkoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbTEVYSUNPTi5sXSA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IG5ldyBGYWtlalF1ZXJ5KCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBzZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgIHZhciBlbG1zO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChfdHlwZShzZWxlY3RvcikgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLmNoYXJBdCgwKSA9PT0gJzwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IHNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1zID0gZWwuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbG1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGVsbXNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsbXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZShlbGVtZW50cykgIT0gVFlQRVMucyAmJiAoIWlzQXJyYXlMaWtlKGVsZW1lbnRzKSB8fCBlbGVtZW50cyA9PT0gd2luZG93IHx8IGVsZW1lbnRzID09PSBlbGVtZW50cy5zZWxmKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBbZWxlbWVudHNdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlW2ldID0gZWxlbWVudHNbaV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VbTEVYSUNPTi5sXSA9IGVsZW1lbnRzW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBGYWtlalF1ZXJ5W0xFWElDT04ucF0gPSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9FVkVOVFM6XHJcblxyXG4gICAgICAgICAgICAgICAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSAoZXZlbnROYW1lIHx8IF9zdHJFbXB0eSkubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtfc3RyRW1wdHldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnROYW1lTGVuZ3RoID0gZXZlbnROYW1lW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsLmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZVtpXSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC5kZXRhY2hFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnROYW1lTGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWVbaV0sIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gKGV2ZW50TmFtZSB8fCBfc3RyRW1wdHkpLm1hdGNoKF9ybm90aHRtbHdoaXRlKSB8fCBbX3N0ckVtcHR5XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50TmFtZUxlbmd0aCA9IGV2ZW50TmFtZVtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBldmVudE5hbWVMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWVbaV0sIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWwuZGV0YWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGV2ZW50TmFtZUxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnROYW1lW2ldLCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIG9uZTogZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IChldmVudE5hbWUgfHwgX3N0ckVtcHR5KS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW19zdHJFbXB0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IEZha2VqUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZha2VqUXVlcnkuZWFjaChldmVudE5hbWUsIGZ1bmN0aW9uIChpLCBvbmVFdmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbmVIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwub2ZmKG9uZUV2ZW50TmFtZSwgb25lSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwub24ob25lRXZlbnROYW1lLCBvbmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnSFRNTEV2ZW50cycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5maXJlRXZlbnQoJ29uJyArIGV2ZW50TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgLy9ET00gTk9ERSBJTlNFUlRJTkcgLyBSRU1PVklORzpcclxuXHJcbiAgICAgICAgICAgICAgICBhcHBlbmQ6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2JlZm9yZWVuZCcsIGNoaWxkKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHByZXBlbmQ6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2FmdGVyYmVnaW4nLCBjaGlsZCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBiZWZvcmU6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2JlZm9yZWJlZ2luJywgY2hpbGQpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBpbnNlcnRBZGphY2VudEVsZW1lbnQodGhpcywgJ2FmdGVyZW5kJywgY2hpbGQpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gZWwucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE5vZGUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB1bndyYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KHBhcmVudCwgcGFyZW50cykgPT09IC0gMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChwYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFyZW50c1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBwYXJlbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWwuZmlyc3RDaGlsZCwgZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHdyYXBBbGw6IGZ1bmN0aW9uICh3cmFwcGVySFRNTCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBGYWtlalF1ZXJ5KHdyYXBwZXJIVE1MKVswXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGVlcGVzdCA9IHdyYXBwZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVzWzBdLnBhcmVudE5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IG5vZGVzWzBdLnByZXZpb3VzU2libGluZztcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZGVlcGVzdC5jaGlsZE5vZGVzW0xFWElDT04ubF0gPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWVwZXN0ID0gZGVlcGVzdC5jaGlsZE5vZGVzWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBub2Rlc1tMRVhJQ09OLmxdIC0gaTsgZGVlcGVzdC5maXJzdENoaWxkID09PSBub2Rlc1swXSAmJiBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBlc3QuYXBwZW5kQ2hpbGQobm9kZXNbaV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFNpYmxpbmcgPSBwcmV2aW91c1NpYmxpbmcgPyBwcmV2aW91c1NpYmxpbmcubmV4dFNpYmxpbmcgOiBwYXJlbnQuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHdyYXBwZXIsIG5leHRTaWJsaW5nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHdyYXBJbm5lcjogZnVuY3Rpb24gKHdyYXBwZXJIVE1MKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IEZha2VqUXVlcnkodGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50cyA9IGVsLmNvbnRlbnRzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGVudHNbTEVYSUNPTi5sXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLndyYXBBbGwod3JhcHBlckhUTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC5hcHBlbmQod3JhcHBlckhUTUwpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB3cmFwOiBmdW5jdGlvbiAod3JhcHBlckhUTUwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgRmFrZWpRdWVyeSh0aGlzKS53cmFwQWxsKHdyYXBwZXJIVE1MKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL0RPTSBOT0RFIE1BTklQVUxBVElPTiAvIElORk9STUFUSU9OOlxyXG5cclxuICAgICAgICAgICAgICAgIGNzczogZnVuY3Rpb24gKHN0eWxlcywgdmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNwdFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRDcHRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZShzdHlsZXMpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcHRTdHlsZSA9IGdldENwdFN0eWxlID8gZ2V0Q3B0U3R5bGUoZWwsIG51bGwpIDogZWwuY3VycmVudFN0eWxlW3N0eWxlc107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9odHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTcgY2FuIGJlIG51bGwgc29tZXRpbWVzIGlmIGlmcmFtZSB3aXRoIGRpc3BsYXk6IG5vbmUgKGZpcmVmb3ggb25seSEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q3B0U3R5bGUgPyBjcHRTdHlsZSAhPSBudWxsID8gY3B0U3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZXMpIDogZWxbTEVYSUNPTi5zXVtzdHlsZXNdIDogY3B0U3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDU1NWYWwodGhpcywgc3R5bGVzLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gc3R5bGVzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENTU1ZhbCh0aGlzLCBrZXksIHN0eWxlc1trZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBoYXNDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtLCBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lUHJlcGFyZWQgPSBfc3RyU3BhY2UgKyBjbGFzc05hbWUgKyBfc3RyU3BhY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTGlzdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc0xpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTGlzdCAmJiBjbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtLm5vZGVUeXBlID09PSAxICYmIChfc3RyU3BhY2UgKyBzdHJpcEFuZENvbGxhcHNlKGVsZW0uY2xhc3NOYW1lICsgX3N0ckVtcHR5KSArIF9zdHJTcGFjZSkuaW5kZXhPZihjbGFzc05hbWVQcmVwYXJlZCkgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzczogZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1clZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGF6ejtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3VwcG9ydENsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxtQ2xhc3NMaXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5tYXRjaChfcm5vdGh0bWx3aGl0ZSkgfHwgW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGVsZW0gPSB0aGlzW2krK10pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG1DbGFzc0xpc3QgPSBlbGVtLmNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0Q2xhc3NMaXN0ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydENsYXNzTGlzdCA9IGVsbUNsYXNzTGlzdCAhPT0gdW5kZWZpbmVkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0Q2xhc3NMaXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbdisrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsbUNsYXNzTGlzdC5hZGQoY2xhenopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyVmFsdWUgPSBlbGVtLmNsYXNzTmFtZSArIF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmIChfc3RyU3BhY2UgKyBzdHJpcEFuZENvbGxhcHNlKGN1clZhbHVlKSArIF9zdHJTcGFjZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChjbGF6eiA9IGNsYXNzZXNbdisrXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmluZGV4T2YoX3N0clNwYWNlICsgY2xhenogKyBfc3RyU3BhY2UpIDwgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXIgKz0gY2xhenogKyBfc3RyU3BhY2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gc3RyaXBBbmRDb2xsYXBzZShjdXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xheno7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1cHBvcnRDbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsbUNsYXNzTGlzdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBjbGFzc05hbWUubWF0Y2goX3Jub3RodG1sd2hpdGUpIHx8IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKChlbGVtID0gdGhpc1tpKytdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxtQ2xhc3NMaXN0ID0gZWxlbS5jbGFzc0xpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydENsYXNzTGlzdCA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cHBvcnRDbGFzc0xpc3QgPSBlbG1DbGFzc0xpc3QgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydENsYXNzTGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW3YrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbG1DbGFzc0xpc3QucmVtb3ZlKGNsYXp6KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clZhbHVlID0gZWxlbS5jbGFzc05hbWUgKyBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoX3N0clNwYWNlICsgc3RyaXBBbmRDb2xsYXBzZShjdXJWYWx1ZSkgKyBfc3RyU3BhY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2xhenogPSBjbGFzc2VzW3YrK10pKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1ci5pbmRleE9mKF9zdHJTcGFjZSArIGNsYXp6ICsgX3N0clNwYWNlKSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKF9zdHJTcGFjZSArIGNsYXp6ICsgX3N0clNwYWNlLCBfc3RyU3BhY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clZhbHVlICE9PSBmaW5hbFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc05hbWUgPSBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgdGhpc1tMRVhJQ09OLnNdLmRpc3BsYXkgPSAnbm9uZSc7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7IHRoaXNbTEVYSUNPTi5zXS5kaXNwbGF5ID0gJ2Jsb2NrJzsgfSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGF0dHI6IGZ1bmN0aW9uIChhdHRyTmFtZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChlbCA9IHRoaXNbaSsrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHJlbW92ZUF0dHI6IGZ1bmN0aW9uIChhdHRyTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyTmFtZSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gZWxbTEVYSUNPTi5iQ1JdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB3aW5kb3cucGFnZVhPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFtfc3RyU2Nyb2xsVG9wXTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHJlY3QudG9wICsgc2Nyb2xsVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LmxlZnQgKyBzY3JvbGxMZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogZWwub2Zmc2V0VG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBlbC5vZmZzZXRMZWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsTGVmdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwgPSB0aGlzW2krK10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxbX3N0clNjcm9sbExlZnRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFtfc3RyU2Nyb2xsTGVmdF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHNjcm9sbFRvcDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoZWwgPSB0aGlzW2krK10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxbX3N0clNjcm9sbFRvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsW19zdHJTY3JvbGxUb3BdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgICAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGVsLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL0RPTSBUUkFWRVJTQUwgLyBGSUxURVJJTkc6XHJcblxyXG4gICAgICAgICAgICAgICAgZmlyc3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lcSgwKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgbGFzdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKC0xKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZXE6IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5KHRoaXNbaW5kZXggPj0gMCA/IGluZGV4IDogdGhpc1tMRVhJQ09OLmxdICsgaW5kZXhdKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgZmluZDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoID0gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaFtMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaFtMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gY2hbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGVsLm1hdGNoZXMgJiYgZWwubWF0Y2hlcyhzZWxlY3RvcikpIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShjaGlsZHJlbik7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIHBhcmVudDogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID8gRmFrZWpRdWVyeShwYXJlbnQpLmlzKHNlbGVjdG9yKSA6IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gocGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShwYXJlbnRzKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgaXM6IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdGhpc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSAnOnZpc2libGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGUoZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICc6aGlkZGVuJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZWxlbWVudElzVmlzaWJsZShlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZWwubWF0Y2hlcyAmJiBlbC5tYXRjaGVzKHNlbGVjdG9yKSkgfHwgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgY29udGVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHMgPSB0aGlzLmNoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaGlsZHNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudHMucHVzaChjaGlsZHNbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRmFrZWpRdWVyeShjb250ZW50cyk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIGVhY2g6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlYWNoKHRoaXMsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vQU5JTUFUSU9OOlxyXG5cclxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IGZ1bmN0aW9uIChwcm9wcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHsgYW5pbWF0ZSh0aGlzLCBwcm9wcywgZHVyYXRpb24sIGVhc2luZywgY29tcGxldGUpOyB9KTtcclxuICAgICAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICAgICAgc3RvcDogZnVuY3Rpb24gKGNsZWFyUSwganVtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkgeyBzdG9wKHRoaXMsIGNsZWFyUSwganVtcCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZXh0ZW5kKEZha2VqUXVlcnksIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuZDogZXh0ZW5kLFxyXG4gICAgICAgICAgICAgICAgaW5BcnJheTogaW5BcnJheSxcclxuICAgICAgICAgICAgICAgIGlzRW1wdHlPYmplY3Q6IGlzRW1wdHlPYmplY3QsXHJcbiAgICAgICAgICAgICAgICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxyXG4gICAgICAgICAgICAgICAgZWFjaDogZWFjaFxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBGYWtlalF1ZXJ5O1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgdmFyIElOU1RBTkNFUyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGFyZ2V0cyA9IFtdO1xyXG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlUHJvcGVydHlTdHJpbmcgPSAnX19vdmVybGF5U2Nyb2xsYmFyc19fJztcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBSZWdpc3RlciwgdW5yZWdpc3RlciBvciBnZXQgYSBjZXJ0YWluIChvciBhbGwpIGluc3RhbmNlcy5cclxuICAgICAgICAgICAgICogUmVnaXN0ZXI6IFBhc3MgdGhlIHRhcmdldCBhbmQgdGhlIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKiBVbnJlZ2lzdGVyOiBQYXNzIHRoZSB0YXJnZXQgYW5kIG51bGwuXHJcbiAgICAgICAgICAgICAqIEdldCBJbnN0YW5jZTogUGFzcyB0aGUgdGFyZ2V0IGZyb20gd2hpY2ggdGhlIGluc3RhbmNlIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICogR2V0IFRhcmdldHM6IFBhc3Mgbm8gYXJndW1lbnRzLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSB0YXJnZXQgdG8gd2hpY2ggdGhlIGluc3RhbmNlIHNoYWxsIGJlIHJlZ2lzdGVyZWQgLyBmcm9tIHdoaWNoIHRoZSBpbnN0YW5jZSBzaGFsbCBiZSB1bnJlZ2lzdGVyZWQgLyB0aGUgaW5zdGFuY2Ugc2hhbGwgYmUgZ290XHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfHZvaWR9IFJldHVybnMgdGhlIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIHRhcmdldC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ0xlbiA9IGFyZ3VtZW50c1tMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ0xlbiA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBhbGwgdGFyZ2V0c1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGFyZ2V0cztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlZ2lzdGVyIGluc3RhbmNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtfaW5zdGFuY2VQcm9wZXJ0eVN0cmluZ10gPSBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldHMucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gQ09NUEFUSUJJTElUWS5pbkEodGFyZ2V0LCBfdGFyZ2V0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnTGVuID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdW5yZWdpc3RlciBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRbX2luc3RhbmNlUHJvcGVydHlTdHJpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCBpbnN0YW5jZSBmcm9tIHRhcmdldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGFyZ2V0c1tpbmRleF1bX2luc3RhbmNlUHJvcGVydHlTdHJpbmddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSkoKTtcclxuICAgICAgICB2YXIgUExVR0lOID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF9wbHVnaW47XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luc0dsb2JhbHM7XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luc0F1dG9VcGRhdGVMb29wO1xyXG4gICAgICAgICAgICB2YXIgX3BsdWdpbnNFeHRlbnNpb25zID0gW107XHJcbiAgICAgICAgICAgIHZhciBfcGx1Z2luc09wdGlvbnMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBDT01QQVRJQklMSVRZLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVUZW1wbGF0ZVR5cGVzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLmIsIC8vYm9vbGVhblxyXG4gICAgICAgICAgICAgICAgICAgIFRZUEVTLm4sIC8vbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMucywgLy9zdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5hLCAvL2FycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMubywgLy9vYmplY3RcclxuICAgICAgICAgICAgICAgICAgICBUWVBFUy5mLCAvL2Z1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgVFlQRVMueiAgLy9udWxsXHJcbiAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRTdHJpbmdzU3BsaXQgPSAnICc7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdHJpY3RlZFN0cmluZ3NQb3NzaWJpbGl0aWVzU3BsaXQgPSAnOic7XHJcbiAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lQWxsb3dlZFZhbHVlcyA9IFtUWVBFUy56LCBUWVBFUy5zXTtcclxuICAgICAgICAgICAgICAgIHZhciBudW1iZXJBbGxvd2VkVmFsdWVzID0gVFlQRVMubjtcclxuICAgICAgICAgICAgICAgIHZhciBib29sZWFuTnVsbEFsbG93ZWRWYWx1ZXMgPSBbVFlQRVMueiwgVFlQRVMuYl07XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9vbGVhblRydWVUZW1wbGF0ZSA9IFt0cnVlLCBUWVBFUy5iXTtcclxuICAgICAgICAgICAgICAgIHZhciBib29sZWFuRmFsc2VUZW1wbGF0ZSA9IFtmYWxzZSwgVFlQRVMuYl07XHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tUZW1wbGF0ZSA9IFtudWxsLCBbVFlQRVMueiwgVFlQRVMuZl1dO1xyXG4gICAgICAgICAgICAgICAgdmFyIHVwZGF0ZU9uTG9hZFRlbXBsYXRlID0gW1snaW1nJ10sIFtUWVBFUy5zLCBUWVBFUy5hLCBUWVBFUy56XV07XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5oZXJpdGVkQXR0cnNUZW1wbGF0ZSA9IFtbJ3N0eWxlJywgJ2NsYXNzJ10sIFtUWVBFUy5zLCBUWVBFUy5hLCBUWVBFUy56XV07XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzaXplQWxsb3dlZFZhbHVlcyA9ICduOm5vbmUgYjpib3RoIGg6aG9yaXpvbnRhbCB2OnZlcnRpY2FsJztcclxuICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9yQWxsb3dlZFZhbHVlcyA9ICd2LWg6dmlzaWJsZS1oaWRkZW4gdi1zOnZpc2libGUtc2Nyb2xsIHM6c2Nyb2xsIGg6aGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eUFsbG93ZWRWYWx1ZXMgPSAndjp2aXNpYmxlIGg6aGlkZGVuIGE6YXV0byc7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0F1dG9IaWRlQWxsb3dlZFZhbHVlcyA9ICduOm5ldmVyIHM6c2Nyb2xsIGw6bGVhdmUgbTptb3ZlJztcclxuICAgICAgICAgICAgICAgIHZhciBvcHRpb25zRGVmYXVsdHNBbmRUZW1wbGF0ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFsnb3MtdGhlbWUtZGFyaycsIGNsYXNzTmFtZUFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAvL251bGwgfHwgc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgcmVzaXplOiBbJ25vbmUnLCByZXNpemVBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub25lIHx8IGJvdGggIHx8IGhvcml6b250YWwgfHwgdmVydGljYWwgfHwgbiB8fCBiIHx8IGggfHwgdlxyXG4gICAgICAgICAgICAgICAgICAgIHNpemVBdXRvQ2FwYWJsZTogYm9vbGVhblRydWVUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGNsaXBBbHdheXM6IGJvb2xlYW5UcnVlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZVJUTDogYm9vbGVhblRydWVUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdBYnNvbHV0ZTogYm9vbGVhbkZhbHNlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGU6IFtudWxsLCBib29sZWFuTnVsbEFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZUludGVydmFsOiBbMzMsIG51bWJlckFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgICAgLy9udW1iZXJcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVPbkxvYWQ6IHVwZGF0ZU9uTG9hZFRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0cmluZyB8fCBhcnJheSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dOYXRpdmVTY3JvbGxiYXJzOiBib29sZWFuRmFsc2VUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemU6IGJvb2xlYW5UcnVlVGVtcGxhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy90cnVlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0JlaGF2aW9yOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IFsnc2Nyb2xsJywgb3ZlcmZsb3dCZWhhdmlvckFsbG93ZWRWYWx1ZXNdLCAgICAgICAgICAgICAgICAgICAgLy92aXNpYmxlLWhpZGRlbiAgfHwgdmlzaWJsZS1zY3JvbGwgfHwgaGlkZGVuIHx8IHNjcm9sbCB8fCB2LWggfHwgdi1zIHx8IGggfHwgc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBbJ3Njcm9sbCcsIG92ZXJmbG93QmVoYXZpb3JBbGxvd2VkVmFsdWVzXSAgICAgICAgICAgICAgICAgICAgIC8vdmlzaWJsZS1oaWRkZW4gIHx8IHZpc2libGUtc2Nyb2xsIHx8IGhpZGRlbiB8fCBzY3JvbGwgfHwgdi1oIHx8IHYtcyB8fCBoIHx8IHNcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogWydhdXRvJywgc2Nyb2xsYmFyc1Zpc2liaWxpdHlBbGxvd2VkVmFsdWVzXSwgICAgICAgICAvL3Zpc2libGUgfHwgaGlkZGVuIHx8IGF1dG8gfHwgdiB8fCBoIHx8IGFcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0hpZGU6IFsnbmV2ZXInLCBzY3JvbGxiYXJzQXV0b0hpZGVBbGxvd2VkVmFsdWVzXSwgICAgICAgICAgICAvL25ldmVyIHx8IHNjcm9sbCB8fCBsZWF2ZSB8fCBtb3ZlIHx8IG4gfHwgcyB8fCBsIHx8IG1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b0hpZGVEZWxheTogWzgwMCwgbnVtYmVyQWxsb3dlZFZhbHVlc10sICAgICAgICAgICAgICAgICAgICAgICAvL251bWJlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnU2Nyb2xsaW5nOiBib29sZWFuVHJ1ZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlja1Njcm9sbGluZzogYm9vbGVhbkZhbHNlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3VjaFN1cHBvcnQ6IGJvb2xlYW5UcnVlVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwSGFuZGxlOiBib29sZWFuRmFsc2VUZW1wbGF0ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSB8fCBmYWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHluV2lkdGg6IGJvb2xlYW5GYWxzZVRlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHluSGVpZ2h0OiBib29sZWFuRmFsc2VUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgfHwgZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5oZXJpdGVkQXR0cnM6IGluaGVyaXRlZEF0dHJzVGVtcGxhdGUgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3N0cmluZyB8fCBhcnJheSB8fCBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Jbml0aWFsaXplZDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Jbml0aWFsaXphdGlvbldpdGhkcmF3bjogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25EZXN0cm95ZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxTdGFydDogY2FsbGJhY2tUZW1wbGF0ZSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGw6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxTdG9wOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25PdmVyZmxvd0NoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25PdmVyZmxvd0Ftb3VudENoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25EaXJlY3Rpb25DaGFuZ2VkOiBjYWxsYmFja1RlbXBsYXRlLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Db250ZW50U2l6ZUNoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25Ib3N0U2l6ZUNoYW5nZWQ6IGNhbGxiYWNrVGVtcGxhdGUsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25VcGRhdGVkOiBjYWxsYmFja1RlbXBsYXRlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL251bGwgfHwgZnVuY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbnZlcnQgPSBmdW5jdGlvbiAodGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdXJzaXZlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ialtMRVhJQ09OLmhPUF0oa2V5KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsVHlwZSA9IHR5cGUodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxUeXBlID09IFRZUEVTLmEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSB2YWxbdGVtcGxhdGUgPyAxIDogMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWxUeXBlID09IFRZUEVTLm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSByZWN1cnNpdmUodmFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3Vyc2l2ZShGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zRGVmYXVsdHNBbmRUZW1wbGF0ZSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIF9kZWZhdWx0czogY29udmVydCgpLFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfdGVtcGxhdGU6IGNvbnZlcnQodHJ1ZSksXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIFZhbGlkYXRlcyB0aGUgcGFzc2VkIG9iamVjdCBieSB0aGUgcGFzc2VkIHRlbXBsYXRlLlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB3aGljaCBzaGFsbCBiZSB2YWxpZGF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHRlbXBsYXRlIFRoZSB0ZW1wbGF0ZSB3aGljaCBkZWZpbmVzIHRoZSBhbGxvd2VkIHZhbHVlcyBhbmQgdHlwZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHdyaXRlRXJyb3JzIFRydWUgaWYgZXJyb3JzIHNoYWxsIGJlIGxvZ2dlZCB0byB0aGUgY29uc29sZS5cclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGlmZk9iaiBJZiBhIG9iamVjdCBpcyBwYXNzZWQgdGhlbiBvbmx5IHZhbGlkIGRpZmZlcmVuY2VzIHRvIHRoaXMgb2JqZWN0IHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3t9fSBBIG9iamVjdCB3aGljaCBjb250YWlucyB0d28gb2JqZWN0cyBjYWxsZWQgXCJkZWZhdWx0XCIgYW5kIFwicHJlcGFyZWRcIiB3aGljaCBjb250YWlucyBvbmx5IHRoZSB2YWxpZCBwcm9wZXJ0aWVzIG9mIHRoZSBwYXNzZWQgb3JpZ2luYWwgb2JqZWN0IGFuZCBkaXNjYXJkcyBub3QgZGlmZmVyZW50IHZhbHVlcyBjb21wYXJlZCB0byB0aGUgcGFzc2VkIGRpZmZPYmouXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgX3ZhbGlkYXRlOiBmdW5jdGlvbiAob2JqLCB0ZW1wbGF0ZSwgd3JpdGVFcnJvcnMsIGRpZmZPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlZE9wdGlvbnMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0Q29weSA9IEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbkFycmF5ID0gRlJBTUVXT1JLLmluQXJyYXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0VtcHR5T2JqID0gRlJBTUVXT1JLLmlzRW1wdHlPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVja09iamVjdFByb3BzID0gZnVuY3Rpb24gKGRhdGEsIHRlbXBsYXRlLCBkaWZmRGF0YSwgdmFsaWRhdGVkT3B0aW9ucywgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkLCBwcmV2UHJvcE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gdGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVbTEVYSUNPTi5oT1BdKHByb3ApICYmIGRhdGFbTEVYSUNPTi5oT1BdKHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0RpZmYgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVmFsdWUgPSB0ZW1wbGF0ZVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVmFsdWVUeXBlID0gdHlwZSh0ZW1wbGF0ZVZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlSXNDb21wbGV4ID0gdGVtcGxhdGVWYWx1ZVR5cGUgPT0gVFlQRVMubztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVHlwZXMgPSAhQ09NUEFUSUJJTElUWS5pc0EodGVtcGxhdGVWYWx1ZSkgPyBbdGVtcGxhdGVWYWx1ZV0gOiB0ZW1wbGF0ZVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YURpZmZWYWx1ZSA9IGRpZmZEYXRhW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVZhbHVlID0gZGF0YVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGFWYWx1ZVR5cGUgPSB0eXBlKGRhdGFWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wUHJlZml4ID0gcHJldlByb3BOYW1lID8gcHJldlByb3BOYW1lICsgJy4nIDogJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IFwiVGhlIG9wdGlvbiBcXFwiXCIgKyBwcm9wUHJlZml4ICsgcHJvcCArIFwiXFxcIiB3YXNuJ3Qgc2V0LCBiZWNhdXNlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvclBvc3NpYmxlVHlwZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yUmVzdHJpY3RlZFN0cmluZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1Jlc3RyaWN0ZWRWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1haW5Qb3NzaWJpbGl0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJUeXBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YURpZmZWYWx1ZSA9IGRhdGFEaWZmVmFsdWUgPT09IHVuZGVmaW5lZCA/IHt9IDogZGF0YURpZmZWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIHRlbXBsYXRlIGhhcyBhIG9iamVjdCBhcyB2YWx1ZSwgaXQgbWVhbnMgdGhhdCB0aGUgb3B0aW9ucyBhcmUgY29tcGxleCAodmVyc2NoYWNodGVsdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlSXNDb21wbGV4ICYmIGRhdGFWYWx1ZVR5cGUgPT0gVFlQRVMubykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkT3B0aW9uc1twcm9wXSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkW3Byb3BdID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja09iamVjdFByb3BzKGRhdGFWYWx1ZSwgdGVtcGxhdGVWYWx1ZSwgZGF0YURpZmZWYWx1ZSwgdmFsaWRhdGVkT3B0aW9uc1twcm9wXSwgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkW3Byb3BdLCBwcm9wUHJlZml4ICsgcHJvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZWFjaChbZGF0YSwgdmFsaWRhdGVkT3B0aW9ucywgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkXSwgZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5T2JqKHZhbHVlW3Byb3BdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRlbXBsYXRlSXNDb21wbGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGVtcGxhdGVUeXBlc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVHlwZSA9IHRlbXBsYXRlVHlwZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVWYWx1ZVR5cGUgPSB0eXBlKGN1cnJUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGN1cnJ0eXBlIGlzIHN0cmluZyBhbmQgc3RhcnRzIHdpdGggcmVzdHJpY3RlZFN0cmluZ1ByZWZpeCBhbmQgZW5kIHdpdGggcmVzdHJpY3RlZFN0cmluZ1N1ZmZpeFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVzdHJpY3RlZFZhbHVlID0gdGVtcGxhdGVWYWx1ZVR5cGUgPT0gVFlQRVMucyAmJiBpbkFycmF5KGN1cnJUeXBlLCBwb3NzaWJsZVRlbXBsYXRlVHlwZXMpID09PSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZXN0cmljdGVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JQb3NzaWJsZVR5cGVzLnB1c2goVFlQRVMucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NwbGl0IGl0IGludG8gYSBhcnJheSB3aGljaCBjb250YWlucyBhbGwgcG9zc2libGUgdmFsdWVzIGZvciBleGFtcGxlOiBbXCJ5Onllc1wiLCBcIm46bm9cIiwgXCJtOm1heWJlXCJdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdCA9IGN1cnJUeXBlLnNwbGl0KHJlc3RyaWN0ZWRTdHJpbmdzU3BsaXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclJlc3RyaWN0ZWRTdHJpbmdzID0gZXJyb3JSZXN0cmljdGVkU3RyaW5ncy5jb25jYXQocmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1NwbGl0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2ID0gMDsgdiA8IHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNTcGxpdFtMRVhJQ09OLmxdOyB2KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3BsaXQgdGhlIHBvc3NpYmxlIHZhbHVlcyBpbnRvIHRoZWlyIHBvc3NpYmlsaXRlaXMgZm9yIGV4YW1wbGU6IFtcInlcIiwgXCJ5ZXNcIl0gLT4gdGhlIGZpcnN0IGlzIGFsd2F5cyB0aGUgbWFpblBvc3NpYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0ID0gcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1NwbGl0W3ZdLnNwbGl0KHJlc3RyaWN0ZWRTdHJpbmdzUG9zc2liaWxpdGllc1NwbGl0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Qb3NzaWJpbGl0eSA9IHJlc3RyaWN0ZWRTdHJpbmdWYWx1ZXNQb3NzaWJpbGl0aWVzU3BsaXRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdFtMRVhJQ09OLmxdOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIGFueSBwb3NzaWJpbGl0eSBtYXRjaGVzIHdpdGggdGhlIGRhdGFWYWx1ZSwgaXRzIHZhbGlkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFWYWx1ZSA9PT0gcmVzdHJpY3RlZFN0cmluZ1ZhbHVlc1Bvc3NpYmlsaXRpZXNTcGxpdFtqXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yUG9zc2libGVUeXBlcy5wdXNoKGN1cnJUeXBlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhVmFsdWVUeXBlID09PSBjdXJyVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGlmZiA9IGRhdGFWYWx1ZSAhPT0gZGF0YURpZmZWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlmZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVkT3B0aW9uc1twcm9wXSA9IGRhdGFWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVzdHJpY3RlZFZhbHVlID8gaW5BcnJheShkYXRhRGlmZlZhbHVlLCByZXN0cmljdGVkU3RyaW5nVmFsdWVzUG9zc2liaWxpdGllc1NwbGl0KSA8IDAgOiBpc0RpZmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlZE9wdGlvbnNQcmVwYXJlZFtwcm9wXSA9IGlzUmVzdHJpY3RlZFZhbHVlID8gbWFpblBvc3NpYmlsaXR5IDogZGF0YVZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod3JpdGVFcnJvcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IgKyBcIiBpdCBkb2Vzbid0IGFjY2VwdCB0aGUgdHlwZSBbIFwiICsgZGF0YVZhbHVlVHlwZS50b1VwcGVyQ2FzZSgpICsgXCIgXSB3aXRoIHRoZSB2YWx1ZSBvZiBcXFwiXCIgKyBkYXRhVmFsdWUgKyBcIlxcXCIuXFxyXFxuXCIgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFjY2VwdGVkIHR5cGVzIGFyZTogWyBcIiArIGVycm9yUG9zc2libGVUeXBlcy5qb2luKCcsICcpLnRvVXBwZXJDYXNlKCkgKyBcIiBdLlwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVycm9yUmVzdHJpY3RlZFN0cmluZ3NbbGVuZ3RoXSA+IDAgPyBcIlxcclxcblZhbGlkIHN0cmluZ3MgYXJlOiBbIFwiICsgZXJyb3JSZXN0cmljdGVkU3RyaW5ncy5qb2luKCcsICcpLnNwbGl0KHJlc3RyaWN0ZWRTdHJpbmdzUG9zc2liaWxpdGllc1NwbGl0KS5qb2luKCcsICcpICsgXCIgXS5cIiA6ICcnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YVtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tPYmplY3RQcm9wcyhvYmplY3RDb3B5LCB0ZW1wbGF0ZSwgZGlmZk9iaiB8fCB7fSwgdmFsaWRhdGVkT3B0aW9ucywgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHZhbHVlcyB3aGljaCBhcmVuJ3Qgc3BlY2lmaWVkIGluIHRoZSB0ZW1wbGF0ZSB0byB0aGUgZmluaXNoZWQgdmFsaWRhdGVkIG9iamVjdCB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZyBkaXNjYXJkZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoa2VlcEZvcmVpZ25Qcm9wcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB2YWxpZGF0ZWRPcHRpb25zLCBvYmplY3RDb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5leHRlbmQodHJ1ZSwgdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkLCBvYmplY3RDb3B5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqKG9iamVjdENvcHkpICYmIHdyaXRlRXJyb3JzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdUaGUgZm9sbG93aW5nIG9wdGlvbnMgYXJlIGRpc2NhcmRlZCBkdWUgdG8gaW52YWxpZGl0eTpcXHJcXG4nICsgd2luZG93LkpTT04uc3RyaW5naWZ5KG9iamVjdENvcHksIG51bGwsIDIpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdDogdmFsaWRhdGVkT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVwYXJlZDogdmFsaWRhdGVkT3B0aW9uc1ByZXBhcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KCkpO1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBvYmplY3Qgd2hpY2ggY29udGFpbnMgZ2xvYmFsIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwbHVnaW4gYW5kIGVhY2ggaW5zdGFuY2Ugb2YgaXQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBpbml0T3ZlcmxheVNjcm9sbGJhcnNTdGF0aWNzKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfcGx1Z2luc0dsb2JhbHMpXHJcbiAgICAgICAgICAgICAgICAgICAgX3BsdWdpbnNHbG9iYWxzID0gbmV3IE92ZXJsYXlTY3JvbGxiYXJzR2xvYmFscyhfcGx1Z2luc09wdGlvbnMuX2RlZmF1bHRzKTtcclxuICAgICAgICAgICAgICAgIGlmICghX3BsdWdpbnNBdXRvVXBkYXRlTG9vcClcclxuICAgICAgICAgICAgICAgICAgICBfcGx1Z2luc0F1dG9VcGRhdGVMb29wID0gbmV3IE92ZXJsYXlTY3JvbGxiYXJzQXV0b1VwZGF0ZUxvb3AoX3BsdWdpbnNHbG9iYWxzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBnbG9iYWwgb2JqZWN0IGZvciB0aGUgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0cy4gSXQgY29udGFpbnMgcmVzb3VyY2VzIHdoaWNoIGV2ZXJ5IE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdCBuZWVkcy4gVGhpcyBvYmplY3QgaXMgaW5pdGlhbGl6ZWQgb25seSBvbmNlOiBpZiB0aGUgZmlyc3QgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0IGdldHMgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBkZWZhdWx0T3B0aW9uc1xyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE92ZXJsYXlTY3JvbGxiYXJzR2xvYmFscyhkZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iYXNlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBzdHJPdmVyZmxvdyA9ICdvdmVyZmxvdyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RySGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgICAgICB2YXIgc3RyU2Nyb2xsID0gJ3Njcm9sbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgYm9keUVsZW1lbnQgPSBGUkFNRVdPUksoJ2JvZHknKTtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJEdW1teUVsZW1lbnQgPSBGUkFNRVdPUksoJzxkaXYgaWQ9XCJvcy1kdW1teS1zY3JvbGxiYXItc2l6ZVwiPjxkaXY+PC9kaXY+PC9kaXY+Jyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyRHVtbXlFbGVtZW50MCA9IHNjcm9sbGJhckR1bW15RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgIHZhciBkdW1teUNvbnRhaW5lckNoaWxkID0gRlJBTUVXT1JLKHNjcm9sbGJhckR1bW15RWxlbWVudC5jaGlsZHJlbignZGl2JykuZXEoMCkpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LmFwcGVuZChzY3JvbGxiYXJEdW1teUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmhpZGUoKS5zaG93KCk7IC8vZml4IElFOCBidWcgKGluY29ycmVjdCBtZWFzdXJpbmcpXHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVNjcm9sbGJhclNpemUgPSBjYWxjTmF0aXZlU2Nyb2xsYmFyU2l6ZShzY3JvbGxiYXJEdW1teUVsZW1lbnQwKTtcclxuICAgICAgICAgICAgICAgIHZhciBuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IG5hdGl2ZVNjcm9sbGJhclNpemUueCA9PT0gMCxcclxuICAgICAgICAgICAgICAgICAgICB5OiBuYXRpdmVTY3JvbGxiYXJTaXplLnkgPT09IDBcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB2YXIgbXNpZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckluZGV4T2YgPSAnaW5kZXhPZic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clN1YlN0cmluZyA9ICdzdWJzdHJpbmcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2llID0gdWFbc3RySW5kZXhPZl0oJ01TSUUgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWRlbnQgPSB1YVtzdHJJbmRleE9mXSgnVHJpZGVudC8nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IHVhW3N0ckluZGV4T2ZdKCdFZGdlLycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydiA9IHVhW3N0ckluZGV4T2ZdKCdydjonKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZUludEZ1bmMgPSBwYXJzZUludDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgMTAgb3Igb2xkZXIgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zaWUgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwYXJzZUludEZ1bmModWFbc3RyU3ViU3RyaW5nXShtc2llICsgNSwgdWFbc3RySW5kZXhPZl0oJy4nLCBtc2llKSksIDEwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJpZGVudCA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50RnVuYyh1YVtzdHJTdWJTdHJpbmddKHJ2ICsgMywgdWFbc3RySW5kZXhPZl0oJy4nLCBydikpLCAxMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZWRnZSA+IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHBhcnNlSW50RnVuYyh1YVtzdHJTdWJTdHJpbmddKGVkZ2UgKyA1LCB1YVtzdHJJbmRleE9mXSgnLicsIGVkZ2UpKSwgMTApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlciBicm93c2VyXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgRlJBTUVXT1JLLmV4dGVuZChfYmFzZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiBkZWZhdWx0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtc2llOiBtc2llLFxyXG4gICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGVMb29wOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICBhdXRvVXBkYXRlUmVjb21tZW5kZWQ6ICFDT01QQVRJQklMSVRZLm1PKCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFyU2l6ZTogbmF0aXZlU2Nyb2xsYmFyU2l6ZSxcclxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkOiBuYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLFxyXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZVNjcm9sbGJhclN0eWxpbmc6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmFkZENsYXNzKCdvcy12aWV3cG9ydC1uYXRpdmUtc2Nyb2xsYmFycy1pbnZpc2libGUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IChzY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKCdzY3JvbGxiYXItd2lkdGgnKSA9PT0gJ25vbmUnICYmIChtc2llID4gOSB8fCAhbXNpZSkpIHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGJhckR1bW15RWxlbWVudDAsICc6Oi13ZWJraXQtc2Nyb2xsYmFyJykuZ2V0UHJvcGVydHlWYWx1ZSgnZGlzcGxheScpID09PSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7IH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vZml4IG9wZXJhIGJ1Zzogc2Nyb2xsYmFyIHN0eWxlcyB3aWxsIG9ubHkgYXBwZWFyIGlmIG92ZXJmbG93IHZhbHVlIGlzIHNjcm9sbCBvciBhdXRvIGR1cmluZyB0aGUgYWN0aXZhdGlvbiBvZiB0aGUgc3R5bGUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYW5kIHNldCBvdmVyZmxvdyB0byBzY3JvbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKHN0ck92ZXJmbG93LCBzdHJIaWRkZW4pLmhpZGUoKS5jc3Moc3RyT3ZlcmZsb3csIHN0clNjcm9sbCkuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JldHVybiAoc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLm9IXSAtIHNjcm9sbGJhckR1bW15RWxlbWVudDBbTEVYSUNPTi5jSF0pID09PSAwICYmIChzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04ub1ddIC0gc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLmNXXSkgPT09IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZTogeyB4OiAzMCwgeTogMzAgfSxcclxuICAgICAgICAgICAgICAgICAgICBjc3NDYWxjOiBWRU5ET1JTLl9jc3NQcm9wZXJ0eVZhbHVlKCd3aWR0aCcsICdjYWxjJywgJygxcHgpJykgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICByZXN0cmljdGVkTWVhc3VyaW5nOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2h0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTE0MzkzMDVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zaW5jZSAxLjExLjAgYWx3YXlzIGZhbHNlIC0+IGZpeGVkIHZpYSBDU1MgKGhvcGVmdWxseSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LmNzcyhzdHJPdmVyZmxvdywgc3RySGlkZGVuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uc1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLnNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKHN0ck92ZXJmbG93LCAndmlzaWJsZScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsU2l6ZTIgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBzY3JvbGxiYXJEdW1teUVsZW1lbnQwW0xFWElDT04uc1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogc2Nyb2xsYmFyRHVtbXlFbGVtZW50MFtMRVhJQ09OLnNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHNjcm9sbFNpemUudyAtIHNjcm9sbFNpemUyLncpICE9PSAwIHx8IChzY3JvbGxTaXplLmggLSBzY3JvbGxTaXplMi5oKSAhPT0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ0bFNjcm9sbEJlaGF2aW9yOiAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQuY3NzKHsgJ292ZXJmbG93LXknOiBzdHJIaWRkZW4sICdvdmVyZmxvdy14Jzogc3RyU2Nyb2xsLCAnZGlyZWN0aW9uJzogJ3J0bCcgfSkuc2Nyb2xsTGVmdCgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR1bW15Q29udGFpbmVyT2Zmc2V0ID0gc2Nyb2xsYmFyRHVtbXlFbGVtZW50Lm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVtbXlDb250YWluZXJDaGlsZE9mZnNldCA9IGR1bW15Q29udGFpbmVyQ2hpbGQub2Zmc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL0tpbmdTb3JhL092ZXJsYXlTY3JvbGxiYXJzL2lzc3Vlcy8xODdcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyRHVtbXlFbGVtZW50LnNjcm9sbExlZnQoLTk5OSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkdW1teUNvbnRhaW5lckNoaWxkT2Zmc2V0QWZ0ZXJTY3JvbGwgPSBkdW1teUNvbnRhaW5lckNoaWxkLm9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vcmlnaW4gZGlyZWN0aW9uID0gZGV0ZXJtaW5lcyBpZiB0aGUgemVybyBzY3JvbGwgcG9zaXRpb24gaXMgb24gdGhlIGxlZnQgb3IgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8naScgbWVhbnMgJ2ludmVydCcgKGkgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgYXhpcyBtdXN0IGJlIGludmVydGVkIHRvIGJlIGNvcnJlY3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RydWUgPSBvbiB0aGUgbGVmdCBzaWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZhbHNlID0gb24gdGhlIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk6IGR1bW15Q29udGFpbmVyT2Zmc2V0LmxlZnQgPT09IGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQubGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbmVnYXRpdmUgPSBkZXRlcm1pbmVzIGlmIHRoZSBtYXhpbXVtIHNjcm9sbCBpcyBwb3NpdGl2ZSBvciBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8nbicgbWVhbnMgJ25lZ2F0ZScgKG4gPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgYXhpcyBtdXN0IGJlIG5lZ2F0ZWQgdG8gYmUgY29ycmVjdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ1ZSA9IG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZhbHNlID0gcG9zaXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG46IGR1bW15Q29udGFpbmVyQ2hpbGRPZmZzZXQubGVmdCAhPT0gZHVtbXlDb250YWluZXJDaGlsZE9mZnNldEFmdGVyU2Nyb2xsLmxlZnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRUcmFuc2Zvcm06ICEhVkVORE9SUy5fY3NzUHJvcGVydHkoJ3RyYW5zZm9ybScpLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRUcmFuc2l0aW9uOiAhIVZFTkRPUlMuX2Nzc1Byb3BlcnR5KCd0cmFuc2l0aW9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydFBhc3NpdmVFdmVudHM6IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydFJlc2l6ZU9ic2VydmVyOiAhIUNPTVBBVElCSUxJVFkuck8oKSxcclxuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0TXV0YXRpb25PYnNlcnZlcjogISFDT01QQVRJQklMSVRZLm1PKClcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHNjcm9sbGJhckR1bW15RWxlbWVudC5yZW1vdmVBdHRyKExFWElDT04ucykucmVtb3ZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9DYXRjaCB6b29tIGV2ZW50OlxyXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIG5hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWJzID0gTUFUSC5hYnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd1dpZHRoID0gQ09NUEFUSUJJTElUWS53VygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aW5kb3dIZWlnaHQgPSBDT01QQVRJQklMSVRZLndIKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpbmRvd0RwciA9IGdldFdpbmRvd0RQUigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKElOU1RBTkNFUygpLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdXID0gQ09NUEFUSUJJTElUWS53VygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0ggPSBDT01QQVRJQklMSVRZLndIKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFXID0gbmV3VyAtIHdpbmRvd1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhSCA9IG5ld0ggLSB3aW5kb3dIZWlnaHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbHRhVyA9PT0gMCAmJiBkZWx0YUggPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YVdSYXRpbyA9IE1BVEgucm91bmQobmV3VyAvICh3aW5kb3dXaWR0aCAvIDEwMC4wKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsdGFIUmF0aW8gPSBNQVRILnJvdW5kKG5ld0ggLyAod2luZG93SGVpZ2h0IC8gMTAwLjApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNEZWx0YVcgPSBhYnMoZGVsdGFXKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNEZWx0YUggPSBhYnMoZGVsdGFIKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNEZWx0YVdSYXRpbyA9IGFicyhkZWx0YVdSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWJzRGVsdGFIUmF0aW8gPSBhYnMoZGVsdGFIUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0RQUiA9IGdldFdpbmRvd0RQUigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YUlzQmlnZ2VyID0gYWJzRGVsdGFXID4gMiAmJiBhYnNEZWx0YUggPiAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAhZGlmZmVyZW5jZUlzQmlnZ2VyVGhhbk9uZShhYnNEZWx0YVdSYXRpbywgYWJzRGVsdGFIUmF0aW8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRwckNoYW5nZWQgPSBuZXdEUFIgIT09IHdpbmRvd0RwciAmJiB3aW5kb3dEcHIgPiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzWm9vbSA9IGRlbHRhSXNCaWdnZXIgJiYgZGlmZmVyZW5jZSAmJiBkcHJDaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9sZFNjcm9sbGJhclNpemUgPSBfYmFzZS5uYXRpdmVTY3JvbGxiYXJTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Njcm9sbGJhclNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzWm9vbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlFbGVtZW50LmFwcGVuZChzY3JvbGxiYXJEdW1teUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Njcm9sbGJhclNpemUgPSBfYmFzZS5uYXRpdmVTY3JvbGxiYXJTaXplID0gY2FsY05hdGl2ZVNjcm9sbGJhclNpemUoc2Nyb2xsYmFyRHVtbXlFbGVtZW50WzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJEdW1teUVsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9sZFNjcm9sbGJhclNpemUueCAhPT0gbmV3U2Nyb2xsYmFyU2l6ZS54IHx8IG9sZFNjcm9sbGJhclNpemUueSAhPT0gbmV3U2Nyb2xsYmFyU2l6ZS55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5lYWNoKElOU1RBTkNFUygpLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoSU5TVEFOQ0VTKHRoaXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOU1RBTkNFUyh0aGlzKS51cGRhdGUoJ3pvb20nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gbmV3VztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd0hlaWdodCA9IG5ld0g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dEcHIgPSBuZXdEUFI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkaWZmZXJlbmNlSXNCaWdnZXJUaGFuT25lKHZhbE9uZSwgdmFsVHdvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhYnNWYWxPbmUgPSBhYnModmFsT25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFic1ZhbFR3byA9IGFicyh2YWxUd28pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIShhYnNWYWxPbmUgPT09IGFic1ZhbFR3byB8fCBhYnNWYWxPbmUgKyAxID09PSBhYnNWYWxUd28gfHwgYWJzVmFsT25lIC0gMSA9PT0gYWJzVmFsVHdvKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldFdpbmRvd0RQUigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGREUEkgPSB3aW5kb3cuc2NyZWVuLmRldmljZVhEUEkgfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNEUEkgPSB3aW5kb3cuc2NyZWVuLmxvZ2ljYWxYRFBJIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAoZERQSSAvIHNEUEkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLKHdpbmRvdykub24oJ3Jlc2l6ZScsIG9uUmVzaXplKTtcclxuICAgICAgICAgICAgICAgIH0pKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FsY05hdGl2ZVNjcm9sbGJhclNpemUobWVhc3VyZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtZWFzdXJlRWxlbWVudFtMRVhJQ09OLm9IXSAtIG1lYXN1cmVFbGVtZW50W0xFWElDT04uY0hdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtZWFzdXJlRWxlbWVudFtMRVhJQ09OLm9XXSAtIG1lYXN1cmVFbGVtZW50W0xFWElDT04uY1ddXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBvYmplY3Qgd2hpY2ggbWFuYWdlcyB0aGUgYXV0byB1cGRhdGUgbG9vcCBmb3IgYWxsIE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdHMuIFRoaXMgb2JqZWN0IGlzIGluaXRpYWxpemVkIG9ubHkgb25jZTogaWYgdGhlIGZpcnN0IE92ZXJsYXlTY3JvbGxiYXJzIG9iamVjdCBnZXRzIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIE92ZXJsYXlTY3JvbGxiYXJzQXV0b1VwZGF0ZUxvb3AoZ2xvYmFscykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iYXNlID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHZhciBfaW5BcnJheSA9IEZSQU1FV09SSy5pbkFycmF5O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9nZXROb3cgPSBDT01QQVRJQklMSVRZLm5vdztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyQXV0b1VwZGF0ZSA9ICdhdXRvVXBkYXRlJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyQXV0b1VwZGF0ZUludGVydmFsID0gX3N0ckF1dG9VcGRhdGUgKyAnSW50ZXJ2YWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJMZW5ndGggPSBMRVhJQ09OLmw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BpbmdJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcGluZ0luc3RhbmNlc0ludGVydmFsQ2FjaGUgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcElzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BJbnRlcnZhbERlZmF1bHQgPSAzMztcclxuICAgICAgICAgICAgICAgIHZhciBfbG9vcEludGVydmFsID0gX2xvb3BJbnRlcnZhbERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xvb3BUaW1lT2xkID0gX2dldE5vdygpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wSUQ7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIGF1dG8gdXBkYXRlIGxvb3Agd2hpY2ggd2lsbCBydW4gZXZlcnkgNTAgbWlsbGlzZWNvbmRzIG9yIGxlc3MgaWYgdGhlIHVwZGF0ZSBpbnRlcnZhbCBvZiBhIGluc3RhbmNlIGlzIGxvd2VyIHRoYW4gNTAgbWlsbGlzZWNvbmRzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xvb3BpbmdJbnN0YW5jZXNbX3N0ckxlbmd0aF0gPiAwICYmIF9sb29wSXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJRCA9IENPTVBBVElCSUxJVFkuckFGKCkoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVOZXcgPSBfZ2V0Tm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aW1lRGVsdGEgPSB0aW1lTmV3IC0gX2xvb3BUaW1lT2xkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG93ZXN0SW50ZXJ2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlT3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlQXV0b1VwZGF0ZUFsbG93ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vdztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aW1lRGVsdGEgPiBfbG9vcEludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcFRpbWVPbGQgPSB0aW1lTmV3IC0gKHRpbWVEZWx0YSAlIF9sb29wSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0SW50ZXJ2YWwgPSBfbG9vcEludGVydmFsRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX2xvb3BpbmdJbnN0YW5jZXNbX3N0ckxlbmd0aF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gX2xvb3BpbmdJbnN0YW5jZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VPcHRpb25zID0gaW5zdGFuY2Uub3B0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUF1dG9VcGRhdGVBbGxvd2VkID0gaW5zdGFuY2VPcHRpb25zW19zdHJBdXRvVXBkYXRlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VBdXRvVXBkYXRlSW50ZXJ2YWwgPSBNQVRILm1heCgxLCBpbnN0YW5jZU9wdGlvbnNbX3N0ckF1dG9VcGRhdGVJbnRlcnZhbF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3cgPSBfZ2V0Tm93KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGluc3RhbmNlQXV0b1VwZGF0ZUFsbG93ZWQgPT09IHRydWUgfHwgaW5zdGFuY2VBdXRvVXBkYXRlQWxsb3dlZCA9PT0gbnVsbCkgJiYgKG5vdyAtIF9sb29waW5nSW5zdGFuY2VzSW50ZXJ2YWxDYWNoZVtpXSkgPiBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudXBkYXRlKCdhdXRvJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlc0ludGVydmFsQ2FjaGVbaV0gPSBuZXcgRGF0ZShub3cgKz0gaW5zdGFuY2VBdXRvVXBkYXRlSW50ZXJ2YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RJbnRlcnZhbCA9IE1BVEgubWF4KDEsIE1BVEgubWluKGxvd2VzdEludGVydmFsLCBpbnN0YW5jZUF1dG9VcGRhdGVJbnRlcnZhbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSW50ZXJ2YWwgPSBsb3dlc3RJbnRlcnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSW50ZXJ2YWwgPSBfbG9vcEludGVydmFsRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkIE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIHRvIHRoZSBhdXRvIHVwZGF0ZSBsb29wLiBPbmx5IHN1Y2Nlc3NmdWwgaWYgdGhlIGluc3RhbmNlIGlzbid0IGFscmVhZHkgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaW5zdGFuY2UgVGhlIGluc3RhbmNlIHdoaWNoIHNoYWxsIGJlIHVwZGF0ZWQgaW4gYSBsb29wIGF1dG9tYXRpY2FsbHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLmFkZCA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaW5BcnJheShpbnN0YW5jZSwgX2xvb3BpbmdJbnN0YW5jZXMpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BpbmdJbnN0YW5jZXNJbnRlcnZhbENhY2hlLnB1c2goX2dldE5vdygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9sb29waW5nSW5zdGFuY2VzW19zdHJMZW5ndGhdID4gMCAmJiAhX2xvb3BJc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3BJc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLmF1dG9VcGRhdGVMb29wID0gX2xvb3BJc0FjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UgZnJvbSB0aGUgYXV0byB1cGRhdGUgbG9vcC4gT25seSBzdWNjZXNzZnVsIGlmIHRoZSBpbnN0YW5jZSB3YXMgYWRkZWQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGluc3RhbmNlIFRoZSBpbnN0YW5jZSB3aGljaCBzaGFsbCBiZSB1cGRhdGVkIGluIGEgbG9vcCBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5yZW1vdmUgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBfaW5BcnJheShpbnN0YW5jZSwgX2xvb3BpbmdJbnN0YW5jZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGZyb20gbG9vcGluZ0luc3RhbmNlcyBsaXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29waW5nSW5zdGFuY2VzSW50ZXJ2YWxDYWNoZS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcGluZ0luc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb3JyZWN0IHVwZGF0ZSBsb29wIGJlaGF2aW9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbG9vcGluZ0luc3RhbmNlc1tfc3RyTGVuZ3RoXSA9PT0gMCAmJiBfbG9vcElzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcElzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxzLmF1dG9VcGRhdGVMb29wID0gX2xvb3BJc0FjdGl2ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbG9vcElEICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLmNBRigpKF9sb29wSUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wSUQgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBBIG9iamVjdCB3aGljaCBtYW5hZ2VzIHRoZSBzY3JvbGxiYXJzIHZpc2liaWxpdHkgb2YgdGhlIHRhcmdldCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gcGx1Z2luVGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSBzY3JvbGxiYXJzIHNoYWxsIGJlIGhpZGRlbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGN1c3RvbSBvcHRpb25zLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgY3VzdG9tIGV4dGVuc2lvbnMuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBnbG9iYWxzXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdXRvVXBkYXRlTG9vcFxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBPdmVybGF5U2Nyb2xsYmFyc0luc3RhbmNlKHBsdWdpblRhcmdldEVsZW1lbnQsIG9wdGlvbnMsIGV4dGVuc2lvbnMsIGdsb2JhbHMsIGF1dG9VcGRhdGVMb29wKSB7XHJcbiAgICAgICAgICAgICAgICAvL3Nob3J0Y3V0c1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBDT01QQVRJQklMSVRZLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5BcnJheSA9IEZSQU1FV09SSy5pbkFycmF5O1xyXG4gICAgICAgICAgICAgICAgdmFyIGVhY2ggPSBGUkFNRVdPUksuZWFjaDtcclxuXHJcbiAgICAgICAgICAgICAgICAvL21ha2UgY29ycmVjdCBpbnN0YW5jZW9mXHJcbiAgICAgICAgICAgICAgICB2YXIgX2Jhc2UgPSBuZXcgX3BsdWdpbigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZXdvcmtQcm90byA9IEZSQU1FV09SS1tMRVhJQ09OLnBdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vaWYgcGFzc2VkIGVsZW1lbnQgaXMgbm8gSFRNTCBlbGVtZW50OiBza2lwIGFuZCByZXR1cm5cclxuICAgICAgICAgICAgICAgIGlmICghaXNIVE1MRWxlbWVudChwbHVnaW5UYXJnZXRFbGVtZW50KSlcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy9pZiBwYXNzZWQgZWxlbWVudCBpcyBhbHJlYWR5IGluaXRpYWxpemVkOiBzZXQgcGFzc2VkIG9wdGlvbnMgaWYgdGhlcmUgYXJlIGFueSBhbmQgcmV0dXJuIGl0cyBpbnN0YW5jZVxyXG4gICAgICAgICAgICAgICAgaWYgKElOU1RBTkNFUyhwbHVnaW5UYXJnZXRFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gSU5TVEFOQ0VTKHBsdWdpblRhcmdldEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc3Qub3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvL2dsb2JhbHM6XHJcbiAgICAgICAgICAgICAgICB2YXIgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3J0bFNjcm9sbEJlaGF2aW9yO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hdXRvVXBkYXRlUmVjb21tZW5kZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX21zaWVWZXJzaW9uO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NDYWxjO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9uYXRpdmVTY3JvbGxiYXJTaXplO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdXBwb3J0VHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydFBhc3NpdmVFdmVudHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N1cHBvcnRSZXNpemVPYnNlcnZlcjtcclxuICAgICAgICAgICAgICAgIHZhciBfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc3RyaWN0ZWRNZWFzdXJpbmc7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9nZW5lcmFsIHJlYWRvbmx5OlxyXG4gICAgICAgICAgICAgICAgdmFyIF9pbml0aWFsaXplZDtcclxuICAgICAgICAgICAgICAgIHZhciBfZGVzdHJveWVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pc1RleHRhcmVhO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pc0JvZHk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50TWl4ZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvbUV4aXN0cztcclxuXHJcbiAgICAgICAgICAgICAgICAvL2dlbmVyYWw6XHJcbiAgICAgICAgICAgICAgICB2YXIgX2lzQm9yZGVyQm94O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplQXV0b09ic2VydmVyQWRkZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BhZGRpbmdYO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9wYWRkaW5nWTtcclxuICAgICAgICAgICAgICAgIHZhciBfYm9yZGVyWDtcclxuICAgICAgICAgICAgICAgIHZhciBfYm9yZGVyWTtcclxuICAgICAgICAgICAgICAgIHZhciBfbWFyZ2luWDtcclxuICAgICAgICAgICAgICAgIHZhciBfbWFyZ2luWTtcclxuICAgICAgICAgICAgICAgIHZhciBfaXNSVEw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NsZWVwaW5nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50Qm9yZGVyU2l6ZSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxIb3Jpem9udGFsSW5mbyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxWZXJ0aWNhbEluZm8gPSB7fTtcclxuICAgICAgICAgICAgICAgIHZhciBfdmlld3BvcnRTaXplID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX25hdGl2ZVNjcm9sbGJhck1pblNpemUgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL25hbWluZzpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNaW51c0hpZGRlbiA9ICctaGlkZGVuJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWFyZ2luTWludXMgPSAnbWFyZ2luLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clBhZGRpbmdNaW51cyA9ICdwYWRkaW5nLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckJvcmRlck1pbnVzID0gJ2JvcmRlci0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJUb3AgPSAndG9wJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyUmlnaHQgPSAncmlnaHQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJCb3R0b20gPSAnYm90dG9tJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTGVmdCA9ICdsZWZ0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTWluTWludXMgPSAnbWluLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1heE1pbnVzID0gJ21heC0nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJXaWR0aCA9ICd3aWR0aCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckhlaWdodCA9ICdoZWlnaHQnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJGbG9hdCA9ICdmbG9hdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckVtcHR5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ckF1dG8gPSAnYXV0byc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clN5bmMgPSAnc3luYyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNjcm9sbCA9ICdzY3JvbGwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJIdW5kcmVkUGVyY2VudCA9ICcxMDAlJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyWCA9ICd4JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyWSA9ICd5JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyRG90ID0gJy4nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTcGFjZSA9ICcgJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsYmFyID0gJ3Njcm9sbGJhcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1pbnVzSG9yaXpvbnRhbCA9ICctaG9yaXpvbnRhbCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1pbnVzVmVydGljYWwgPSAnLXZlcnRpY2FsJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyU2Nyb2xsTGVmdCA9IF9zdHJTY3JvbGwgKyAnTGVmdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clNjcm9sbFRvcCA9IF9zdHJTY3JvbGwgKyAnVG9wJztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyTW91c2VUb3VjaERvd25FdmVudCA9ICdtb3VzZWRvd24gdG91Y2hzdGFydCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0ck1vdXNlVG91Y2hVcEV2ZW50ID0gJ21vdXNldXAgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZVRvdWNoTW92ZUV2ZW50ID0gJ21vdXNlbW92ZSB0b3VjaG1vdmUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZUVudGVyID0gJ21vdXNlZW50ZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJNb3VzZUxlYXZlID0gJ21vdXNlbGVhdmUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJLZXlEb3duRXZlbnQgPSAna2V5ZG93bic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0cktleVVwRXZlbnQgPSAna2V5dXAnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zdHJTZWxlY3RTdGFydEV2ZW50ID0gJ3NlbGVjdHN0YXJ0JztcclxuICAgICAgICAgICAgICAgIHZhciBfc3RyVHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQgd2Via2l0VHJhbnNpdGlvbkVuZCBvVHJhbnNpdGlvbkVuZCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHkgPSAnX19vdmVybGF5U2Nyb2xsYmFyc1JPX18nO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY2xhc3MgbmFtZXM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfY2Fzc05hbWVzUHJlZml4ID0gJ29zLSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhUTUxFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdodG1sJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2hvc3QnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24gPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLWZvcmVpZ24nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0VGV4dGFyZWFFbGVtZW50ID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy10ZXh0YXJlYSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJIb3Jpem9udGFsSGlkZGVuID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy0nICsgX3N0clNjcm9sbGJhciArIF9zdHJNaW51c0hvcml6b250YWwgKyBfc3RyTWludXNIaWRkZW47XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RTY3JvbGxiYXJWZXJ0aWNhbEhpZGRlbiA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctJyArIF9zdHJTY3JvbGxiYXIgKyBfc3RyTWludXNWZXJ0aWNhbCArIF9zdHJNaW51c0hpZGRlbjtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdFRyYW5zaXRpb24gPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXRyYW5zaXRpb24nO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0UlRMID0gX2NsYXNzTmFtZUhvc3RFbGVtZW50ICsgJy1ydGwnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0UmVzaXplRGlzYWJsZWQgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXJlc2l6ZS1kaXNhYmxlZCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RTY3JvbGxpbmcgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLXNjcm9sbGluZyc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyA9IF9jbGFzc05hbWVIb3N0RWxlbWVudCArICctb3ZlcmZsb3cnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3cgPSBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnLW92ZXJmbG93JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WCA9IF9jbGFzc05hbWVIb3N0T3ZlcmZsb3cgKyAnLXgnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dZID0gX2NsYXNzTmFtZUhvc3RPdmVyZmxvdyArICcteSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVRleHRhcmVhRWxlbWVudCA9IF9jYXNzTmFtZXNQcmVmaXggKyAndGV4dGFyZWEnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVUZXh0YXJlYUNvdmVyRWxlbWVudCA9IF9jbGFzc05hbWVUZXh0YXJlYUVsZW1lbnQgKyAnLWNvdmVyJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lUGFkZGluZ0VsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3BhZGRpbmcnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVWaWV3cG9ydEVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3ZpZXdwb3J0JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzSW52aXNpYmxlID0gX2NsYXNzTmFtZVZpZXdwb3J0RWxlbWVudCArICctbmF0aXZlLXNjcm9sbGJhcnMtaW52aXNpYmxlJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQgPSBfY2xhc3NOYW1lVmlld3BvcnRFbGVtZW50ICsgJy1uYXRpdmUtc2Nyb2xsYmFycy1vdmVybGFpZCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZUNvbnRlbnRFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdjb250ZW50JztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lQ29udGVudEFycmFuZ2VFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdjb250ZW50LWFycmFuZ2UnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVDb250ZW50R2x1ZUVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2NvbnRlbnQtZ2x1ZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50ID0gX2Nhc3NOYW1lc1ByZWZpeCArICdzaXplLWF1dG8tb2JzZXJ2ZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3Jlc2l6ZS1vYnNlcnZlcic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3Jlc2l6ZS1vYnNlcnZlci1pdGVtJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRmluYWxFbGVtZW50ID0gX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUVsZW1lbnQgKyAnLWZpbmFsJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVGV4dEluaGVyaXQgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ3RleHQtaW5oZXJpdCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhciA9IF9jYXNzTmFtZXNQcmVmaXggKyBfc3RyU2Nyb2xsYmFyO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJUcmFjayA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyAnLXRyYWNrJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2tPZmYgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2sgKyAnLW9mZic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZSA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyAnLWhhbmRsZSc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZU9mZiA9IF9jbGFzc05hbWVTY3JvbGxiYXJIYW5kbGUgKyAnLW9mZic7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhclVudXNhYmxlID0gX2NsYXNzTmFtZVNjcm9sbGJhciArICctdW51c2FibGUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJBdXRvSGlkZGVuID0gX2NsYXNzTmFtZVNjcm9sbGJhciArICctJyArIF9zdHJBdXRvICsgX3N0ck1pbnVzSGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXIgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyICsgJy1jb3JuZXInO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUgPSBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyICsgJy1yZXNpemUnO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVCID0gX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSArICctYm90aCc7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZUggPSBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplICsgX3N0ck1pbnVzSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplViA9IF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemUgKyBfc3RyTWludXNWZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lU2Nyb2xsYmFySG9yaXpvbnRhbCA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyBfc3RyTWludXNIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVTY3JvbGxiYXJWZXJ0aWNhbCA9IF9jbGFzc05hbWVTY3JvbGxiYXIgKyBfc3RyTWludXNWZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lRHJhZ2dpbmcgPSBfY2Fzc05hbWVzUHJlZml4ICsgJ2RyYWdnaW5nJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lVGhlbWVOb25lID0gX2Nhc3NOYW1lc1ByZWZpeCArICd0aGVtZS1ub25lJztcclxuICAgICAgICAgICAgICAgIHZhciBfY2xhc3NOYW1lc0R5bmFtaWNEZXN0cm95ID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVWaWV3cG9ydE5hdGl2ZVNjcm9sbGJhcnNJbnZpc2libGUsXHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc092ZXJsYWlkLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJUcmFja09mZixcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlT2ZmLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJVbnVzYWJsZSxcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbixcclxuICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVCLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVILFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVWLFxyXG4gICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVEcmFnZ2luZ10uam9pbihfc3RyU3BhY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vY2FsbGJhY2tzOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NhbGxiYWNrc0luaXRRZXVldWUgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2F0dHJzIHZpZXdwb3J0IHNoYWxsIGluaGVyaXQgZnJvbSB0YXJnZXRcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldCA9IFtMRVhJQ09OLnRpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL29wdGlvbnM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfZGVmYXVsdE9wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2N1cnJlbnRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jdXJyZW50UHJlcGFyZWRPcHRpb25zO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vZXh0ZW5zaW9uczpcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9leHRlbnNpb25zID0ge307XHJcbiAgICAgICAgICAgICAgICB2YXIgX2V4dGVuc2lvbnNQcml2YXRlTWV0aG9kcyA9ICdhZGRlZCByZW1vdmVkIG9uIGNvbnRyYWN0JztcclxuXHJcbiAgICAgICAgICAgICAgICAvL3VwZGF0ZVx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX2xhc3RVcGRhdGVUaW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zd2FsbG93ZWRVcGRhdGVIaW50cyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zd2FsbG93ZWRVcGRhdGVUaW1lb3V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zd2FsbG93VXBkYXRlTGFnID0gNDI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSA9ICdsb2FkJztcclxuICAgICAgICAgICAgICAgIHZhciBfdXBkYXRlT25Mb2FkRWxtcyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vRE9NIGVsZW1lbnRzOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3dpbmRvd0VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50RWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfaHRtbEVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2JvZHlFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF90YXJnZXRFbGVtZW50OyAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHRhcmdldCBlbGVtZW50IG9mIHRoaXMgT3ZlcmxheVNjcm9sbGJhcnMgb2JqZWN0XHRcclxuICAgICAgICAgICAgICAgIHZhciBfaG9zdEVsZW1lbnQ7ICAgICAgICAgICAgICAgICAgICAgICAvL3RoZSBob3N0IGVsZW1lbnQgb2YgdGhpcyBPdmVybGF5U2Nyb2xsYmFycyBvYmplY3QgLT4gbWF5IGJlIHRoZSBzYW1lIGFzIHRhcmdldEVsZW1lbnRcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplQXV0b09ic2VydmVyRWxlbWVudDsgICAgICAgICAgIC8vb2JzZXJ2ZXMgc2l6ZSBhdXRvIGNoYW5nZXNcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zaXplT2JzZXJ2ZXJFbGVtZW50OyAgICAgICAgICAgICAgIC8vb2JzZXJ2ZXMgc2l6ZSBhbmQgcGFkZGluZyBjaGFuZ2VzXHRcclxuICAgICAgICAgICAgICAgIHZhciBfcGFkZGluZ0VsZW1lbnQ7ICAgICAgICAgICAgICAgICAgICAvL21hbmFnZXMgdGhlIHBhZGRpbmdcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF92aWV3cG9ydEVsZW1lbnQ7ICAgICAgICAgICAgICAgICAgIC8vaXMgdGhlIHZpZXdwb3J0IG9mIG91ciBzY3JvbGxiYXIgbW9kZWxcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50RWxlbWVudDsgICAgICAgICAgICAgICAgICAgIC8vdGhlIGVsZW1lbnQgd2hpY2ggaG9sZHMgdGhlIGNvbnRlbnRcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50QXJyYW5nZUVsZW1lbnQ7ICAgICAgICAgICAgIC8vaXMgbmVlZGVkIGZvciBjb3JyZWN0IHNpemluZyBvZiB0aGUgY29udGVudCBlbGVtZW50IChvbmx5IGlmIG5hdGl2ZSBzY3JvbGxiYXJzIGFyZSBvdmVybGF5cylcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50R2x1ZUVsZW1lbnQ7ICAgICAgICAgICAgICAgIC8vaGFzIGFsd2F5cyB0aGUgc2l6ZSBvZiB0aGUgY29udGVudCBlbGVtZW50XHRcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFDb3ZlckVsZW1lbnQ7ICAgICAgICAgICAgICAvL29ubHkgYXBwbGllZCBpZiB0YXJnZXQgaXMgYSB0ZXh0YXJlYSBlbGVtZW50LiBVc2VkIGZvciBjb3JyZWN0IHNpemUgY2FsY3VsYXRpb24gYW5kIGZvciBwcmV2ZW50aW9uIG9mIHVuY29udHJvbGxlZCBzY3JvbGxpbmdcdFxyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFySG9yaXpvbnRhbFRyYWNrRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyVmVydGljYWxUcmFja0VsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfd2luZG93RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfZG9jdW1lbnRFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90YXJnZXRFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9ob3N0RWxlbWVudE5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3BhZGRpbmdFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF92aWV3cG9ydEVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRFbGVtZW50TmF0aXZlO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vQ2FjaGU6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfaG9zdFNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY29udGVudFNjcm9sbFNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfYXJyYW5nZUNvbnRlbnRTaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hhc092ZXJmbG93Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hpZGVPdmVyZmxvd0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF93aWR0aEF1dG9DYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfaGVpZ2h0QXV0b0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NCb3hTaXppbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzUGFkZGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NCb3JkZXJDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY3NzTWFyZ2luQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2Nzc0RpcmVjdGlvbkNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jc3NEaXJlY3Rpb25EZXRlY3RlZENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9wYWRkaW5nQWJzb2x1dGVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfY2xpcEFsd2F5c0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jb250ZW50R2x1ZVNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9vdmVyZmxvd0Ftb3VudENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9pZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2F1dG9VcGRhdGVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2l6ZUF1dG9DYXBhYmxlQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2NvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZUNoYW5nZURldGVjdGVkQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2hvc3RFbGVtZW50U2l6ZUNoYW5nZURldGVjdGVkQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNWaXNpYmlsaXR5Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZUNhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmdDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfcmVzaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX25vcm1hbGl6ZVJUTENhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9jbGFzc05hbWVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfb2xkQ2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlO1xyXG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0YXJlYUluZm9DYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFTaXplQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhRHluSGVpZ2h0Q2FjaGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3RleHRhcmVhRHluV2lkdGhDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfYm9keU1pblNpemVDYWNoZTtcclxuICAgICAgICAgICAgICAgIHZhciBfdXBkYXRlQXV0b0NhY2hlID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgLy9NdXRhdGlvbk9ic2VydmVyOlx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJIb3N0O1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVyQ29udGVudDtcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckhvc3RDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnRDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgIHZhciBfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgX211dGF0aW9uT2JzZXJ2ZXJBdHRyc1RleHRhcmVhID0gWyd3cmFwJywgJ2NvbHMnLCAncm93cyddO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9tdXRhdGlvbk9ic2VydmVyQXR0cnNIb3N0ID0gW0xFWElDT04uaSwgTEVYSUNPTi5jLCBMRVhJQ09OLnMsICdvcGVuJ10uY29uY2F0KF92aWV3cG9ydEF0dHJzRnJvbVRhcmdldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9ldmVudHM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfZGVzdHJveUV2ZW50cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdGV4dGFyZWE6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfdGV4dGFyZWFIYXNGb2N1cztcclxuXHJcbiAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnM6XHRcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlVGltZW91dElkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlVGltZW91dElkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzQXV0b0hpZGVEZWxheTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlTmV2ZXI7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZTtcclxuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Njcm9sbGJhcnNIYW5kbGVIb3ZlcmVkO1xyXG4gICAgICAgICAgICAgICAgdmFyIF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcztcclxuXHJcbiAgICAgICAgICAgICAgICAvL3Jlc2l6ZVx0XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZU5vbmU7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZUJvdGg7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZUhvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Jlc2l6ZVZlcnRpY2FsO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gRXZlbnQgTGlzdGVuZXIgPT09PS8vXHRcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcdFxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBvciByZW1vdmVzIGEgZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC4gXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbGVtZW50IFRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBldmVudCBsaXN0ZW5lciBzaGFsbCBiZSBhcHBsaWVkIG9yIHJlbW92ZWQuXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudE5hbWVzIFRoZSBuYW1lKHMpIG9mIHRoZSBldmVudHMuXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lciBUaGUgbWV0aG9kIHdoaWNoIHNoYWxsIGJlIGNhbGxlZC5cdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHJlbW92ZSBUcnVlIGlmIHRoZSBoYW5kbGVyIHNoYWxsIGJlIHJlbW92ZWQsIGZhbHNlIG9yIHVuZGVmaW5lZCBpZiB0aGUgaGFuZGxlciBzaGFsbCBiZSBhZGRlZC5cdFxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHBhc3NpdmVPck9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBldmVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihlbGVtZW50LCBldmVudE5hbWVzLCBsaXN0ZW5lciwgcmVtb3ZlLCBwYXNzaXZlT3JPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3RlZCA9IENPTVBBVElCSUxJVFkuaXNBKGV2ZW50TmFtZXMpICYmIENPTVBBVElCSUxJVFkuaXNBKGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gcmVtb3ZlID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2FkZEV2ZW50TGlzdGVuZXInO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbk9mZiA9IHJlbW92ZSA/ICdvZmYnIDogJ29uJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gY29sbGVjdGVkID8gZmFsc2UgOiBldmVudE5hbWVzLnNwbGl0KF9zdHJTcGFjZSlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXNzaXZlT3JPcHRpb25zSXNPYmogPSBGUkFNRVdPUksuaXNQbGFpbk9iamVjdChwYXNzaXZlT3JPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFzc2l2ZSA9IChfc3VwcG9ydFBhc3NpdmVFdmVudHMgJiYgKHBhc3NpdmVPck9wdGlvbnNJc09iaiA/IChwYXNzaXZlT3JPcHRpb25zLl9wYXNzaXZlKSA6IHBhc3NpdmVPck9wdGlvbnMpKSB8fCBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IHBhc3NpdmVPck9wdGlvbnNJc09iaiAmJiAocGFzc2l2ZU9yT3B0aW9ucy5fY2FwdHVyZSB8fCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVBhcmFtID0gX3N1cHBvcnRQYXNzaXZlRXZlbnRzID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzaXZlOiBwYXNzaXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXB0dXJlOiBjYXB0dXJlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0gOiBjYXB0dXJlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgZXZlbnROYW1lc1tMRVhJQ09OLmxdOyBpKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZXNbaV0sIGxpc3RlbmVyW2ldLCByZW1vdmUsIHBhc3NpdmVPck9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBldmVudHNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihfc3VwcG9ydFBhc3NpdmVFdmVudHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50WzBdW21ldGhvZF0oZXZlbnRzW2ldLCBsaXN0ZW5lciwgbmF0aXZlUGFyYW0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFtvbk9mZl0oZXZlbnRzW2ldLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZXZlbnROYW1lcywgbGlzdGVuZXIsIHBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGxpc3RlbmVyLCBmYWxzZSwgcGFzc2l2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3lFdmVudHMucHVzaChDT01QQVRJQklMSVRZLmJpbmQoc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lciwgMCwgZWxlbWVudCwgZXZlbnROYW1lcywgbGlzdGVuZXIsIHRydWUsIHBhc3NpdmUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gUmVzaXplIE9ic2VydmVyID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBvciByZW1vdmVzIGEgcmVzaXplIG9ic2VydmVyIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgcmVzaXplIG9ic2VydmVyIHNoYWxsIGJlIGFkZGVkIG9yIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gb25FbGVtZW50UmVzaXplZENhbGxiYWNrIFRoZSBjYWxsYmFjayB3aGljaCBpcyBmaXJlZCBldmVyeSB0aW1lIHRoZSByZXNpemUgb2JzZXJ2ZXIgcmVnaXN0ZXJzIGEgc2l6ZSBjaGFuZ2Ugb3IgZmFsc2UgLyB1bmRlZmluZWQgaWYgdGhlIHJlc2l6ZU9ic2VydmVyIHNoYWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwUmVzaXplT2JzZXJ2ZXIodGFyZ2V0RWxlbWVudCwgb25FbGVtZW50UmVzaXplZENhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZU9ic2VydmVyID0gQ09NUEFUSUJJTElUWS5yTygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQW5pbWF0aW9uU3RhcnRFdmVudCA9ICdhbmltYXRpb25zdGFydCBtb3pBbmltYXRpb25TdGFydCB3ZWJraXRBbmltYXRpb25TdGFydCBNU0FuaW1hdGlvblN0YXJ0JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckNoaWxkTm9kZXMgPSAnY2hpbGROb2Rlcyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25zdFNjcm9sbCA9IDMzMzMzMzM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oY29uc3RTY3JvbGwpW19zdHJTY3JvbGxMZWZ0XShfaXNSVEwgPyBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IC1jb25zdFNjcm9sbCA6IF9ydGxTY3JvbGxCZWhhdmlvci5pID8gMCA6IGNvbnN0U2Nyb2xsIDogY29uc3RTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FbGVtZW50UmVzaXplZENhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHJlc2l6ZSBvYnNlcnZlcjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRWxlbWVudFJlc2l6ZWRDYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0UmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRhcmdldEVsZW1lbnQuYWRkQ2xhc3MoJ29ic2VydmVkJykuYXBwZW5kKGdlbmVyYXRlRGl2KF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpKS5jb250ZW50cygpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYnNlcnZlciA9IGVsZW1lbnRbX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHldID0gbmV3IHJlc2l6ZU9ic2VydmVyKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9tc2llVmVyc2lvbiA+IDkgfHwgIV9hdXRvVXBkYXRlUmVjb21tZW5kZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5wcmVwZW5kKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZURpdih7IGM6IF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1FbGVtZW50LCBkaXI6ICdsdHInIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGl2KF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVySXRlbUZpbmFsRWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRGl2KF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckl0ZW1FbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVEaXYoeyBjOiBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJJdGVtRmluYWxFbGVtZW50LCBzdHlsZTogJ3dpZHRoOiAyMDAlOyBoZWlnaHQ6IDIwMCUnIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JzZXJ2ZXJFbGVtZW50ID0gdGFyZ2V0RWxlbWVudFswXVtzdHJDaGlsZE5vZGVzXVswXVtzdHJDaGlsZE5vZGVzXVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNocmlua0VsZW1lbnQgPSBGUkFNRVdPUksob2JzZXJ2ZXJFbGVtZW50W3N0ckNoaWxkTm9kZXNdWzFdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZEVsZW1lbnQgPSBGUkFNRVdPUksob2JzZXJ2ZXJFbGVtZW50W3N0ckNoaWxkTm9kZXNdWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGFuZEVsZW1lbnRDaGlsZCA9IEZSQU1FV09SSyhleHBhbmRFbGVtZW50WzBdW3N0ckNoaWxkTm9kZXNdWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQ2FjaGUgPSBvYnNlcnZlckVsZW1lbnRbTEVYSUNPTi5vV107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHRDYWNoZSA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9IXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRGlydHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByQUZJZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlU2Nyb2xsYmFyU2l6ZSA9IGdsb2JhbHMubmF0aXZlU2Nyb2xsYmFyU2l6ZTsgLy9jYXJlIGRvbid0IG1ha2UgY2hhbmdlcyB0byB0aGlzIG9iamVjdCEhIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplUmVzZXRXaWR0aCA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9XXSArIG5hdGl2ZVNjcm9sbGJhclNpemUueCAqIGZhY3RvciArIG5hdGl2ZVNjcm9sbGJhclNpemUueSAqIGZhY3RvciArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnggKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplUmVzZXRIZWlnaHQgPSBvYnNlcnZlckVsZW1lbnRbTEVYSUNPTi5vSF0gKyBuYXRpdmVTY3JvbGxiYXJTaXplLnggKiBmYWN0b3IgKyBuYXRpdmVTY3JvbGxiYXJTaXplLnkgKiBmYWN0b3IgKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS54ICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kQ2hpbGRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRDaGlsZENTU1tfc3RyV2lkdGhdID0gc2l6ZVJlc2V0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGRDU1NbX3N0ckhlaWdodF0gPSBzaXplUmVzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kRWxlbWVudENoaWxkLmNzcyhleHBhbmRDaGlsZENTUyk7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShzaXplUmVzZXRXaWR0aClbX3N0clNjcm9sbFRvcF0oc2l6ZVJlc2V0SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaHJpbmtFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShzaXplUmVzZXRXaWR0aClbX3N0clNjcm9sbFRvcF0oc2l6ZVJlc2V0SGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kRWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oY29uc3RTY3JvbGwpW19zdHJTY3JvbGxUb3BdKGNvbnN0U2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNocmlua0VsZW1lbnRbX3N0clNjcm9sbExlZnRdKGNvbnN0U2Nyb2xsKVtfc3RyU2Nyb2xsVG9wXShjb25zdFNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvblJlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByQUZJZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRGlydHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoQ2FjaGUgPSBjdXJyV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHRDYWNoZSA9IGN1cnJIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25TY3JvbGwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJXaWR0aCA9IG9ic2VydmVyRWxlbWVudFtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJIZWlnaHQgPSBvYnNlcnZlckVsZW1lbnRbTEVYSUNPTi5vSF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RpcnR5ID0gY3VycldpZHRoICE9IHdpZHRoQ2FjaGUgfHwgY3VyckhlaWdodCAhPSBoZWlnaHRDYWNoZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgaXNEaXJ0eSAmJiAhckFGSWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLmNBRigpKHJBRklkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByQUZJZCA9IENPTVBBVElCSUxJVFkuckFGKCkob25SZXNpemVkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFldmVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblJlc2l6ZWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5wcnZEKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhwYW5kQ2hpbGRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9ic2VydmVyRWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KG9ic2VydmVyRWxlbWVudENTUywgX3N0ckVtcHR5LCBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtKChuYXRpdmVTY3JvbGxiYXJTaXplLnkgKyAxKSAqIGZhY3RvciksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVTY3JvbGxiYXJTaXplLnggKiAtZmFjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF0aXZlU2Nyb2xsYmFyU2l6ZS55ICogLWZhY3RvcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0oKG5hdGl2ZVNjcm9sbGJhclNpemUueCArIDEpICogZmFjdG9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSyhvYnNlcnZlckVsZW1lbnQpLmNzcyhvYnNlcnZlckVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRFbGVtZW50Lm9uKF9zdHJTY3JvbGwsIG9uU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rRWxlbWVudC5vbihfc3RyU2Nyb2xsLCBvblNjcm9sbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQub24oc3RyQW5pbWF0aW9uU3RhcnRFdmVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGwoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXRzIGFzc3VtZSB0aGF0IHRoZSBkaXZzIHdpbGwgbmV2ZXIgYmUgdGhhdCBsYXJnZSBhbmQgYSBjb25zdGFudCB2YWx1ZSBpcyBlbm91Z2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kQ2hpbGRDU1NbX3N0cldpZHRoXSA9IGNvbnN0U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRDaGlsZENTU1tfc3RySGVpZ2h0XSA9IGNvbnN0U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRFbGVtZW50Q2hpbGQuY3NzKGV4cGFuZENoaWxkQ1NTKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNoRXZlbnQgPSBfZG9jdW1lbnRFbGVtZW50TmF0aXZlLmF0dGFjaEV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXNJRSA9IF9tc2llVmVyc2lvbiAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0YWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQucHJlcGVuZChnZW5lcmF0ZURpdihfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3QodGFyZ2V0RWxlbWVudCwgX3N0ckRvdCArIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpWzBdLmF0dGFjaEV2ZW50KCdvbnJlc2l6ZScsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBfZG9jdW1lbnRFbGVtZW50TmF0aXZlLmNyZWF0ZUVsZW1lbnQoVFlQRVMubyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouc2V0QXR0cmlidXRlKExFWElDT04udGksICctMScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNldEF0dHJpYnV0ZShMRVhJQ09OLmMsIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd25kID0gdGhpcy5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd25kLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3bmQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnR5cGUgPSAndGV4dC9odG1sJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0lFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQucHJlcGVuZChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmRhdGEgPSAnYWJvdXQ6YmxhbmsnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0lFKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQucHJlcGVuZChvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5vbihzdHJBbmltYXRpb25TdGFydEV2ZW50LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnRbMF0gPT09IF9zaXplT2JzZXJ2ZXJFbGVtZW50TmF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbkNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXIgPSBfaG9zdEVsZW1lbnQuY3NzKCdkaXJlY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdFZhbHVlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyICE9PSBfY3NzRGlyZWN0aW9uRGV0ZWN0ZWRDYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpciA9PT0gJ2x0cicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckxlZnRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0clJpZ2h0XSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbExlZnRWYWx1ZSA9IGNvbnN0U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJMZWZ0XSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyUmlnaHRdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxMZWZ0VmFsdWUgPSBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IC1jb25zdFNjcm9sbCA6IF9ydGxTY3JvbGxCZWhhdmlvci5pID8gMCA6IGNvbnN0U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9leGVjdXRpb24gb3JkZXIgaXMgaW1wb3J0YW50IGZvciBJRSEhIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnQuY2hpbGRyZW4oKS5lcSgwKS5jc3MoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplT2JzZXJ2ZXJFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShzY3JvbGxMZWZ0VmFsdWUpW19zdHJTY3JvbGxUb3BdKGNvbnN0U2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jc3NEaXJlY3Rpb25EZXRlY3RlZENhY2hlID0gZGlyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uQ2hhbmdlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsIF9zdHJTY3JvbGwsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQ2hhbmdlZCgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSByZXNpemUgb2JzZXJ2ZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0UmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRhcmdldEVsZW1lbnQuY29udGVudHMoKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaXplT2JzZXJ2ZXJPYmogPSBlbGVtZW50W19zdHJSZXNpemVPYnNlcnZlclByb3BlcnR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzaXplT2JzZXJ2ZXJPYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXJPYmouZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudFtfc3RyUmVzaXplT2JzZXJ2ZXJQcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHRhcmdldEVsZW1lbnQuY2hpbGRyZW4oX3N0ckRvdCArIF9jbGFzc05hbWVSZXNpemVPYnNlcnZlckVsZW1lbnQpLmVxKDApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEZyZWV6ZXMgb3IgdW5mcmVlemVzIHRoZSBnaXZlbiByZXNpemUgb2JzZXJ2ZXIuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0RWxlbWVudCBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgdGFyZ2V0IHJlc2l6ZSBvYnNlcnZlciBpcyBhcHBsaWVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGZyZWV6ZSBUcnVlIGlmIHRoZSByZXNpemUgb2JzZXJ2ZXIgc2hhbGwgYmUgZnJvemVuLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmcmVlemVSZXNpemVPYnNlcnZlcih0YXJnZXRFbGVtZW50LCBmcmVlemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZyZWV6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0UmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHRhcmdldEVsZW1lbnQuY29udGVudHMoKVswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50W19zdHJSZXNpemVPYnNlcnZlclByb3BlcnR5XS51bm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5jaGlsZHJlbihfc3RyRG90ICsgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkuZXEoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHcgPSB0YXJnZXRFbGVtZW50LmNzcyhfc3RyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0gdGFyZ2V0RWxlbWVudC5jc3MoX3N0ckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckhlaWdodF0gPSBoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuY3NzKGNzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRSZXNpemVPYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdGFyZ2V0RWxlbWVudC5jb250ZW50cygpWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRbX3N0clJlc2l6ZU9ic2VydmVyUHJvcGVydHldLm9ic2VydmUoZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3NzID0geyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RySGVpZ2h0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmNoaWxkcmVuKF9zdHJEb3QgKyBfY2xhc3NOYW1lUmVzaXplT2JzZXJ2ZXJFbGVtZW50KS5lcSgwKS5jc3MoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICovXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBNdXRhdGlvbiBPYnNlcnZlcnMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDcmVhdGVzIE11dGF0aW9uT2JzZXJ2ZXJzIGZvciB0aGUgaG9zdCBhbmQgY29udGVudCBFbGVtZW50IGlmIHRoZXkgYXJlIHN1cHBvcnRlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY3JlYXRlTXV0YXRpb25PYnNlcnZlcnMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0TXV0YXRpb25PYnNlcnZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWcgPSAxMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uT2JzZXJ2ZXIgPSBDT01QQVRJQklMSVRZLm1PKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50TGFzdFVwZGF0ZSA9IENPTVBBVElCSUxJVFkubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvblRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG11dGF0aW9uQXR0ck5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbklzQ2xhc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRNdXRhdGlvblZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld0NsYXNzVmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdENsYXNzTmFtZVJlZ2V4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFRpbWVvdXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaXplQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVySG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKG11dGF0aW9ucykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvVXBkYXRlRm9yY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkQXR0cnMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2luaXRpYWxpemVkICYmICFfc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKG11dGF0aW9ucywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uVGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbkF0dHJOYW1lID0gbXV0YXRpb24uYXR0cmlidXRlTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25Jc0NsYXNzID0gbXV0YXRpb25BdHRyTmFtZSA9PT0gTEVYSUNPTi5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRNdXRhdGlvblZhbCA9IG11dGF0aW9uLm9sZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDbGFzc1ZhbCA9IG11dGF0aW9uVGFyZ2V0LmNsYXNzTmFtZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzICYmIG11dGF0aW9uSXNDbGFzcyAmJiAhZG9VcGRhdGVGb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgb2xkIGNsYXNzIHZhbHVlIGNvbnRhaW5zIF9jbGFzc05hbWVIb3N0RWxlbWVudEZvcmVpZ24gYW5kIG5ldyBjbGFzcyB2YWx1ZSBkb2Vzbid0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2xkTXV0YXRpb25WYWwuaW5kZXhPZihfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduKSA+IC0xICYmIG5ld0NsYXNzVmFsLmluZGV4T2YoX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbikgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdENsYXNzTmFtZVJlZ2V4ID0gY3JlYXRlSG9zdENsYXNzTmFtZVJlZ0V4cCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnROYXRpdmUuY2xhc3NOYW1lID0gbmV3Q2xhc3NWYWwuc3BsaXQoX3N0clNwYWNlKS5jb25jYXQob2xkTXV0YXRpb25WYWwuc3BsaXQoX3N0clNwYWNlKS5maWx0ZXIoZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWUubWF0Y2goaG9zdENsYXNzTmFtZVJlZ2V4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuam9pbihfc3RyU3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVXBkYXRlID0gZG9VcGRhdGVGb3JjZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVXBkYXRlID0gbXV0YXRpb25Jc0NsYXNzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBob3N0Q2xhc3NOYW1lc0NoYW5nZWQob2xkTXV0YXRpb25WYWwsIG5ld0NsYXNzVmFsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbXV0YXRpb25BdHRyTmFtZSA9PT0gTEVYSUNPTi5zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gb2xkTXV0YXRpb25WYWwgIT09IG11dGF0aW9uVGFyZ2V0W0xFWElDT04uc10uY3NzVGV4dFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0ZWRBdHRycy5wdXNoKG11dGF0aW9uQXR0ck5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWaWV3cG9ydEF0dHJzRnJvbVRhcmdldChtdXRhdGVkQXR0cnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9VcGRhdGUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShkb1VwZGF0ZUZvcmNlIHx8IF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkb1VwZGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50Q2FsbGJhY2sgPSBmdW5jdGlvbiAobXV0YXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9VcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2luaXRpYWxpemVkICYmICFfc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKG11dGF0aW9ucywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGlvbiA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVXBkYXRlID0gaXNVbmtub3duTXV0YXRpb24obXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm93ID0gQ09NUEFUSUJJTElUWS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUF1dG8gPSAoX2hlaWdodEF1dG9DYWNoZSB8fCBfd2lkdGhBdXRvQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50TGFzdFVwZGF0ZSA9IG5vdztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBjb2xzLCByb3dzIG9yIHdyYXAgYXR0ciB3YXMgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFVcGRhdGUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVBdXRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjb250ZW50VGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyQ29udGVudExhZyA8PSAwIHx8IG5vdyAtIGNvbnRlbnRMYXN0VXBkYXRlID4gbXV0YXRpb25PYnNlcnZlckNvbnRlbnRMYWcgfHwgIXNpemVBdXRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUaW1lb3V0ID0gc2V0VGltZW91dChhY3Rpb24sIG11dGF0aW9uT2JzZXJ2ZXJDb250ZW50TGFnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVySG9zdCA9IG5ldyBtdXRhdGlvbk9ic2VydmVyKF9tdXRhdGlvbk9ic2VydmVySG9zdENhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50ID0gbmV3IG11dGF0aW9uT2JzZXJ2ZXIoX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50Q2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENvbm5lY3RzIHRoZSBNdXRhdGlvbk9ic2VydmVycyBpZiB0aGV5IGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRNdXRhdGlvbk9ic2VydmVyICYmICFfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJIb3N0Lm9ic2VydmUoX2hvc3RFbGVtZW50TmF0aXZlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IF9tdXRhdGlvbk9ic2VydmVyQXR0cnNIb3N0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50Lm9ic2VydmUoX2lzVGV4dGFyZWEgPyBfdGFyZ2V0RWxlbWVudE5hdGl2ZSA6IF9jb250ZW50RWxlbWVudE5hdGl2ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU9sZFZhbHVlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VidHJlZTogIV9pc1RleHRhcmVhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRMaXN0OiAhX2lzVGV4dGFyZWEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiAhX2lzVGV4dGFyZWEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVGaWx0ZXI6IF9pc1RleHRhcmVhID8gX211dGF0aW9uT2JzZXJ2ZXJBdHRyc1RleHRhcmVhIDogX211dGF0aW9uT2JzZXJ2ZXJBdHRyc0hvc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlcnNDb25uZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIERpc2Nvbm5lY3RzIHRoZSBNdXRhdGlvbk9ic2VydmVycyBpZiB0aGV5IGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRNdXRhdGlvbk9ic2VydmVyICYmIF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckhvc3QuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbXV0YXRpb25PYnNlcnZlckNvbnRlbnQuZGlzY29ubmVjdCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gRXZlbnRzIG9mIGVsZW1lbnRzID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgZXZlcnkgdGltZSB0aGUgaG9zdCBlbGVtZW50IGdldHMgcmVzaXplZC4gSU1QT1JUQU5UOiBQYWRkaW5nIGNoYW5nZXMgYXJlIGRldGVjdGVkIHRvbyEhXHJcbiAgICAgICAgICAgICAgICAgKiBJdCByZWZyZXNoZXMgdGhlIGhvc3RSZXNpemVkRXZlbnRBcmdzIGFuZCB0aGUgaG9zdFNpemVSZXNpemVDYWNoZS5cclxuICAgICAgICAgICAgICAgICAqIElmIHRoZXJlIGFyZSBhbnkgc2l6ZSBjaGFuZ2VzLCB0aGUgdXBkYXRlIG1ldGhvZCBnZXRzIGNhbGxlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaG9zdE9uUmVzaXplZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogX3NpemVPYnNlcnZlckVsZW1lbnROYXRpdmVbTEVYSUNPTi5zV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBfc2l6ZU9ic2VydmVyRWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNIXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IGNoZWNrQ2FjaGUoaG9zdFNpemUsIF9ob3N0RWxlbWVudFNpemVDaGFuZ2VEZXRlY3RlZENhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50U2l6ZUNoYW5nZURldGVjdGVkQ2FjaGUgPSBob3N0U2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoeyBfaG9zdFNpemVDaGFuZ2VkOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBtb3VzZSBlbnRlciBldmVudCBvZiB0aGUgaG9zdCBlbGVtZW50LiBUaGlzIGV2ZW50IGlzIG9ubHkgbmVlZGVkIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaG9zdE9uTW91c2VFbnRlcigpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIG1vdXNlIGxlYXZlIGV2ZW50IG9mIHRoZSBob3N0IGVsZW1lbnQuIFRoaXMgZXZlbnQgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBhdXRvSGlkZSBmZWF0dXJlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0T25Nb3VzZUxlYXZlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUgJiYgIV9ib2R5RWxlbWVudC5oYXNDbGFzcyhfY2xhc3NOYW1lRHJhZ2dpbmcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBtb3VzZSBtb3ZlIGV2ZW50IG9mIHRoZSBob3N0IGVsZW1lbnQuIFRoaXMgZXZlbnQgaXMgb25seSBuZWVkZWQgZm9yIHRoZSBhdXRvSGlkZSBcIm1vdmVcIiBmZWF0dXJlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBob3N0T25Nb3VzZU1vdmUoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUgJiYgIV9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUHJldmVudHMgdGV4dCBmcm9tIGRlc2VsZWN0aW9uIGlmIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCBlbGVtZW50IG9uIHRoZSBtb3VzZWRvd24gZXZlbnQgb2YgYSBET00gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUgc2VsZWN0IHN0YXJ0IGV2ZW50LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkb2N1bWVudE9uU2VsZWN0U3RhcnQoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcdFxyXG4gICAgICAgICAgICAgICAgICogQSBjYWxsYmFjayB3aGljaCB3aWxsIGJlIGNhbGxlZCBhZnRlciBhIGVsZW1lbnQgaGFzIGxvYWRlZC5cdFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVPbkxvYWRDYWxsYmFjayhldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbG0gPSBGUkFNRVdPUksoZXZlbnQudGFyZ2V0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWFjaFVwZGF0ZU9uTG9hZChmdW5jdGlvbiAoaSwgdXBkYXRlT25Mb2FkU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVsbS5pcyh1cGRhdGVPbkxvYWRTZWxlY3RvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7IF9jb250ZW50U2l6ZUNoYW5nZWQ6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICogQWRkcyBvciByZW1vdmVzIG1vdXNlICYgdG91Y2ggZXZlbnRzIG9mIHRoZSBob3N0IGVsZW1lbnQuIChmb3IgaGFuZGxpbmcgYXV0by1oaWRpbmcgb2YgdGhlIHNjcm9sbGJhcnMpXHJcbiAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBldmVudHMgc2hhbGwgYmUgYWRkZWQgb3IgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cEhvc3RNb3VzZVRvdWNoRXZlbnRzKGRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlc3Ryb3kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwSG9zdE1vdXNlVG91Y2hFdmVudHModHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2hvc3RFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTW91c2VUb3VjaE1vdmVFdmVudC5zcGxpdChfc3RyU3BhY2UpWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0T25Nb3VzZU1vdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICghX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUgfHwgZGVzdHJveSksIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2hvc3RFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbX3N0ck1vdXNlRW50ZXIsIF9zdHJNb3VzZUxlYXZlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW2hvc3RPbk1vdXNlRW50ZXIsIGhvc3RPbk1vdXNlTGVhdmVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoIV9zY3JvbGxiYXJzQXV0b0hpZGVMZWF2ZSB8fCBkZXN0cm95KSwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlIHBsdWdpbiBpcyBpbml0aWFsaXplZCBhbmQgdGhlIG1vdXNlIGlzIG92ZXIgdGhlIGhvc3QgZWxlbWVudCwgbWFrZSB0aGUgc2Nyb2xsYmFycyB2aXNpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfaW5pdGlhbGl6ZWQgJiYgIWRlc3Ryb3kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC5vbmUoJ21vdXNlb3ZlcicsIGhvc3RPbk1vdXNlRW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gVXBkYXRlIERldGVjdGlvbiA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIE1lYXN1cmVzIHRoZSBtaW4gd2lkdGggYW5kIG1pbiBoZWlnaHQgb2YgdGhlIGJvZHkgZWxlbWVudCBhbmQgcmVmcmVzaGVzIHRoZSByZWxhdGVkIGNhY2hlLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIG1pbiB3aWR0aCBvciBtaW4gaGVpZ2h0IGhhcyBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGJvZHlNaW5TaXplQ2hhbmdlZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keU1pblNpemUgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSAmJiBfY29udGVudEFycmFuZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplLncgPSBwYXJzZVRvWmVyb09yTnVtYmVyKF9jb250ZW50QXJyYW5nZUVsZW1lbnQuY3NzKF9zdHJNaW5NaW51cyArIF9zdHJXaWR0aCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5TWluU2l6ZS5oID0gcGFyc2VUb1plcm9Pck51bWJlcihfY29udGVudEFycmFuZ2VFbGVtZW50LmNzcyhfc3RyTWluTWludXMgKyBfc3RySGVpZ2h0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplLmMgPSBjaGVja0NhY2hlKGJvZHlNaW5TaXplLCBfYm9keU1pblNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlNaW5TaXplLmYgPSB0cnVlOyAvL2ZsYWcgZm9yIFwibWVhc3VyZWQgYXQgbGVhc3Qgb25jZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIF9ib2R5TWluU2l6ZUNhY2hlID0gYm9keU1pblNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhYm9keU1pblNpemUuYztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2xhc3MgbmFtZXMgcmVhbGx5IGNoYW5nZWQgKG5ldyBjbGFzcyB3aXRob3V0IHBsdWdpbiBob3N0IHByZWZpeClcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvbGRDbGFzc05hbWVzIFRoZSBvbGQgQ2xhc3NOYW1lIHN0cmluZyBvciBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuZXdDbGFzc05hbWVzIFRoZSBuZXcgQ2xhc3NOYW1lIHN0cmluZyBvciBhcnJheS5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBjbGFzcyBuYW1lcyBoYXMgcmVhbGx5IGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaG9zdENsYXNzTmFtZXNDaGFuZ2VkKG9sZENsYXNzTmFtZXMsIG5ld0NsYXNzTmFtZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyckNsYXNzZXMgPSB0eXBlb2YgbmV3Q2xhc3NOYW1lcyA9PSBUWVBFUy5zID8gbmV3Q2xhc3NOYW1lcy5zcGxpdChfc3RyU3BhY2UpIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9sZENsYXNzZXMgPSB0eXBlb2Ygb2xkQ2xhc3NOYW1lcyA9PSBUWVBFUy5zID8gb2xkQ2xhc3NOYW1lcy5zcGxpdChfc3RyU3BhY2UpIDogW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBnZXRBcnJheURpZmZlcmVuY2VzKG9sZENsYXNzZXMsIGN1cnJDbGFzc2VzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vbmUgdGhlbWUgZnJvbSBkaWZmIGxpc3QgdG8gcHJldmVudCB1cGRhdGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gaW5BcnJheShfY2xhc3NOYW1lVGhlbWVOb25lLCBkaWZmKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZi5zcGxpY2UoaWR4LCAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmZbTEVYSUNPTi5sXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVnZXggPSBjcmVhdGVIb3N0Q2xhc3NOYW1lUmVnRXhwKHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaWZmW2ldLm1hdGNoKHJlZ2V4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbXV0YXRpb24gaXMgbm90IGZyb20gYSBmcm9tIHRoZSBwbHVnaW4gZ2VuZXJhdGVkIGVsZW1lbnQuIElmIHRoZSB0YXJnZXQgZWxlbWVudCBpcyBhIHRleHRhcmVhIHRoZSBtdXRhdGlvbiBpcyBhbHdheXMgdW5rbm93bi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBtdXRhdGlvbiBUaGUgbXV0YXRpb24gd2hpY2ggc2hhbGwgYmUgY2hlY2tlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBtdXRhdGlvbiBpcyBmcm9tIGEgdW5rbm93biBlbGVtZW50LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzVW5rbm93bk11dGF0aW9uKG11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvblRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXV0YXRpb25UeXBlID0gbXV0YXRpb24udHlwZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQ2xvc2VzdCA9ICdjbG9zZXN0JztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uVGFyZ2V0ID09PSBfY29udGVudEVsZW1lbnROYXRpdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lID09PSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvblR5cGUgPT09ICdhdHRyaWJ1dGVzJyAmJiAoYXR0cmlidXRlTmFtZSA9PT0gTEVYSUNPTi5jIHx8IGF0dHJpYnV0ZU5hbWUgPT09IExFWElDT04ucykgJiYgIV9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWdub3JlIGNsYXNzTmFtZSBjaGFuZ2VzIGJ5IHRoZSBwbHVnaW5cdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gTEVYSUNPTi5jICYmIEZSQU1FV09SSyhtdXRhdGlvblRhcmdldCkuaGFzQ2xhc3MoX2NsYXNzTmFtZUhvc3RFbGVtZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBob3N0Q2xhc3NOYW1lc0NoYW5nZWQobXV0YXRpb24ub2xkVmFsdWUsIG11dGF0aW9uVGFyZ2V0LmNsYXNzTmFtZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL29ubHkgZG8gaXQgb2YgYnJvd3NlciBzdXBwb3J0IGl0IG5hdGl2ZWx5XHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtdXRhdGlvblRhcmdldFtzdHJDbG9zZXN0XSAhPSBUWVBFUy5mKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvblRhcmdldFtzdHJDbG9zZXN0XShfc3RyRG90ICsgX2NsYXNzTmFtZVJlc2l6ZU9ic2VydmVyRWxlbWVudCkgIT09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0aW9uVGFyZ2V0W3N0ckNsb3Nlc3RdKF9zdHJEb3QgKyBfY2xhc3NOYW1lU2Nyb2xsYmFyKSAhPT0gbnVsbCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25UYXJnZXRbc3RyQ2xvc2VzdF0oX3N0ckRvdCArIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXIpICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udGVudCBzaXplIHdhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBjb250ZW50IHNpemUgd2FzIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQXV0b0NvbnRlbnRTaXplQ2hhbmdlZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3NsZWVwaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50TWVhc3VyZUVsZW1lbnQgPSBnZXRDb250ZW50TWVhc3VyZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFWYWx1ZUxlbmd0aCA9IF9pc1RleHRhcmVhICYmIF93aWR0aEF1dG9DYWNoZSAmJiAhX3RleHRhcmVhQXV0b1dyYXBwaW5nQ2FjaGUgPyBfdGFyZ2V0RWxlbWVudC52YWwoKS5sZW5ndGggOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXRDU1MgPSAhX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkICYmIF93aWR0aEF1dG9DYWNoZSAmJiAhX2lzVGV4dGFyZWE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbG9hdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keU1pblNpemVDO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50RWxlbWVudFNjcm9sbFNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXRDU1MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvYXQgPSBfY29udGVudEVsZW1lbnQuY3NzKF9zdHJGbG9hdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyRmxvYXRdID0gX2lzUlRMID8gX3N0clJpZ2h0IDogX3N0ckxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3N0ckF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY3NzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRTY3JvbGxTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3OiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5zV10gKyB0ZXh0YXJlYVZhbHVlTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoOiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5zSF0gKyB0ZXh0YXJlYVZhbHVlTGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0Q1NTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyRmxvYXRdID0gZmxvYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyV2lkdGhdID0gX3N0ckh1bmRyZWRQZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKGNzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBib2R5TWluU2l6ZUMgPSBib2R5TWluU2l6ZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gY2hlY2tDYWNoZShjb250ZW50RWxlbWVudFNjcm9sbFNpemUsIF9jb250ZW50RWxlbWVudFNjcm9sbFNpemVDaGFuZ2VEZXRlY3RlZENhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50U2Nyb2xsU2l6ZUNoYW5nZURldGVjdGVkQ2FjaGUgPSBjb250ZW50RWxlbWVudFNjcm9sbFNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkIHx8IGJvZHlNaW5TaXplQztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgdHJ1ZSB3aGVuIGEgYXR0cmlidXRlIHdoaWNoIHRoZSBNdXRhdGlvbk9ic2VydmVyIHdvdWxkIG9ic2VydmUgaGFzIGNoYW5nZWQuICBcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9uZSBvZiB0aGUgYXR0cmlidXRlcyB3aGljaCBhIE11dGF0aW9uT2JzZXJ2ZXIgd291bGQgb2JzZXJ2ZSBoYXMgY2hhbmdlZCwgZmFsc2Ugb3IgdW5kZWZpbmVkIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gbWVhbmluZ2Z1bEF0dHJzQ2hhbmdlZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3NsZWVwaW5nIHx8IF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRBdHRycyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja3MgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lbGVtOiBfaG9zdEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYXR0cnM6IF9tdXRhdGlvbk9ic2VydmVyQXR0cnNIb3N0LmNvbmNhdCgnOnZpc2libGUnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZWxlbTogX2lzVGV4dGFyZWEgPyBfdGFyZ2V0RWxlbWVudCA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hdHRyczogX211dGF0aW9uT2JzZXJ2ZXJBdHRyc1RleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlYWNoKGNoZWNrcywgZnVuY3Rpb24gKGluZGV4LCBjaGVjaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtID0gY2hlY2suX2VsZW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGNoZWNrLl9hdHRycywgZnVuY3Rpb24gKGluZGV4LCBhdHRyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGF0dHIuY2hhckF0KDApID09PSAnOicgPyBlbGVtLmlzKGF0dHIpIDogZWxlbS5hdHRyKGF0dHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlID0gX3VwZGF0ZUF1dG9DYWNoZVthdHRyXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrQ2FjaGUoY3VyciwgY2FjaGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRBdHRycy5wdXNoKGF0dHIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUF1dG9DYWNoZVthdHRyXSA9IGN1cnI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVWaWV3cG9ydEF0dHJzRnJvbVRhcmdldChjaGFuZ2VkQXR0cnMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhbmdlZEF0dHJzW0xFWElDT04ubF0gPiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2hlY2tzIGlzIGEgQ1NTIFByb3BlcnR5IG9mIGEgY2hpbGQgZWxlbWVudCBpcyBhZmZlY3RpbmcgdGhlIHNjcm9sbCBzaXplIG9mIHRoZSBjb250ZW50LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHByb3BlcnR5TmFtZSBUaGUgQ1NTIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvcGVydHkgaXMgYWZmZWN0aW5nIHRoZSBjb250ZW50IHNjcm9sbCBzaXplLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGlzU2l6ZUFmZmVjdGluZ0NTU1Byb3BlcnR5KHByb3BlcnR5TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghX2luaXRpYWxpemVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxleEdyb3cgPSAnZmxleC1ncm93JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxleFNocmluayA9ICdmbGV4LXNocmluayc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZsZXhCYXNpcyA9ICdmbGV4LWJhc2lzJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0aW5nUHJvcHNYID0gW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNaW5NaW51cyArIF9zdHJXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1heE1pbnVzICsgX3N0cldpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTWFyZ2luTWludXMgKyBfc3RyTGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1hcmdpbk1pbnVzICsgX3N0clJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clJpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnZm9udC13ZWlnaHQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnd29yZC1zcGFjaW5nJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhTaHJpbmssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhCYXNpc1xyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGluZ1Byb3BzWENvbnRlbnRCb3ggPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJQYWRkaW5nTWludXMgKyBfc3RyTGVmdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clBhZGRpbmdNaW51cyArIF9zdHJSaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckJvcmRlck1pbnVzICsgX3N0ckxlZnQgKyBfc3RyV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJCb3JkZXJNaW51cyArIF9zdHJSaWdodCArIF9zdHJXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGluZ1Byb3BzWSA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1pbk1pbnVzICsgX3N0ckhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1heE1pbnVzICsgX3N0ckhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1hcmdpbk1pbnVzICsgX3N0clRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ck1hcmdpbk1pbnVzICsgX3N0ckJvdHRvbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0clRvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckJvdHRvbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2xpbmUtaGVpZ2h0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmxleEdyb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhTaHJpbmssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsZXhCYXNpc1xyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGluZ1Byb3BzWUNvbnRlbnRCb3ggPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJQYWRkaW5nTWludXMgKyBfc3RyVG9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyUGFkZGluZ01pbnVzICsgX3N0ckJvdHRvbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckJvcmRlck1pbnVzICsgX3N0clRvcCArIF9zdHJXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckJvcmRlck1pbnVzICsgX3N0ckJvdHRvbSArIF9zdHJXaWR0aFxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9zdHJTID0gJ3MnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfc3RyVlMgPSAndi1zJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tYID0gX292ZXJmbG93QmVoYXZpb3JDYWNoZS54ID09PSBfc3RyUyB8fCBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLnggPT09IF9zdHJWUztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tZID0gX292ZXJmbG93QmVoYXZpb3JDYWNoZS55ID09PSBfc3RyUyB8fCBfb3ZlcmZsb3dCZWhhdmlvckNhY2hlLnkgPT09IF9zdHJWUztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2l6ZUlzQWZmZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hlY2tQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiAoYXJyLCBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyW0xFWElDT04ubF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXSA9PT0gbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrWSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplSXNBZmZlY3RlZCA9IGNoZWNrUHJvcGVydHlOYW1lKGFmZmVjdGluZ1Byb3BzWSwgcHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaXplSXNBZmZlY3RlZCAmJiAhX2lzQm9yZGVyQm94KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUlzQWZmZWN0ZWQgPSBjaGVja1Byb3BlcnR5TmFtZShhZmZlY3RpbmdQcm9wc1lDb250ZW50Qm94LCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tYICYmICFzaXplSXNBZmZlY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplSXNBZmZlY3RlZCA9IGNoZWNrUHJvcGVydHlOYW1lKGFmZmVjdGluZ1Byb3BzWCwgcHJvcGVydHlOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaXplSXNBZmZlY3RlZCAmJiAhX2lzQm9yZGVyQm94KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUlzQWZmZWN0ZWQgPSBjaGVja1Byb3BlcnR5TmFtZShhZmZlY3RpbmdQcm9wc1hDb250ZW50Qm94LCBwcm9wZXJ0eU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZUlzQWZmZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBVcGRhdGUgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIG9mIHRoZSB2aWV3cG9ydCBlbGVtZW50IHRvIHRoZSB2YWx1ZXMgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgdmFsdWUgb2YgYSBhdHRyaWJ1dGUgaXMgb25seSBzZXQgaWYgdGhlIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZC5cclxuICAgICAgICAgICAgICAgICAqIEBhdHRycyBhdHRycyBUaGUgYXJyYXkgb2YgYXR0cmlidXRlcyB3aGljaCBzaGFsbCBiZSBzZXQgb3IgdW5kZWZpbmVkIGlmIGFsbCB3aGl0ZWxpc3RlZCBzaGFsbCBiZSBzZXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZpZXdwb3J0QXR0cnNGcm9tVGFyZ2V0KGF0dHJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMgPSBhdHRycyB8fCBfdmlld3BvcnRBdHRyc0Zyb21UYXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZWFjaChhdHRycywgZnVuY3Rpb24gKGluZGV4LCBhdHRyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmluQShhdHRyLCBfdmlld3BvcnRBdHRyc0Zyb21UYXJnZXQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRBdHRyID0gX3RhcmdldEVsZW1lbnQuYXR0cihhdHRyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKHRhcmdldEF0dHIpID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmF0dHIoYXR0ciwgdGFyZ2V0QXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LnJlbW92ZUF0dHIoYXR0cik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIHZhcmlhYmxlcyBhbmQgc2l6ZSBvZiB0aGUgdGV4dGFyZWEgZWxlbWVudCwgYW5kIG1hbmFnZXMgdGhlIHNjcm9sbCBvbiBuZXcgbGluZSBvciBuZXcgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYVVwZGF0ZSgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcEF0dHJPZmYgPSAhX3RleHRhcmVhQXV0b1dyYXBwaW5nQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtaW5XaWR0aCA9IF92aWV3cG9ydFNpemUudztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbkhlaWdodCA9IF92aWV3cG9ydFNpemUuaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNzcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9NZWFzdXJlID0gX3dpZHRoQXV0b0NhY2hlIHx8IHdyYXBBdHRyT2ZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ1dpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXNldCBtaW4gc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJNaW5NaW51cyArIF9zdHJIZWlnaHRdID0gX3N0ckVtcHR5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgd2lkdGggYXV0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IF9zdHJBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5jc3MoY3NzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnV2lkdGggPSBfdGFyZ2V0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBkb01lYXN1cmUgPyBNQVRILm1heChvcmlnV2lkdGgsIF90YXJnZXRFbGVtZW50TmF0aXZlW0xFWElDT04uc1ddIC0gMSkgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKndpZHRoICs9IChfd2lkdGhBdXRvQ2FjaGUgPyBfbWFyZ2luWCArICghX2lzQm9yZGVyQm94ID8gd3JhcEF0dHJPZmYgPyAwIDogX3BhZGRpbmdYICsgX2JvcmRlclggOiAwKSA6IDApOyovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCBtZWFzdXJlZCB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0cldpZHRoXSA9IF93aWR0aEF1dG9DYWNoZSA/IF9zdHJBdXRvIC8qd2lkdGgqLyA6IF9zdHJIdW5kcmVkUGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJNaW5NaW51cyArIF9zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3NldCBoZWlnaHQgYXV0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NbX3N0ckhlaWdodF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQuY3NzKGNzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdIZWlnaHQgPSBfdGFyZ2V0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gTUFUSC5tYXgob3JpZ0hlaWdodCwgX3RhcmdldEVsZW1lbnROYXRpdmVbTEVYSUNPTi5zSF0gLSAxKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwZW5kIGNvcnJlY3Qgc2l6ZSB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJXaWR0aF0gPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJIZWlnaHRdID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFDb3ZlckVsZW1lbnQuY3NzKGNzcyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IG1pbiB3aWR0aCAvIG1pbiBoZWlnaHQgdG8gcHJldmVudCB0ZXh0YXJlYSBjb2xsYXBzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNzc1tfc3RyTWluTWludXMgKyBfc3RyV2lkdGhdID0gbWluV2lkdGggLyorICghX2lzQm9yZGVyQm94ICYmIF93aWR0aEF1dG9DYWNoZSA/IF9wYWRkaW5nWCArIF9ib3JkZXJYIDogMCkqLztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzW19zdHJNaW5NaW51cyArIF9zdHJIZWlnaHRdID0gbWluSGVpZ2h0IC8qKyAoIV9pc0JvcmRlckJveCAmJiBfaGVpZ2h0QXV0b0NhY2hlID8gX3BhZGRpbmdZICsgX2JvcmRlclkgOiAwKSovO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5jc3MoY3NzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3JpZ2luYWxXaWR0aDogb3JpZ1dpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29yaWdpbmFsSGVpZ2h0OiBvcmlnSGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2R5bmFtaWNXaWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZHluYW1pY0hlaWdodDogaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyB0aGUgcGx1Z2luIGFuZCBET00gdG8gdGhlIGN1cnJlbnQgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBhIHVwZGF0ZSBpcyAxMDAlIHJlcXVpcmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHVwZGF0ZUhpbnRzIEEgb2JqZWN0cyB3aGljaCBjb250YWlucyBoaW50cyBmb3IgdGhpcyB1cGRhdGU6XHJcbiAgICAgICAgICAgICAgICAgKiB7XHJcbiAgICAgICAgICAgICAgICAgKiAgIF9ob3N0U2l6ZUNoYW5nZWQgOiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICogICBfY29udGVudFNpemVDaGFuZ2VkIDogYm9vbGVhbixcclxuICAgICAgICAgICAgICAgICAqICAgX2ZvcmNlIDogYm9vbGVhbiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgID09IHByZXZlbnRTd2FsbG93aW5nXHJcbiAgICAgICAgICAgICAgICAgKiAgIF9jaGFuZ2VkT3B0aW9ucyA6IHsgfSwgICAgICAgICAgICAgICAgICAgICAgICA9PSBwcmV2ZW50U3dhbGxvd2luZyAmJiBwcmV2ZW50U2xlZXBcclxuICAgICAgICAgICAgICAgICogIH1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlKHVwZGF0ZUhpbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9zd2FsbG93ZWRVcGRhdGVUaW1lb3V0KTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVIaW50cyA9IHVwZGF0ZUhpbnRzIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIF9zd2FsbG93ZWRVcGRhdGVIaW50cy5faG9zdFNpemVDaGFuZ2VkIHw9IHVwZGF0ZUhpbnRzLl9ob3N0U2l6ZUNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N3YWxsb3dlZFVwZGF0ZUhpbnRzLl9jb250ZW50U2l6ZUNoYW5nZWQgfD0gdXBkYXRlSGludHMuX2NvbnRlbnRTaXplQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICBfc3dhbGxvd2VkVXBkYXRlSGludHMuX2ZvcmNlIHw9IHVwZGF0ZUhpbnRzLl9mb3JjZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdyA9IENPTVBBVElCSUxJVFkubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RTaXplQ2hhbmdlZCA9ICEhX3N3YWxsb3dlZFVwZGF0ZUhpbnRzLl9ob3N0U2l6ZUNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRTaXplQ2hhbmdlZCA9ICEhX3N3YWxsb3dlZFVwZGF0ZUhpbnRzLl9jb250ZW50U2l6ZUNoYW5nZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvcmNlID0gISFfc3dhbGxvd2VkVXBkYXRlSGludHMuX2ZvcmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkT3B0aW9ucyA9IHVwZGF0ZUhpbnRzLl9jaGFuZ2VkT3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3dhbGxvdyA9IF9zd2FsbG93VXBkYXRlTGFnID4gMCAmJiBfaW5pdGlhbGl6ZWQgJiYgIV9kZXN0cm95ZWQgJiYgIWZvcmNlICYmICFjaGFuZ2VkT3B0aW9ucyAmJiAobm93IC0gX2xhc3RVcGRhdGVUaW1lKSA8IF9zd2FsbG93VXBkYXRlTGFnICYmICghX2hlaWdodEF1dG9DYWNoZSAmJiAhX3dpZHRoQXV0b0NhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZGlzcGxheUlzSGlkZGVuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3dhbGxvdylcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N3YWxsb3dlZFVwZGF0ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHVwZGF0ZSwgX3N3YWxsb3dVcGRhdGVMYWcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Fib3J0IHVwZGF0ZSBkdWUgdG86XHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXN0cm95ZWRcclxuICAgICAgICAgICAgICAgICAgICAvL3N3YWxsb3dpbmdcclxuICAgICAgICAgICAgICAgICAgICAvL3NsZWVwaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ob3N0IGlzIGhpZGRlbiBvciBoYXMgZmFsc2UgZGlzcGxheVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGVzdHJveWVkIHx8IHN3YWxsb3cgfHwgKF9zbGVlcGluZyAmJiAhY2hhbmdlZE9wdGlvbnMpIHx8IChfaW5pdGlhbGl6ZWQgJiYgIWZvcmNlICYmIChkaXNwbGF5SXNIaWRkZW4gPSBfaG9zdEVsZW1lbnQuaXMoJzpoaWRkZW4nKSkpIHx8IF9ob3N0RWxlbWVudC5jc3MoJ2Rpc3BsYXknKSA9PT0gJ2lubGluZScpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgX2xhc3RVcGRhdGVUaW1lID0gbm93O1xyXG4gICAgICAgICAgICAgICAgICAgIF9zd2FsbG93ZWRVcGRhdGVIaW50cyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2lmIHNjcm9sbGJhciBzdHlsaW5nIGlzIHBvc3NpYmxlIGFuZCBuYXRpdmUgc2Nyb2xsYmFycyBhcmVuJ3Qgb3ZlcmxhaWQgdGhlIHNjcm9sbGJhciBzdHlsaW5nIHdpbGwgYmUgYXBwbGllZCB3aGljaCBoaWRlcyB0aGUgbmF0aXZlIHNjcm9sbGJhcnMgY29tcGxldGVseS5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcgJiYgIShfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbmF0aXZlIHNjcm9sbGJhcnMgYXJlIGhpZGRlbiwgc28gY2hhbmdlIHRoZSB2YWx1ZXMgdG8gemVyb1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyU2l6ZS54ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX25hdGl2ZVNjcm9sbGJhclNpemUueSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlZnJlc2ggbmF0aXZlIHNjcm9sbGJhciBzaXplIChpbiBjYXNlIG9mIHpvb20pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJTaXplID0gZXh0ZW5kRGVlcCh7fSwgZ2xvYmFscy5uYXRpdmVTY3JvbGxiYXJTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNjcm9sbGJhciBwYWRkaW5nIGlzIG5lZWRlZCBmb3IgZmlyZWZveCwgYmVjYXVzZSBmaXJlZm94IGhpZGVzIHNjcm9sbGJhciBhdXRvbWF0aWNhbGx5IGlmIHRoZSBzaXplIG9mIHRoZSBkaXYgaXMgdG9vIHNtYWxsLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjYWxjdWxhdGlvbjogW3Njcm9sbGJhciBzaXplICszICozXVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICgrMyBiZWNhdXNlIG9mIHBvc3NpYmxlIGRlY29yYXRpb24gZS5nLiBib3JkZXJzLCBtYXJnaW5zIGV0Yy4sIGJ1dCBvbmx5IGlmIG5hdGl2ZSBzY3JvbGxiYXIgaXMgTk9UIGEgb3ZlcmxhaWQgc2Nyb2xsYmFyKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICgqMyBiZWNhdXNlICgxKWluY3JlYXNlIC8gKDIpZGVjcmVhc2UgLWJ1dHRvbiBhbmQgKDMpcmVzaXplIGhhbmRsZSlcclxuICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogKF9uYXRpdmVTY3JvbGxiYXJTaXplLnggKyAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCA/IDAgOiAzKSkgKiAzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAoX25hdGl2ZVNjcm9sbGJhclNpemUueSArIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55ID8gMCA6IDMpKSAqIDNcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkT3B0aW9ucyA9IGNoYW5nZWRPcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJlZXplUmVzaXplT2JzZXJ2ZXIoX3NpemVPYnNlcnZlckVsZW1lbnQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJlZXplUmVzaXplT2JzZXJ2ZXIoX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrQ2FjaGVBdXRvRm9yY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0NhY2hlLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoW2ZvcmNlXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2F2ZSBjdXJyZW50IHNjcm9sbCBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclNjcm9sbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgpXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuc2Nyb2xsYmFycztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFByZXBhcmVkT3B0aW9uc1RleHRhcmVhID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMudGV4dGFyZWE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyB2aXNpYmlsaXR5OlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzVmlzaWJpbGl0eSA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzLnZpc2liaWxpdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNWaXNpYmlsaXR5Q2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uoc2Nyb2xsYmFyc1Zpc2liaWxpdHksIF9zY3JvbGxiYXJzVmlzaWJpbGl0eUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIGF1dG9IaWRlOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzQXV0b0hpZGUgPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zU2Nyb2xsYmFycy5hdXRvSGlkZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc0F1dG9IaWRlQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uoc2Nyb2xsYmFyc0F1dG9IaWRlLCBfc2Nyb2xsYmFyc0F1dG9IaWRlQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Njcm9sbGJhcnMgY2xpY2sgc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZyA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzLmNsaWNrU2Nyb2xsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmcsIF9zY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyBkcmFnIHNjcm9sbGluZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZyA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNTY3JvbGxiYXJzLmRyYWdTY3JvbGxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uoc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmcsIF9zY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jbGFzc05hbWVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShjbGFzc05hbWUsIF9jbGFzc05hbWVDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc2l6ZSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnJlc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzaXplQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UocmVzaXplLCBfcmVzaXplQ2FjaGUpICYmICFfaXNCb2R5OyAvL2JvZHkgY2FuJ3QgYmUgcmVzaXplZCBzaW5jZSB0aGUgd2luZG93IGl0c2VsZiBhY3RzIGFzIHJlc2l6ZSBwb3NzaWJpbGl0eS5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9wYWRkaW5nQWJzb2x1dGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0Fic29sdXRlID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMucGFkZGluZ0Fic29sdXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShwYWRkaW5nQWJzb2x1dGUsIF9wYWRkaW5nQWJzb2x1dGVDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY2xpcEFsd2F5c1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGlwQWx3YXlzID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuY2xpcEFsd2F5cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xpcEFsd2F5c0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGNsaXBBbHdheXMsIF9jbGlwQWx3YXlzQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NpemVBdXRvQ2FwYWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplQXV0b0NhcGFibGUgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5zaXplQXV0b0NhcGFibGUgJiYgIV9pc0JvZHk7IC8vYm9keSBjYW4gbmV2ZXIgYmUgc2l6ZSBhdXRvLCBiZWNhdXNlIGl0IHNoYWxsIGJlIGFsd2F5cyBhcyBiaWcgYXMgdGhlIHZpZXdwb3J0LlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplQXV0b0NhcGFibGVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShzaXplQXV0b0NhcGFibGUsIF9zaXplQXV0b0NhcGFibGVDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2hvd05hdGl2ZVNjcm9sbGJhcnNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLm5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC5zaG93TmF0aXZlU2Nyb2xsYmFycztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZ0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcsIF9pZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2F1dG9VcGRhdGVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXV0b1VwZGF0ZSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLmF1dG9VcGRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9VcGRhdGVDaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShhdXRvVXBkYXRlLCBfYXV0b1VwZGF0ZUNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vdmVyZmxvd0JlaGF2aW9yXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3IgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5vdmVyZmxvd0JlaGF2aW9yO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9yQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2Uob3ZlcmZsb3dCZWhhdmlvciwgX292ZXJmbG93QmVoYXZpb3JDYWNoZSwgZm9yY2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2R5bldpZHRoOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUR5bldpZHRoID0gY3VycmVudFByZXBhcmVkT3B0aW9uc1RleHRhcmVhLmR5bldpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUR5bldpZHRoQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoX3RleHRhcmVhRHluV2lkdGhDYWNoZSwgdGV4dGFyZWFEeW5XaWR0aCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZHluSGVpZ2h0OlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUR5bkhlaWdodCA9IGN1cnJlbnRQcmVwYXJlZE9wdGlvbnNUZXh0YXJlYS5keW5IZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhRHluSGVpZ2h0Q2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoX3RleHRhcmVhRHluSGVpZ2h0Q2FjaGUsIHRleHRhcmVhRHluSGVpZ2h0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIHZpc2liaWxpdHlcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlTmV2ZXIgPSBzY3JvbGxiYXJzQXV0b0hpZGUgPT09ICduJztcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlU2Nyb2xsID0gc2Nyb2xsYmFyc0F1dG9IaWRlID09PSAncyc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUgPSBzY3JvbGxiYXJzQXV0b0hpZGUgPT09ICdtJztcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUgPSBzY3JvbGxiYXJzQXV0b0hpZGUgPT09ICdsJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zY3JvbGxiYXJzIGF1dG9IaWRlRGVsYXlcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlRGVsYXkgPSBjdXJyZW50UHJlcGFyZWRPcHRpb25zU2Nyb2xsYmFycy5hdXRvSGlkZURlbGF5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL29sZCBjbGFzc05hbWVcclxuICAgICAgICAgICAgICAgICAgICBfb2xkQ2xhc3NOYW1lID0gX2NsYXNzTmFtZUNhY2hlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3Jlc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNpemVOb25lID0gcmVzaXplID09PSAnbic7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Jlc2l6ZUJvdGggPSByZXNpemUgPT09ICdiJztcclxuICAgICAgICAgICAgICAgICAgICBfcmVzaXplSG9yaXpvbnRhbCA9IHJlc2l6ZSA9PT0gJ2gnO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNpemVWZXJ0aWNhbCA9IHJlc2l6ZSA9PT0gJ3YnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL25vcm1hbGl6ZVJUTFxyXG4gICAgICAgICAgICAgICAgICAgIF9ub3JtYWxpemVSVExDYWNoZSA9IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLm5vcm1hbGl6ZVJUTDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZ25vcmUgb3ZlcmxheSBzY3JvbGxiYXIgaGlkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyA9IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcgJiYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnggJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVmcmVzaCBvcHRpb25zIGNhY2hlXHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNWaXNpYmlsaXR5Q2FjaGUgPSBzY3JvbGxiYXJzVmlzaWJpbGl0eTtcclxuICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlQ2FjaGUgPSBzY3JvbGxiYXJzQXV0b0hpZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NhY2hlID0gc2Nyb2xsYmFyc0NsaWNrU2Nyb2xsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NhY2hlID0gc2Nyb2xsYmFyc0RyYWdTY3JvbGxpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUNhY2hlID0gY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXNpemVDYWNoZSA9IHJlc2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0Fic29sdXRlQ2FjaGUgPSBwYWRkaW5nQWJzb2x1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NsaXBBbHdheXNDYWNoZSA9IGNsaXBBbHdheXM7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvQ2FwYWJsZUNhY2hlID0gc2l6ZUF1dG9DYXBhYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2FjaGUgPSBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hdXRvVXBkYXRlQ2FjaGUgPSBhdXRvVXBkYXRlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9vdmVyZmxvd0JlaGF2aW9yQ2FjaGUgPSBleHRlbmREZWVwKHt9LCBvdmVyZmxvd0JlaGF2aW9yKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFEeW5XaWR0aENhY2hlID0gdGV4dGFyZWFEeW5XaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFEeW5IZWlnaHRDYWNoZSA9IHRleHRhcmVhRHluSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIF9oYXNPdmVyZmxvd0NhY2hlID0gX2hhc092ZXJmbG93Q2FjaGUgfHwgeyB4OiBmYWxzZSwgeTogZmFsc2UgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgY29ycmVjdCBjbGFzcyBuYW1lIHRvIHRoZSBob3N0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3NOYW1lQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9vbGRDbGFzc05hbWUgKyBfc3RyU3BhY2UgKyBfY2xhc3NOYW1lVGhlbWVOb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBjbGFzc05hbWUgIT09IHVuZGVmaW5lZCAmJiBjbGFzc05hbWUgIT09IG51bGwgJiYgY2xhc3NOYW1lLmxlbmd0aCA+IDAgPyBjbGFzc05hbWUgOiBfY2xhc3NOYW1lVGhlbWVOb25lKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IGNvcnJlY3QgYXV0byBVcGRhdGVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b1VwZGF0ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF1dG9VcGRhdGUgPT09IHRydWUgfHwgKGF1dG9VcGRhdGUgPT09IG51bGwgJiYgX2F1dG9VcGRhdGVSZWNvbW1lbmRlZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZUxvb3AuYWRkKF9iYXNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9VcGRhdGVMb29wLnJlbW92ZShfYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHNpemUgYXV0byBjYXBhYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVBdXRvQ2FwYWJsZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVBdXRvQ2FwYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZW50R2x1ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LnNob3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQgPSBGUkFNRVdPUksoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZUNvbnRlbnRHbHVlRWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5iZWZvcmUoX2NvbnRlbnRHbHVlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudC5zaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQgPSBGUkFNRVdPUksoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZVNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlID0gX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50WzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmJlZm9yZShfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvbGRTaXplID0geyB3OiAtMSwgaDogLTEgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc2l6ZU9ic2VydmVyKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2l6ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IF9zaXplQXV0b09ic2VydmVyRWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IF9zaXplQXV0b09ic2VydmVyRWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tDYWNoZShuZXdTaXplLCBvbGRTaXplKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pbml0aWFsaXplZCAmJiAoX2hlaWdodEF1dG9DYWNoZSAmJiBuZXdTaXplLmggPiAwKSB8fCAoX3dpZHRoQXV0b0NhY2hlICYmIG5ld1NpemUudyA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfaW5pdGlhbGl6ZWQgJiYgKCFfaGVpZ2h0QXV0b0NhY2hlICYmIG5ld1NpemUuaCA9PT0gMCkgfHwgKCFfd2lkdGhBdXRvQ2FjaGUgJiYgbmV3U2l6ZS53ID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZFNpemUgPSBuZXdTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyQWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZml4IGhlaWdodEF1dG8gZGV0ZWN0b3IgYnVnIGlmIGhlaWdodCBpcyBmaXhlZCBidXQgY29udGVudEhlaWdodCBpcyAwLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhlIHByb2JhYmlsaXR5IHRoaXMgYnVnIHdpbGwgZXZlciBoYXBwZW4gaXMgdmVyeSB2ZXJ5IGxvdywgdGhhdHMgd2h5IGl0cyBvayBpZiB3ZSB1c2UgY2FsYyB3aGljaCBpc24ndCBzdXBwb3J0ZWQgaW4gSUU4LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfY3NzQ2FsYyAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50LmNzcyhfc3RySGVpZ2h0LCBfY3NzQ2FsYyArICcoMTAwJSArIDFweCknKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2l6ZUF1dG9PYnNlcnZlckFkZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudC5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnRlbnRHbHVlRWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBmb3JjZSwgdXBkYXRlIGFsbCByZXNpemVPYnNlcnZlcnMgdG9vXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplT2JzZXJ2ZXJFbGVtZW50LmZpbmQoJyonKS50cmlnZ2VyKF9zdHJTY3JvbGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3NpemVBdXRvT2JzZXJ2ZXJBZGRlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplQXV0b09ic2VydmVyRWxlbWVudC5maW5kKCcqJykudHJpZ2dlcihfc3RyU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGlzcGxheSBoaWRkZW46XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUlzSGlkZGVuID0gZGlzcGxheUlzSGlkZGVuID09PSB1bmRlZmluZWQgPyBfaG9zdEVsZW1lbnQuaXMoJzpoaWRkZW4nKSA6IGRpc3BsYXlJc0hpZGRlbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy90ZXh0YXJlYSBBdXRvV3JhcHBpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQXV0b1dyYXBwaW5nID0gX2lzVGV4dGFyZWEgPyBfdGFyZ2V0RWxlbWVudC5hdHRyKCd3cmFwJykgIT09ICdvZmYnIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQXV0b1dyYXBwaW5nQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UodGV4dGFyZWFBdXRvV3JhcHBpbmcsIF90ZXh0YXJlYUF1dG9XcmFwcGluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgZGlyZWN0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjc3NEaXJlY3Rpb24gPSBfaG9zdEVsZW1lbnQuY3NzKCdkaXJlY3Rpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3NzRGlyZWN0aW9uQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoY3NzRGlyZWN0aW9uLCBfY3NzRGlyZWN0aW9uQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBib3gtc2l6aW5nOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3hTaXppbmcgPSBfaG9zdEVsZW1lbnQuY3NzKCdib3gtc2l6aW5nJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJveFNpemluZ0NoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGJveFNpemluZywgX2Nzc0JveFNpemluZ0NhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kZXRlY3QgcGFkZGluZzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZyA9IGdldFRvcFJpZ2h0Qm90dG9tTGVmdEhvc3QoX3N0clBhZGRpbmdNaW51cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vd2lkdGggKyBoZWlnaHQgYXV0byBkZXRlY3RpbmcgdmFyOlxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaXplQXV0b09ic2VydmVyRWxlbWVudEJDUmVjdDtcclxuICAgICAgICAgICAgICAgICAgICAvL2V4Y2VwdGlvbiBvY2N1cnMgaW4gSUU4IHNvbWV0aW1lcyAodW5rbm93biBleGNlcHRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnRCQ1JlY3QgPSBfc2l6ZUF1dG9PYnNlcnZlckFkZGVkID8gX3NpemVBdXRvT2JzZXJ2ZXJFbGVtZW50TmF0aXZlW0xFWElDT04uYkNSXSgpIDogbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfaXNSVEwgPSBjc3NEaXJlY3Rpb24gPT09ICdydGwnO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pc0JvcmRlckJveCA9IChib3hTaXppbmcgPT09ICdib3JkZXItYm94Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUlRMTGVmdCA9IF9pc1JUTCA/IF9zdHJMZWZ0IDogX3N0clJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1JUTFJpZ2h0ID0gX2lzUlRMID8gX3N0clJpZ2h0IDogX3N0ckxlZnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IHdpZHRoIGF1dG86XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aEF1dG9PYnNlcnZlckRldGVjdGlvbiA9IChfc2l6ZUF1dG9PYnNlcnZlckFkZGVkICYmIChfaG9zdEVsZW1lbnQuY3NzKF9zdHJGbG9hdCkgIT09ICdub25lJyAvKnx8IF9pc1RleHRhcmVhICovKSkgPyAoTUFUSC5yb3VuZChzaXplQXV0b09ic2VydmVyRWxlbWVudEJDUmVjdC5yaWdodCAtIHNpemVBdXRvT2JzZXJ2ZXJFbGVtZW50QkNSZWN0LmxlZnQpID09PSAwKSAmJiAoIXBhZGRpbmdBYnNvbHV0ZSA/IChfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5jV10gLSBfcGFkZGluZ1gpID4gMCA6IHRydWUpIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpemVBdXRvQ2FwYWJsZSAmJiAhd2lkdGhBdXRvT2JzZXJ2ZXJEZXRlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcEN1cnJIb3N0V2lkdGggPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vV107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0bXBDdXJyQ29udGVudEdsdWVXaWR0aCA9IF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKF9zdHJXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKF9zdHJXaWR0aCwgX3N0ckF1dG8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcE5ld0hvc3RXaWR0aCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoLCB0bXBDdXJyQ29udGVudEdsdWVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoQXV0b1Jlc2l6ZURldGVjdGlvbiA9IHRtcEN1cnJIb3N0V2lkdGggIT09IHRtcE5ld0hvc3RXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aWR0aEF1dG9SZXNpemVEZXRlY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50R2x1ZUVsZW1lbnQuY3NzKF9zdHJXaWR0aCwgdG1wQ3Vyckhvc3RXaWR0aCArIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wTmV3SG9zdFdpZHRoID0gX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRHbHVlRWxlbWVudC5jc3MoX3N0cldpZHRoLCB0bXBDdXJyQ29udGVudEdsdWVXaWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aEF1dG9SZXNpemVEZXRlY3Rpb24gPSB0bXBDdXJySG9zdFdpZHRoICE9PSB0bXBOZXdIb3N0V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdpZHRoQXV0byA9ICh3aWR0aEF1dG9PYnNlcnZlckRldGVjdGlvbiB8fCB3aWR0aEF1dG9SZXNpemVEZXRlY3Rpb24pICYmIHNpemVBdXRvQ2FwYWJsZSAmJiAhZGlzcGxheUlzSGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aWR0aEF1dG9DaGFuZ2VkID0gY2hlY2tDYWNoZUF1dG9Gb3JjZSh3aWR0aEF1dG8sIF93aWR0aEF1dG9DYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhc1dpZHRoQXV0byA9ICF3aWR0aEF1dG8gJiYgX3dpZHRoQXV0b0NhY2hlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBoZWlnaHQgYXV0bzpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0QXV0byA9IF9zaXplQXV0b09ic2VydmVyQWRkZWQgJiYgc2l6ZUF1dG9DYXBhYmxlICYmICFkaXNwbGF5SXNIaWRkZW4gPyAoTUFUSC5yb3VuZChzaXplQXV0b09ic2VydmVyRWxlbWVudEJDUmVjdC5ib3R0b20gLSBzaXplQXV0b09ic2VydmVyRWxlbWVudEJDUmVjdC50b3ApID09PSAwKSAvKiAmJiAoIXBhZGRpbmdBYnNvbHV0ZSAmJiAoX21zaWVWZXJzaW9uID4gOSB8fCAhX21zaWVWZXJzaW9uKSA/IHRydWUgOiB0cnVlKSAqLyA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHRBdXRvQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoaGVpZ2h0QXV0bywgX2hlaWdodEF1dG9DYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdhc0hlaWdodEF1dG8gPSAhaGVpZ2h0QXV0byAmJiBfaGVpZ2h0QXV0b0NhY2hlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2RldGVjdCBib3JkZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy93ZSBuZWVkIHRoZSBib3JkZXIgb25seSBpZiBib3JkZXIgYm94IGFuZCBhdXRvIHNpemVcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlQm9yZGVyWCA9ICh3aWR0aEF1dG8gJiYgX2lzQm9yZGVyQm94KSB8fCAhX2lzQm9yZGVyQm94O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1cGRhdGVCb3JkZXJZID0gKGhlaWdodEF1dG8gJiYgX2lzQm9yZGVyQm94KSB8fCAhX2lzQm9yZGVyQm94O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3JkZXIgPSBnZXRUb3BSaWdodEJvdHRvbUxlZnRIb3N0KF9zdHJCb3JkZXJNaW51cywgJy0nICsgX3N0cldpZHRoLCAhdXBkYXRlQm9yZGVyWCwgIXVwZGF0ZUJvcmRlclkpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZGV0ZWN0IG1hcmdpbjpcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luID0gZ2V0VG9wUmlnaHRCb3R0b21MZWZ0SG9zdChfc3RyTWFyZ2luTWludXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3ZhcnMgdG8gYXBwbHkgY29ycmVjdCBjc3NcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudEVsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudEdsdWVFbGVtZW50Q1NTID0ge307XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZnVuY3NcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0SG9zdFNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaGFzIHRvIGJlIGNsaWVudFNpemUgYmVjYXVzZSBvZmZzZXRTaXplIHJlc3BlY3QgYm9yZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04uY1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogX2hvc3RFbGVtZW50TmF0aXZlW0xFWElDT04uY0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Vmlld3BvcnRTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZpZXdwb3J0IHNpemUgaXMgcGFkZGluZyBjb250YWluZXIgYmVjYXVzZSBpdCBuZXZlciBoYXMgcGFkZGluZywgbWFyZ2luIGFuZCBhIGJvcmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2RldGVybWluZSB6b29tIHJvdW5kaW5nIGVycm9yIC0+IHNvbWV0aW1lcyBzY3JvbGxXaWR0aC9IZWlnaHQgaXMgc21hbGxlciB0aGFuIGNsaWVudFdpZHRoL0hlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmIHRoaXMgaGFwcGVucyBhZGQgdGhlIGRpZmZlcmVuY2UgdG8gdGhlIHZpZXdwb3J0U2l6ZSB0byBjb21wZW5zYXRlIHRoZSByb3VuZGluZyBlcnJvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogX3BhZGRpbmdFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddICsgTUFUSC5tYXgoMCwgX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uY1ddIC0gX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uc1ddKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IF9wYWRkaW5nRWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXSArIE1BVEgubWF4KDAsIF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLmNIXSAtIF9jb250ZW50RWxlbWVudE5hdGl2ZVtMRVhJQ09OLnNIXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3NldCBpbmZvIGZvciBwYWRkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdBYnNvbHV0ZVggPSBfcGFkZGluZ1ggPSBwYWRkaW5nLmwgKyBwYWRkaW5nLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdBYnNvbHV0ZVkgPSBfcGFkZGluZ1kgPSBwYWRkaW5nLnQgKyBwYWRkaW5nLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFkZGluZ0Fic29sdXRlWCAqPSBwYWRkaW5nQWJzb2x1dGUgPyAxIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nQWJzb2x1dGVZICo9IHBhZGRpbmdBYnNvbHV0ZSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmcuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UocGFkZGluZywgX2Nzc1BhZGRpbmdDYWNoZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vc2V0IGluZm8gZm9yIGJvcmRlclxyXG4gICAgICAgICAgICAgICAgICAgIF9ib3JkZXJYID0gYm9yZGVyLmwgKyBib3JkZXIucjtcclxuICAgICAgICAgICAgICAgICAgICBfYm9yZGVyWSA9IGJvcmRlci50ICsgYm9yZGVyLmI7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyLmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGJvcmRlciwgX2Nzc0JvcmRlckNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9zZXQgaW5mbyBmb3IgbWFyZ2luXHJcbiAgICAgICAgICAgICAgICAgICAgX21hcmdpblggPSBtYXJnaW4ubCArIG1hcmdpbi5yO1xyXG4gICAgICAgICAgICAgICAgICAgIF9tYXJnaW5ZID0gbWFyZ2luLnQgKyBtYXJnaW4uYjtcclxuICAgICAgICAgICAgICAgICAgICBtYXJnaW4uYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UobWFyZ2luLCBfY3NzTWFyZ2luQ2FjaGUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlZnJlc2ggY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFBdXRvV3JhcHBpbmdDYWNoZSA9IHRleHRhcmVhQXV0b1dyYXBwaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NEaXJlY3Rpb25DYWNoZSA9IGNzc0RpcmVjdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBfY3NzQm94U2l6aW5nQ2FjaGUgPSBib3hTaXppbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgX3dpZHRoQXV0b0NhY2hlID0gd2lkdGhBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIF9oZWlnaHRBdXRvQ2FjaGUgPSBoZWlnaHRBdXRvO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NQYWRkaW5nQ2FjaGUgPSBwYWRkaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NCb3JkZXJDYWNoZSA9IGJvcmRlcjtcclxuICAgICAgICAgICAgICAgICAgICBfY3NzTWFyZ2luQ2FjaGUgPSBtYXJnaW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vSUVGaXggZGlyZWN0aW9uIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzRGlyZWN0aW9uQ2hhbmdlZCAmJiBfc2l6ZUF1dG9PYnNlcnZlckFkZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQuY3NzKF9zdHJGbG9hdCwgaXNSVExSaWdodCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgcGFkZGluZzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFkZGluZy5jIHx8IGNzc0RpcmVjdGlvbkNoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCB8fCB3aWR0aEF1dG9DaGFuZ2VkIHx8IGhlaWdodEF1dG9DaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgc2l6ZUF1dG9DYXBhYmxlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0VsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQ1NTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nVmFsdWVzID0gW3BhZGRpbmcudCwgcGFkZGluZy5yLCBwYWRkaW5nLmIsIHBhZGRpbmcubF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUb3BSaWdodEJvdHRvbUxlZnQoY29udGVudEdsdWVFbGVtZW50Q1NTLCBfc3RyTWFyZ2luTWludXMsIFstcGFkZGluZy50LCAtcGFkZGluZy5yLCAtcGFkZGluZy5iLCAtcGFkZGluZy5sXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdChwYWRkaW5nRWxlbWVudENTUywgX3N0ckVtcHR5LCBwYWRkaW5nVmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRvcFJpZ2h0Qm90dG9tTGVmdChfaXNUZXh0YXJlYSA/IHRleHRhcmVhQ1NTIDogY29udGVudEVsZW1lbnRDU1MsIF9zdHJQYWRkaW5nTWludXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KHBhZGRpbmdFbGVtZW50Q1NTLCBfc3RyRW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KF9pc1RleHRhcmVhID8gdGV4dGFyZWFDU1MgOiBjb250ZW50RWxlbWVudENTUywgX3N0clBhZGRpbmdNaW51cywgcGFkZGluZ1ZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5jc3MocGFkZGluZ0VsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5jc3ModGV4dGFyZWFDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy92aWV3cG9ydCBzaXplIGlzIHBhZGRpbmcgY29udGFpbmVyIGJlY2F1c2UgaXQgbmV2ZXIgaGFzIHBhZGRpbmcsIG1hcmdpbiBhbmQgYSBib3JkZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0U2l6ZSA9IGdldFZpZXdwb3J0U2l6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZSBUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVNpemUgPSBfaXNUZXh0YXJlYSA/IHRleHRhcmVhVXBkYXRlKCkgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFTaXplQ2hhbmdlZCA9IF9pc1RleHRhcmVhICYmIGNoZWNrQ2FjaGVBdXRvRm9yY2UodGV4dGFyZWFTaXplLCBfdGV4dGFyZWFTaXplQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUR5bk9yaWdTaXplID0gX2lzVGV4dGFyZWEgJiYgdGV4dGFyZWFTaXplID8ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3OiB0ZXh0YXJlYUR5bldpZHRoID8gdGV4dGFyZWFTaXplLl9keW5hbWljV2lkdGggOiB0ZXh0YXJlYVNpemUuX29yaWdpbmFsV2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGg6IHRleHRhcmVhRHluSGVpZ2h0ID8gdGV4dGFyZWFTaXplLl9keW5hbWljSGVpZ2h0IDogdGV4dGFyZWFTaXplLl9vcmlnaW5hbEhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH0gOiB7fTtcclxuICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFTaXplQ2FjaGUgPSB0ZXh0YXJlYVNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZml4IGhlaWdodCBhdXRvIC8gd2lkdGggYXV0byBpbiBjb29wZXJhdGlvbiB3aXRoIGN1cnJlbnQgcGFkZGluZyAmIGJveFNpemluZyBiZWhhdmlvcjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0QXV0byAmJiAoaGVpZ2h0QXV0b0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCB8fCBib3hTaXppbmdDaGFuZ2VkIHx8IHBhZGRpbmcuYyB8fCBib3JkZXIuYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGVpZ2h0QXV0b0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IF9zdHJIdW5kcmVkUGVyY2VudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoQXV0byAmJiAod2lkdGhBdXRvQ2hhbmdlZCB8fCBwYWRkaW5nQWJzb2x1dGVDaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgcGFkZGluZy5jIHx8IGJvcmRlci5jIHx8IGNzc0RpcmVjdGlvbkNoYW5nZWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJXaWR0aF0gPSBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJNYXhNaW51cyArIF9zdHJXaWR0aF0gPSBfc3RySHVuZHJlZFBlcmNlbnQ7IC8vSUUgRml4XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdpZHRoQXV0b0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyV2lkdGhdID0gX3N0ckh1bmRyZWRQZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyRmxvYXRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0ck1heE1pbnVzICsgX3N0cldpZHRoXSA9IF9zdHJFbXB0eTsgLy9JRSBGaXhcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpZHRoQXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RleHRhcmVhRHluT3JpZ1NpemUudyB8fCBfc3RyQXV0byA6OiBkb2VzbnQgd29ya3MgYmVjYXVzZSBhcHBsaWVkIG1hcmdpbiB3aWxsIHNoaWZ0IHdpZHRoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RyV2lkdGhdID0gX3N0ckF1dG87XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyV2lkdGhdID0gVkVORE9SUy5fY3NzUHJvcGVydHlWYWx1ZShfc3RyV2lkdGgsICdtYXgtY29udGVudCBpbnRyaW5zaWMnKSB8fCBfc3RyQXV0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckZsb2F0XSA9IGlzUlRMUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodEF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy90ZXh0YXJlYUR5bk9yaWdTaXplLmggfHwgX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uY0hdIDo6IHVzZSBmb3IgYW50aSBzY3JvbGwganVtcGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0ckhlaWdodF0gPSB0ZXh0YXJlYUR5bk9yaWdTaXplLmggfHwgX2NvbnRlbnRFbGVtZW50TmF0aXZlW0xFWElDT04uY0hdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhjb250ZW50R2x1ZUVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY29udGVudEVsZW1lbnRDU1MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0NIRUNLUE9JTlQgSEVSRSB+XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBbY29udGVudChob3N0KSBjbGllbnQgLyBzY3JvbGwgc2l6ZSwgb3IgdGFyZ2V0IGVsZW1lbnQgZGlyZWN0aW9uLCBvciBjb250ZW50KGhvc3QpIG1heC1zaXplc10gY2hhbmdlZCwgb3IgZm9yY2UgaXMgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChob3N0U2l6ZUNoYW5nZWQgfHwgY29udGVudFNpemVDaGFuZ2VkIHx8IHRleHRhcmVhU2l6ZUNoYW5nZWQgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCB8fCBib3hTaXppbmdDaGFuZ2VkIHx8IHBhZGRpbmdBYnNvbHV0ZUNoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCB3aWR0aEF1dG8gfHwgaGVpZ2h0QXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0byB8fCBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCB8fCBvdmVyZmxvd0JlaGF2aW9yQ2hhbmdlZCB8fCBjbGlwQWx3YXlzQ2hhbmdlZCB8fCByZXNpemVDaGFuZ2VkIHx8IHNjcm9sbGJhcnNWaXNpYmlsaXR5Q2hhbmdlZCB8fCBzY3JvbGxiYXJzQXV0b0hpZGVDaGFuZ2VkIHx8IHNjcm9sbGJhcnNEcmFnU2Nyb2xsaW5nQ2hhbmdlZCB8fCBzY3JvbGxiYXJzQ2xpY2tTY3JvbGxpbmdDaGFuZ2VkIHx8IHRleHRhcmVhRHluV2lkdGhDaGFuZ2VkIHx8IHRleHRhcmVhRHluSGVpZ2h0Q2hhbmdlZCB8fCB0ZXh0YXJlYUF1dG9XcmFwcGluZ0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck92ZXJmbG93ID0gJ292ZXJmbG93JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck92ZXJmbG93WCA9IHN0ck92ZXJmbG93ICsgJy14JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck92ZXJmbG93WSA9IHN0ck92ZXJmbG93ICsgJy15JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyVmlzaWJsZSA9ICd2aXNpYmxlJztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVzZXQgdGhlIHZpZXdwb3J0ICh2ZXJ5IGltcG9ydGFudCBmb3IgbmF0aXZlbHkgb3ZlcmxhaWQgc2Nyb2xsYmFycyBhbmQgem9vbSBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9kb24ndCBjaGFuZ2UgdGhlIG92ZXJmbG93IHByb3AgYXMgaXQgaXMgdmVyeSBleHBlbnNpdmUgYW5kIGFmZmVjdHMgcGVyZm9ybWFuY2UgIUEgTE9UIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRFbGVtZW50UmVzZXRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNldFhUbXAgPSBfaGFzT3ZlcmZsb3dDYWNoZS55ICYmIF9oaWRlT3ZlcmZsb3dDYWNoZS55cyAmJiAhaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyA/IChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55ID8gX3ZpZXdwb3J0RWxlbWVudC5jc3MoaXNSVExMZWZ0KSA6IC1fbmF0aXZlU2Nyb2xsYmFyU2l6ZS55KSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzZXRCb3R0b21UbXAgPSBfaGFzT3ZlcmZsb3dDYWNoZS54ICYmIF9oaWRlT3ZlcmZsb3dDYWNoZS54cyAmJiAhaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyA/IChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ID8gX3ZpZXdwb3J0RWxlbWVudC5jc3MoX3N0ckJvdHRvbSkgOiAtX25hdGl2ZVNjcm9sbGJhclNpemUueCkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VG9wUmlnaHRCb3R0b21MZWZ0KHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTLCBfc3RyRW1wdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5jc3Modmlld3BvcnRFbGVtZW50UmVzZXRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmUgc2V2ZXJhbCBzaXplczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRNZWFzdXJlRWxlbWVudCA9IGdldENvbnRlbnRNZWFzdXJlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2luIEZpcmVmb3ggY29udGVudCBlbGVtZW50IGhhcyB0byBoYXZlIG92ZXJmbG93IGhpZGRlbiwgZWxzZSBlbGVtZW50IG1hcmdpbnMgYXJlbid0IGNhbGN1bGF0ZWQgcHJvcGVybHksIHRoaXMgZWxlbWVudCBwcmV2ZW50cyB0aGlzIGJ1ZywgYnV0IG9ubHkgaWYgc2Nyb2xsYmFycyBhcmVuJ3Qgb3ZlcmxhaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91c2UgY2xpZW50U2l6ZSBiZWNhdXNlIG5hdGl2ZWx5IG92ZXJsYWlkU2Nyb2xsYmFycyBhZGQgYm9yZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogdGV4dGFyZWFEeW5PcmlnU2l6ZS53IHx8IGNvbnRlbnRNZWFzdXJlRWxlbWVudFtMRVhJQ09OLmNXXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IHRleHRhcmVhRHluT3JpZ1NpemUuaCB8fCBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5jSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5zV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5zSF1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgdGhlIGNvcnJlY3Qgdmlld3BvcnQgc3R5bGUgYW5kIG1lYXN1cmUgdmlld3BvcnQgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRSZXNldENTU1tfc3RyQm90dG9tXSA9IHdhc0hlaWdodEF1dG8gPyBfc3RyRW1wdHkgOiByZXNldEJvdHRvbVRtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudFJlc2V0Q1NTW2lzUlRMTGVmdF0gPSB3YXNXaWR0aEF1dG8gPyBfc3RyRW1wdHkgOiByZXNldFhUbXA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmNzcyh2aWV3cG9ydEVsZW1lbnRSZXNldENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0U2l6ZSA9IGdldFZpZXdwb3J0U2l6ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIGFuZCBjb3JyZWN0IHNldmVyYWwgc2l6ZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RTaXplID0gZ2V0SG9zdFNpemUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvc3RBYnNvbHV0ZVJlY3RTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogaG9zdFNpemUudyAtIF9tYXJnaW5YIC0gX2JvcmRlclggLSAoX2lzQm9yZGVyQm94ID8gMCA6IF9wYWRkaW5nWCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBob3N0U2l6ZS5oIC0gX21hcmdpblkgLSBfYm9yZGVyWSAtIChfaXNCb3JkZXJCb3ggPyAwIDogX3BhZGRpbmdZKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudEdsdWVTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jbGllbnQvc2Nyb2xsU2l6ZSArIEFic29sdXRlUGFkZGluZyAtPiBiZWNhdXNlIHBhZGRpbmcgaXMgb25seSBhcHBsaWVkIHRvIHRoZSBwYWRkaW5nRWxlbWVudCBpZiBpdHMgYWJzb2x1dGUsIHNvIHlvdSBoYXZlIHRvIGFkZCBpdCBtYW51YWxseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ob3N0U2l6ZSBpcyBjbGllbnRTaXplIC0+IHNvIHBhZGRpbmcgc2hvdWxkIGJlIGFkZGVkIG1hbnVhbGx5LCByaWdodD8gRkFMU0UhIEJlY2F1c2UgY29udGVudCBnbHVlIGlzIGluc2lkZSBob3N0RWxlbWVudCwgc28gd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCBwYWRkaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBNQVRILm1heCgod2lkdGhBdXRvID8gY29udGVudFNpemUudyA6IHNjcm9sbFNpemUudykgKyBwYWRkaW5nQWJzb2x1dGVYLCBob3N0QWJzb2x1dGVSZWN0U2l6ZS53KSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGg6IE1BVEgubWF4KChoZWlnaHRBdXRvID8gY29udGVudFNpemUuaCA6IHNjcm9sbFNpemUuaCkgKyBwYWRkaW5nQWJzb2x1dGVZLCBob3N0QWJzb2x1dGVSZWN0U2l6ZS5oKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZVNpemUuYyA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoY29udGVudEdsdWVTaXplLCBfY29udGVudEdsdWVTaXplQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVTaXplQ2FjaGUgPSBjb250ZW50R2x1ZVNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IGNvcnJlY3QgY29udGVudEdsdWUgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZUF1dG9DYXBhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3NpemUgY29udGVudEdsdWUgY29ycmVjdGx5IHRvIG1ha2Ugc3VyZSB0aGUgZWxlbWVudCBoYXMgY29ycmVjdCBzaXplIGlmIHRoZSBzaXppbmcgc3dpdGNoZXMgdG8gYXV0b1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRHbHVlU2l6ZS5jIHx8IChoZWlnaHRBdXRvIHx8IHdpZHRoQXV0bykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IGNvbnRlbnRHbHVlU2l6ZS53O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRHbHVlRWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IGNvbnRlbnRHbHVlU2l6ZS5oO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3RleHRhcmVhLXNpemVzIGFyZSBhbHJlYWR5IGNhbGN1bGF0ZWQgY29ycmVjdGx5IGF0IHRoaXMgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTaXplID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91c2UgY2xpZW50U2l6ZSBiZWNhdXNlIG5hdGl2ZWx5IG92ZXJsYWlkU2Nyb2xsYmFycyBhZGQgYm9yZGVyc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdzogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uY1ddLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDogY29udGVudE1lYXN1cmVFbGVtZW50W0xFWElDT04uY0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhQ292ZXJDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRDb250ZW50R2x1ZUVsZW1lbnRDU1NmdW5jdGlvbiA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnMgPSBnZXRTY3JvbGxiYXJWYXJzKGhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3aCA9IHNjcm9sbGJhclZhcnMuX3dfaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyV0ggPSBzY3JvbGxiYXJWYXJzLl93aWR0aF9oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF1dG9TaXplID0gaG9yaXpvbnRhbCA/IHdpZHRoQXV0byA6IGhlaWdodEF1dG87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlclNpemUgPSBob3Jpem9udGFsID8gX2JvcmRlclggOiBfYm9yZGVyWTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ1NpemUgPSBob3Jpem9udGFsID8gX3BhZGRpbmdYIDogX3BhZGRpbmdZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW5TaXplID0gaG9yaXpvbnRhbCA/IF9tYXJnaW5YIDogX21hcmdpblk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0U2l6ZSA9IF92aWV3cG9ydFNpemVbd2hdIC0gYm9yZGVyU2l6ZSAtIG1hcmdpblNpemUgLSAoX2lzQm9yZGVyQm94ID8gMCA6IHBhZGRpbmdTaXplKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIGNvbnRlbnRHbHVlIHNpemUgLTEgaWYgZWxlbWVudCBpcyBub3QgYXV0byBzaXplZCwgdG8gbWFrZSBzdXJlIHRoYXQgYSByZXNpemUgZXZlbnQgaGFwcGVucyB3aGVuIHRoZSBlbGVtZW50IHNocmlua3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWF1dG9TaXplIHx8ICghYXV0b1NpemUgJiYgYm9yZGVyLmMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1Nbc3RyV0hdID0gaG9zdEFic29sdXRlUmVjdFNpemVbd2hdIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBzaXplIGlzIGF1dG8gYW5kIGhvc3QgaXMgc21hbGxlciB0aGFuIHNpemUgYXMgbWluIHNpemUsIG1ha2UgY29udGVudCBnbHVlIHNpemUgLTEgdG8gbWFrZSBzdXJlIHNpemUgY2hhbmdlcyB3aWxsIGJlIGRldGVjdGVkICh0aGlzIGlzIG9ubHkgbmVlZGVkIGlmIHBhZGRpbmcgaXMgMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXV0b1NpemUgJiYgKGNvbnRlbnRTaXplW3doXSA8IHZpZXdwb3J0U2l6ZSkgJiYgKGhvcml6b250YWwgJiYgX2lzVGV4dGFyZWEgPyAhdGV4dGFyZWFBdXRvV3JhcHBpbmcgOiB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYUNvdmVyQ1NTW3N0cldIXSA9IHBhcnNlVG9aZXJvT3JOdW1iZXIoX3RleHRhcmVhQ292ZXJFbGVtZW50LmNzcyhzdHJXSCkpIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEdsdWVFbGVtZW50Q1NTW3N0cldIXSAtPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYWtlIHN1cmUgY29udGVudCBnbHVlIHNpemUgaXMgYXQgbGVhc3QgMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50U2l6ZVt3aF0gPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50R2x1ZUVsZW1lbnRDU1Nbc3RyV0hdID0gTUFUSC5tYXgoMSwgY29udGVudEdsdWVFbGVtZW50Q1NTW3N0cldIXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudEdsdWVFbGVtZW50Q1NTZnVuY3Rpb24odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50R2x1ZUVsZW1lbnRDU1NmdW5jdGlvbihmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1RleHRhcmVhKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUNvdmVyRWxlbWVudC5jc3ModGV4dGFyZWFDb3ZlckNTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEdsdWVFbGVtZW50LmNzcyhjb250ZW50R2x1ZUVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aEF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyV2lkdGhdID0gX3N0ckh1bmRyZWRQZXJjZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhBdXRvICYmICFfaXNCb3JkZXJCb3ggJiYgIV9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJGbG9hdF0gPSAnbm9uZSc7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2FwcGx5IGFuZCByZXNldCBjb250ZW50IHN0eWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY29udGVudEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTUyA9IHt9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIGFnYWluLCBidXQgdGhpcyB0aW1lIGFsbCBjb3JyZWN0IHNpemVzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFNjcm9sbFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3OiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5zV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiBjb250ZW50TWVhc3VyZUVsZW1lbnRbTEVYSUNPTi5zSF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTY3JvbGxTaXplLmMgPSBjb250ZW50U2l6ZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGNvbnRlbnRTY3JvbGxTaXplLCBfY29udGVudFNjcm9sbFNpemVDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlID0gY29udGVudFNjcm9sbFNpemU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3JlZnJlc2ggdmlld3BvcnQgc2l6ZSBhZnRlciBjb3JyZWN0IG1lYXN1cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0U2l6ZSA9IGdldEhvc3RTaXplKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RTaXplQ2hhbmdlZCA9IGNoZWNrQ2FjaGVBdXRvRm9yY2UoaG9zdFNpemUsIF9ob3N0U2l6ZUNhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RTaXplQ2FjaGUgPSBob3N0U2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWRlT3ZlcmZsb3dGb3JjZVRleHRhcmVhID0gX2lzVGV4dGFyZWEgJiYgKF92aWV3cG9ydFNpemUudyA9PT0gMCB8fCBfdmlld3BvcnRTaXplLmggPT09IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNPdmVyZmxvd0Ftb3VudCA9IF9vdmVyZmxvd0Ftb3VudENhY2hlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3ZlcmZsb3dCZWhhdmlvcklzVlMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJmbG93QmVoYXZpb3JJc1ZIID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0JlaGF2aW9ySXNTID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdmVyZmxvd0Ftb3VudCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzT3ZlcmZsb3cgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhpZGVPdmVyZmxvdyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FuU2Nyb2xsID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3cG9ydFJlY3QgPSBfcGFkZGluZ0VsZW1lbnROYXRpdmVbTEVYSUNPTi5iQ1JdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRPdmVyZmxvd1ZhcmlhYmxlcyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0ludmVydGVkID0gZ2V0U2Nyb2xsYmFyVmFycyghaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHlJID0gc2Nyb2xsYmFyVmFyc0ludmVydGVkLl94X3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHkgPSBzY3JvbGxiYXJWYXJzLl94X3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2ggPSBzY3JvbGxiYXJWYXJzLl93X2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2lkdGhIZWlnaHQgPSBzY3JvbGxiYXJWYXJzLl93aWR0aF9oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTWF4ID0gX3N0clNjcm9sbCArIHNjcm9sbGJhclZhcnMuX0xlZnRfVG9wICsgJ01heCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhY3Rpb25hbE92ZXJmbG93QW1vdW50ID0gdmlld3BvcnRSZWN0W3dpZHRoSGVpZ2h0XSA/IE1BVEguYWJzKHZpZXdwb3J0UmVjdFt3aWR0aEhlaWdodF0gLSBfdmlld3BvcnRTaXplW3doXSkgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoZWNrRnJhY3Rpb25hbE92ZXJmbG93QW1vdW50ID0gcHJldmlvdXNPdmVyZmxvd0Ftb3VudCAmJiBwcmV2aW91c092ZXJmbG93QW1vdW50W3h5XSA+IDAgJiYgX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZVtzY3JvbGxNYXhdID09PSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dCZWhhdmlvcklzVlNbeHldID0gb3ZlcmZsb3dCZWhhdmlvclt4eV0gPT09ICd2LXMnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dCZWhhdmlvcklzVkhbeHldID0gb3ZlcmZsb3dCZWhhdmlvclt4eV0gPT09ICd2LWgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dCZWhhdmlvcklzU1t4eV0gPSBvdmVyZmxvd0JlaGF2aW9yW3h5XSA9PT0gJ3MnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3dBbW91bnRbeHldID0gTUFUSC5tYXgoMCwgTUFUSC5yb3VuZCgoY29udGVudFNjcm9sbFNpemVbd2hdIC0gX3ZpZXdwb3J0U2l6ZVt3aF0pICogMTAwKSAvIDEwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvd0Ftb3VudFt4eV0gKj0gKGhpZGVPdmVyZmxvd0ZvcmNlVGV4dGFyZWEgfHwgKGNoZWNrRnJhY3Rpb25hbE92ZXJmbG93QW1vdW50ICYmIGZyYWN0aW9uYWxPdmVyZmxvd0Ftb3VudCA+IDAgJiYgZnJhY3Rpb25hbE92ZXJmbG93QW1vdW50IDwgMSkpID8gMCA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPdmVyZmxvd1t4eV0gPSBvdmVyZmxvd0Ftb3VudFt4eV0gPiAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaGlkZU92ZXJmbG93OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy94IHx8IHkgOiB0cnVlID09PSBvdmVyZmxvdyBpcyBoaWRkZW4gYnkgXCJvdmVyZmxvdzogc2Nyb2xsXCIgT1IgXCJvdmVyZmxvdzogaGlkZGVuXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8veHMgfHwgeXMgOiB0cnVlID09PSBvdmVyZmxvdyBpcyBoaWRkZW4gYnkgXCJvdmVyZmxvdzogc2Nyb2xsXCJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVPdmVyZmxvd1t4eV0gPSBvdmVyZmxvd0JlaGF2aW9ySXNWU1t4eV0gfHwgb3ZlcmZsb3dCZWhhdmlvcklzVkhbeHldID8gKGhhc092ZXJmbG93W3h5SV0gJiYgIW92ZXJmbG93QmVoYXZpb3JJc1ZTW3h5SV0gJiYgIW92ZXJmbG93QmVoYXZpb3JJc1ZIW3h5SV0pIDogaGFzT3ZlcmZsb3dbeHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZU92ZXJmbG93W3h5ICsgJ3MnXSA9IGhpZGVPdmVyZmxvd1t4eV0gPyAob3ZlcmZsb3dCZWhhdmlvcklzU1t4eV0gfHwgb3ZlcmZsb3dCZWhhdmlvcklzVlNbeHldKSA6IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhblNjcm9sbFt4eV0gPSBoYXNPdmVyZmxvd1t4eV0gJiYgaGlkZU92ZXJmbG93W3h5ICsgJ3MnXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3ZlcmZsb3dWYXJpYWJsZXModHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE92ZXJmbG93VmFyaWFibGVzKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QW1vdW50LmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKG92ZXJmbG93QW1vdW50LCBfb3ZlcmZsb3dBbW91bnRDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vdmVyZmxvd0Ftb3VudENhY2hlID0gb3ZlcmZsb3dBbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc092ZXJmbG93LmMgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGhhc092ZXJmbG93LCBfaGFzT3ZlcmZsb3dDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oYXNPdmVyZmxvd0NhY2hlID0gaGFzT3ZlcmZsb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGVPdmVyZmxvdy5jID0gY2hlY2tDYWNoZUF1dG9Gb3JjZShoaWRlT3ZlcmZsb3csIF9oaWRlT3ZlcmZsb3dDYWNoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oaWRlT3ZlcmZsb3dDYWNoZSA9IGhpZGVPdmVyZmxvdztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgbmF0aXZlIHNjcm9sbGJhciBpcyBvdmVybGF5IGF0IHggT1IgeSBheGlzLCBwcmVwYXJlIERPTVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCB8fCBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9yZGVyRGVzaWduID0gJ3B4IHNvbGlkIHRyYW5zcGFyZW50JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZW50QXJyYW5nZUVsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcnJhbmdlQ29udGVudCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmFuZ2VDaGFuZ2VkID0gZm9yY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0Q29udGVudEVsZW1lbnRDU1M7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc092ZXJmbG93LnggfHwgaGFzT3ZlcmZsb3cueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmFuZ2VDb250ZW50LncgPSBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55ICYmIGhhc092ZXJmbG93LnkgPyBjb250ZW50U2Nyb2xsU2l6ZS53ICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueSA6IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ29udGVudC5oID0gX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBoYXNPdmVyZmxvdy54ID8gY29udGVudFNjcm9sbFNpemUuaCArIF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplLnggOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNoYW5nZWQgPSBjaGVja0NhY2hlQXV0b0ZvcmNlKGFycmFuZ2VDb250ZW50LCBfYXJyYW5nZUNvbnRlbnRTaXplQ2FjaGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hcnJhbmdlQ29udGVudFNpemVDYWNoZSA9IGFycmFuZ2VDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVyZmxvdy5jIHx8IGhpZGVPdmVyZmxvdy5jIHx8IGNvbnRlbnRTY3JvbGxTaXplLmMgfHwgY3NzRGlyZWN0aW9uQ2hhbmdlZCB8fCB3aWR0aEF1dG9DaGFuZ2VkIHx8IGhlaWdodEF1dG9DaGFuZ2VkIHx8IHdpZHRoQXV0byB8fCBoZWlnaHRBdXRvIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgaXNSVExSaWdodF0gPSBjb250ZW50RWxlbWVudENTU1tfc3RyQm9yZGVyTWludXMgKyBpc1JUTFJpZ2h0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50RWxlbWVudENTUyA9IGZ1bmN0aW9uIChob3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhob3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnNJbnZlcnRlZCA9IGdldFNjcm9sbGJhclZhcnMoIWhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHkgPSBzY3JvbGxiYXJWYXJzLl94X3k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJEaXJlY3Rpb24gPSBob3Jpem9udGFsID8gX3N0ckJvdHRvbSA6IGlzUlRMTGVmdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludmVydGVkQXV0b1NpemUgPSBob3Jpem9udGFsID8gaGVpZ2h0QXV0byA6IHdpZHRoQXV0bztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZFt4eV0gJiYgaGFzT3ZlcmZsb3dbeHldICYmIGhpZGVPdmVyZmxvd1t4eSArICdzJ10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIHN0ckRpcmVjdGlvbl0gPSBpbnZlcnRlZEF1dG9TaXplID8gKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcgPyBfc3RyRW1wdHkgOiBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZVt4eV0pIDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckJvcmRlck1pbnVzICsgc3RyRGlyZWN0aW9uXSA9ICgoaG9yaXpvbnRhbCA/ICFpbnZlcnRlZEF1dG9TaXplIDogdHJ1ZSkgJiYgIWlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpID8gKF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplW3h5XSArIGJvcmRlckRlc2lnbikgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ29udGVudFtzY3JvbGxiYXJWYXJzSW52ZXJ0ZWQuX3dfaF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIHN0ckRpcmVjdGlvbl0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRFbGVtZW50Q1NTW19zdHJCb3JkZXJNaW51cyArIHN0ckRpcmVjdGlvbl0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJhbmdlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25hdGl2ZVNjcm9sbGJhclN0eWxpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX3ZpZXdwb3J0RWxlbWVudCwgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc0ludmlzaWJsZSwgIWlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb250ZW50RWxlbWVudENTUyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q29udGVudEVsZW1lbnRDU1MoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNvbnRlbnQudyA9IGFycmFuZ2VDb250ZW50LmggPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyYW5nZUNoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycmFuZ2VDaGFuZ2VkICYmICFfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBcnJhbmdlRWxlbWVudENTU1tfc3RyV2lkdGhdID0gaGlkZU92ZXJmbG93LnkgPyBhcnJhbmdlQ29udGVudC53IDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRBcnJhbmdlRWxlbWVudENTU1tfc3RySGVpZ2h0XSA9IGhpZGVPdmVyZmxvdy54ID8gYXJyYW5nZUNvbnRlbnQuaCA6IF9zdHJFbXB0eTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfY29udGVudEFycmFuZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50QXJyYW5nZUVsZW1lbnQgPSBGUkFNRVdPUksoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZUNvbnRlbnRBcnJhbmdlRWxlbWVudCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LnByZXBlbmQoX2NvbnRlbnRBcnJhbmdlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50QXJyYW5nZUVsZW1lbnQuY3NzKGNvbnRlbnRBcnJhbmdlRWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKGNvbnRlbnRFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0VsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNldFZpZXdwb3J0Q1NTO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdFNpemVDaGFuZ2VkIHx8IGhhc092ZXJmbG93LmMgfHwgaGlkZU92ZXJmbG93LmMgfHwgY29udGVudFNjcm9sbFNpemUuYyB8fCBvdmVyZmxvd0JlaGF2aW9yQ2hhbmdlZCB8fCBib3hTaXppbmdDaGFuZ2VkIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkIHx8IGNzc0RpcmVjdGlvbkNoYW5nZWQgfHwgY2xpcEFsd2F5c0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tpc1JUTFJpZ2h0XSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0Q1NTID0gZnVuY3Rpb24gKGhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhclZhcnNJbnZlcnRlZCA9IGdldFNjcm9sbGJhclZhcnMoIWhvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4eSA9IHNjcm9sbGJhclZhcnMuX3hfeTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgWFkgPSBzY3JvbGxiYXJWYXJzLl9YX1k7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfc3RyQm90dG9tIDogaXNSVExMZWZ0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJEaXJlY3Rpb25dID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEJvcmRlclNpemVbc2Nyb2xsYmFyVmFyc0ludmVydGVkLl93X2hdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPdmVyZmxvd1t4eV0gJiYgaGlkZU92ZXJmbG93W3h5ICsgJ3MnXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyT3ZlcmZsb3cgKyBYWV0gPSBfc3RyU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZyB8fCBfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tzdHJEaXJlY3Rpb25dID0gLShfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZFt4eV0gPyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZVt4eV0gOiBfbmF0aXZlU2Nyb2xsYmFyU2l6ZVt4eV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRCb3JkZXJTaXplW3Njcm9sbGJhclZhcnNJbnZlcnRlZC5fd19oXSA9IF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkW3h5XSA/IF9vdmVybGF5U2Nyb2xsYmFyRHVtbXlTaXplW3Njcm9sbGJhclZhcnNJbnZlcnRlZC5feF95XSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1Nbc3RyT3ZlcmZsb3cgKyBYWV0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFZpZXdwb3J0Q1NTKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Vmlld3BvcnRDU1MoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzY3JvbGwgY29udGFpbmVyIGlzIHRvbyBzbWFsbCBhbmQgaWYgdGhlcmUgaXMgYW55IG92ZXJmbG93IHdpdGggbm8gb3ZlcmxheSBzY3JvbGxiYXIgKGFuZCBzY3JvbGxiYXIgc3R5bGluZyBpc24ndCBwb3NzaWJsZSksIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSB2aWV3cG9ydCBlbGVtZW50IGdyZWF0ZXIgaW4gc2l6ZSAoRmlyZWZveCBoaWRlIFNjcm9sbGJhcnMgZml4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBmaXJlZm94IHN0YXJ0cyBoaWRpbmcgc2Nyb2xsYmFycyBvbiB0b28gc21hbGwgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpdGggdGhpcyBiZWhhdmlvciB0aGUgb3ZlcmZsb3cgY2FsY3VsYXRpb24gbWF5IGJlIGluY29ycmVjdCBvciB0aGUgc2Nyb2xsYmFycyB3b3VsZCBhcHBlYXIgc3VkZGVubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTI5MjI4NFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfbmF0aXZlU2Nyb2xsYmFyU3R5bGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChfdmlld3BvcnRTaXplLmggPCBfbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZS54IHx8IF92aWV3cG9ydFNpemUudyA8IF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKChoYXNPdmVyZmxvdy54ICYmIGhpZGVPdmVyZmxvdy54ICYmICFfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54KSB8fCAoaGFzT3ZlcmZsb3cueSAmJiBoaWRlT3ZlcmZsb3cueSAmJiAhX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJQYWRkaW5nTWludXMgKyBfc3RyVG9wXSA9IF9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLng7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJNYXJnaW5NaW51cyArIF9zdHJUb3BdID0gLV9uYXRpdmVTY3JvbGxiYXJNaW5TaXplLng7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyUGFkZGluZ01pbnVzICsgaXNSVExSaWdodF0gPSBfbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBpc1JUTFJpZ2h0XSA9IC1fbmF0aXZlU2Nyb2xsYmFyTWluU2l6ZS55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW19zdHJQYWRkaW5nTWludXMgKyBfc3RyVG9wXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBfc3RyVG9wXSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyUGFkZGluZ01pbnVzICsgaXNSVExSaWdodF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0ck1hcmdpbk1pbnVzICsgaXNSVExSaWdodF0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1NbX3N0clBhZGRpbmdNaW51cyArIGlzUlRMTGVmdF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0RWxlbWVudENTU1tfc3RyTWFyZ2luTWludXMgKyBpc1JUTExlZnRdID0gX3N0ckVtcHR5O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUgaXMgYW55IG92ZXJmbG93ICh4IE9SIHkgYXhpcykgYW5kIHRoaXMgb3ZlcmZsb3cgc2hhbGwgYmUgaGlkZGVuLCBtYWtlIG92ZXJmbG93IGhpZGRlbiwgZWxzZSBvdmVyZmxvdyB2aXNpYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGhhc092ZXJmbG93LnggJiYgaGlkZU92ZXJmbG93LngpIHx8IChoYXNPdmVyZmxvdy55ICYmIGhpZGVPdmVyZmxvdy55KSB8fCBoaWRlT3ZlcmZsb3dGb3JjZVRleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vbmx5IGhpZGUgaWYgaXMgVGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEgJiYgaGlkZU92ZXJmbG93Rm9yY2VUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nRWxlbWVudENTU1tzdHJPdmVyZmxvd1hdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdFbGVtZW50Q1NTW3N0ck92ZXJmbG93WV0gPSBzdHJIaWRkZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjbGlwQWx3YXlzIHx8IChvdmVyZmxvd0JlaGF2aW9ySXNWSC54IHx8IG92ZXJmbG93QmVoYXZpb3JJc1ZTLnggfHwgb3ZlcmZsb3dCZWhhdmlvcklzVkgueSB8fCBvdmVyZmxvd0JlaGF2aW9ySXNWUy55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29ubHkgdW4taGlkZSBpZiBUZXh0YXJlYVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdFbGVtZW50Q1NTW3N0ck92ZXJmbG93WF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmdFbGVtZW50Q1NTW3N0ck92ZXJmbG93WV0gPSBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ck92ZXJmbG93WF0gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnRFbGVtZW50Q1NTW3N0ck92ZXJmbG93WV0gPSBzdHJWaXNpYmxlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQuY3NzKHBhZGRpbmdFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuY3NzKHZpZXdwb3J0RWxlbWVudENTUyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydEVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvcmNlIHNvZnQgcmVkcmF3IGluIHdlYmtpdCBiZWNhdXNlIHdpdGhvdXQgdGhlIHNjcm9sbGJhcnMgd2lsbCBtYXkgYXBwZWFyIGJlY2F1c2UgRE9NIHdvbnQgYmUgcmVkcmF3biB1bmRlciBzcGVjaWFsIGNvbmRpdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaGFzT3ZlcmZsb3cuYyB8fCBib3hTaXppbmdDaGFuZ2VkIHx8IHdpZHRoQXV0b0NoYW5nZWQgfHwgaGVpZ2h0QXV0b0NoYW5nZWQpICYmICEoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50U3R5bGUgPSBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5zXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVtcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKDEpJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50U3R5bGUuZGlzcGxheSA9ICdydW4taW4nO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1bXAgPSBfY29udGVudEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLmRpc3BsYXkgPSBfc3RyRW1wdHk7IC8vfHwgZHVtcDsgLy91c2UgZHVtcCB0byBwcmV2ZW50IGl0IGZyb20gZGVsZXRpb24gaWYgbWluaWZ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZvcmNlIGhhcmQgcmVkcmF3IGluIHdlYmtpdCBpZiBuYXRpdmUgb3ZlcmxhaWQgc2Nyb2xsYmFycyBzaGFsbCBhcHBlYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCAmJiBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50LmhpZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHVtcCA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9IXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQuc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jaGFuZ2UgdG8gZGlyZWN0aW9uIFJUTCBhbmQgd2lkdGggYXV0byBCdWdmaXggaW4gV2Via2l0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vd2l0aG91dCB0aGlzIGZpeCwgdGhlIERPTSBzdGlsbCB0aGlua3MgdGhlIHNjcm9sbGJhciBpcyBMVFIgYW5kIHRodXMgdGhlIGNvbnRlbnQgaXMgc2hpZnRlZCB0byB0aGUgbGVmdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTUyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzRGlyZWN0aW9uQ2hhbmdlZCB8fCB3aWR0aEF1dG9DaGFuZ2VkIHx8IGhlaWdodEF1dG9DaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzUlRMICYmIHdpZHRoQXV0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbG9hdFRtcCA9IF9jb250ZW50RWxlbWVudC5jc3MoX3N0ckZsb2F0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zTGVmdFdpdGhvdXRGbG9hdCA9IE1BVEgucm91bmQoX2NvbnRlbnRFbGVtZW50LmNzcyhfc3RyRmxvYXQsIF9zdHJFbXB0eSkuY3NzKF9zdHJMZWZ0LCBfc3RyRW1wdHkpLnBvc2l0aW9uKCkubGVmdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50LmNzcyhfc3RyRmxvYXQsIGZsb2F0VG1wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zTGVmdFdpdGhGbG9hdCA9IE1BVEgucm91bmQoX2NvbnRlbnRFbGVtZW50LnBvc2l0aW9uKCkubGVmdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NMZWZ0V2l0aG91dEZsb2F0ICE9PSBwb3NMZWZ0V2l0aEZsb2F0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RWxlbWVudENTU1tfc3RyTGVmdF0gPSBwb3NMZWZ0V2l0aG91dEZsb2F0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudEVsZW1lbnRDU1NbX3N0ckxlZnRdID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoY29udGVudEVsZW1lbnRDU1MpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGUgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSAmJiBjb250ZW50U2l6ZUNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUluZm8gPSBnZXRUZXh0YXJlYUluZm8oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0YXJlYUluZm8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFSb3dzQ2hhbmdlZCA9IF90ZXh0YXJlYUluZm9DYWNoZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHRleHRhcmVhSW5mby5fcm93cyAhPT0gX3RleHRhcmVhSW5mb0NhY2hlLl9yb3dzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JSb3cgPSB0ZXh0YXJlYUluZm8uX2N1cnNvclJvdztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yQ29sID0gdGV4dGFyZWFJbmZvLl9jdXJzb3JDb2x1bW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpZGVzdFJvdyA9IHRleHRhcmVhSW5mby5fd2lkZXN0Um93O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0Um93ID0gdGV4dGFyZWFJbmZvLl9yb3dzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0Q29sID0gdGV4dGFyZWFJbmZvLl9jb2x1bW5zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JQb3MgPSB0ZXh0YXJlYUluZm8uX2N1cnNvclBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJzb3JNYXggPSB0ZXh0YXJlYUluZm8uX2N1cnNvck1heDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29ySXNMYXN0UG9zaXRpb24gPSAoY3Vyc29yUG9zID49IGN1cnNvck1heCAmJiBfdGV4dGFyZWFIYXNGb2N1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhU2Nyb2xsQW1vdW50ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAoIXRleHRhcmVhQXV0b1dyYXBwaW5nICYmIChjdXJzb3JDb2wgPT09IGxhc3RDb2wgJiYgY3Vyc29yUm93ID09PSB3aWRlc3RSb3cpKSA/IF9vdmVyZmxvd0Ftb3VudENhY2hlLnggOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogKHRleHRhcmVhQXV0b1dyYXBwaW5nID8gY3Vyc29ySXNMYXN0UG9zaXRpb24gfHwgdGV4dGFyZWFSb3dzQ2hhbmdlZCAmJiAocHJldmlvdXNPdmVyZmxvd0Ftb3VudCA/IChjdXJyU2Nyb2xsLnkgPT09IHByZXZpb3VzT3ZlcmZsb3dBbW91bnQueSkgOiBmYWxzZSkgOiAoY3Vyc29ySXNMYXN0UG9zaXRpb24gfHwgdGV4dGFyZWFSb3dzQ2hhbmdlZCkgJiYgY3Vyc29yUm93ID09PSBsYXN0Um93KSA/IF9vdmVyZmxvd0Ftb3VudENhY2hlLnkgOiAtMVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclNjcm9sbC54ID0gdGV4dGFyZWFTY3JvbGxBbW91bnQueCA+IC0xID8gKF9pc1JUTCAmJiBfbm9ybWFsaXplUlRMQ2FjaGUgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAwIDogdGV4dGFyZWFTY3JvbGxBbW91bnQueCkgOiBjdXJyU2Nyb2xsLng7IC8vaWYgaW52ZXJ0ZWQsIHNjcm9sbCB0byAwIC0+IG5vcm1hbGl6ZWQgdGhpcyBtZWFucyB0byBtYXggc2Nyb2xsIG9mZnNldC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyU2Nyb2xsLnkgPSB0ZXh0YXJlYVNjcm9sbEFtb3VudC55ID4gLTEgPyB0ZXh0YXJlYVNjcm9sbEFtb3VudC55IDogY3VyclNjcm9sbC55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RleHRhcmVhSW5mb0NhY2hlID0gdGV4dGFyZWFJbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLmkgJiYgX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueSAmJiBoYXNPdmVyZmxvdy54ICYmIF9ub3JtYWxpemVSVExDYWNoZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJTY3JvbGwueCArPSBfY29udGVudEJvcmRlclNpemUudyB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkdGhBdXRvKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlaWdodEF1dG8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKGN1cnJTY3JvbGwueClbX3N0clNjcm9sbFRvcF0oY3VyclNjcm9sbC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsYmFycyBtYW5hZ2VtZW50OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyc1Zpc2liaWxpdHlWaXNpYmxlID0gc2Nyb2xsYmFyc1Zpc2liaWxpdHkgPT09ICd2JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNWaXNpYmlsaXR5SGlkZGVuID0gc2Nyb2xsYmFyc1Zpc2liaWxpdHkgPT09ICdoJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhcnNWaXNpYmlsaXR5QXV0byA9IHNjcm9sbGJhcnNWaXNpYmlsaXR5ID09PSAnYSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWZyZXNoU2Nyb2xsYmFyc1Zpc2liaWxpdHkgPSBmdW5jdGlvbiAoc2hvd1gsIHNob3dZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93WSA9IHNob3dZID09PSB1bmRlZmluZWQgPyBzaG93WCA6IHNob3dZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckFwcGVhcmFuY2UodHJ1ZSwgc2hvd1gsIGNhblNjcm9sbC54KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckFwcGVhcmFuY2UoZmFsc2UsIHNob3dZLCBjYW5TY3JvbGwueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIGNsYXNzIG5hbWUgd2hpY2ggaW5kaWNhdGVzIHNjcm9sbGFibGUgb3ZlcmZsb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdE92ZXJmbG93LCBoaWRlT3ZlcmZsb3cueCB8fCBoaWRlT3ZlcmZsb3cueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RPdmVyZmxvd1gsIGhpZGVPdmVyZmxvdy54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WSwgaGlkZU92ZXJmbG93LnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgb3IgcmVtb3ZlIHJ0bCBjbGFzcyBuYW1lIGZvciBzdHlsaW5nIHB1cnBvc2VzIGV4Y2VwdCB3aGVuIGl0cyBib2R5LCB0aGVuIHRoZSBzY3JvbGxiYXIgc3RheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNzc0RpcmVjdGlvbkNoYW5nZWQgJiYgIV9pc0JvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgX2NsYXNzTmFtZUhvc3RSVEwsIF9pc1JUTCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIHRoZSByZXNpemUgZmVhdHVyZSAoQ1NTMyByZXNpemUgXCJwb2x5ZmlsbFwiIGZvciB0aGlzIHBsdWdpbilcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0UmVzaXplRGlzYWJsZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzaXplQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFJlc2l6ZURpc2FibGVkLCBfcmVzaXplTm9uZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZSwgIV9yZXNpemVOb25lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJlbW92ZUNsYXNzKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQ29ybmVyUmVzaXplQiwgX3Jlc2l6ZUJvdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQsIF9jbGFzc05hbWVTY3JvbGxiYXJDb3JuZXJSZXNpemVILCBfcmVzaXplSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRSZW1vdmVDbGFzcyhfc2Nyb2xsYmFyQ29ybmVyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lclJlc2l6ZVYsIF9yZXNpemVWZXJ0aWNhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIHRoZSBzY3JvbGxiYXJzIGdlbmVyYWwgdmlzaWJpbGl0eSArIHRoZSBzY3JvbGxiYXIgaW50ZXJhY3Rpdml0eSAodW51c2FibGUgY2xhc3MgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhcnNWaXNpYmlsaXR5Q2hhbmdlZCB8fCBvdmVyZmxvd0JlaGF2aW9yQ2hhbmdlZCB8fCBoaWRlT3ZlcmZsb3cuYyB8fCBoYXNPdmVyZmxvdy5jIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlT3ZlcmxheVNjcm9sbGJhckhpZGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIF9jbGFzc05hbWVIb3N0U2Nyb2xsaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxiYXJzVmlzaWJpbGl0eUF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc1Zpc2liaWxpdHkoY2FuU2Nyb2xsLngsIGNhblNjcm9sbC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbGJhcnNWaXNpYmlsaXR5VmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzVmlzaWJpbGl0eSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbGJhcnNWaXNpYmlsaXR5SGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNWaXNpYmlsaXR5KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2UgdGhlIHNjcm9sbGJhcnMgYXV0byBoaWRlIGZlYXR1cmUgKGF1dG8gaGlkZSB0aGVtIGFmdGVyIHNwZWNpZmljIGFjdGlvbnMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJzQXV0b0hpZGVDaGFuZ2VkIHx8IGlnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cEhvc3RNb3VzZVRvdWNoRXZlbnRzKCFfc2Nyb2xsYmFyc0F1dG9IaWRlTGVhdmUgJiYgIV9zY3JvbGxiYXJzQXV0b0hpZGVNb3ZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoX3Njcm9sbGJhcnNBdXRvSGlkZU5ldmVyLCAhX3Njcm9sbGJhcnNBdXRvSGlkZU5ldmVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9tYW5hZ2Ugc2Nyb2xsYmFycyBoYW5kbGUgbGVuZ3RoICYgb2Zmc2V0IC0gZG9uJ3QgcmVtb3ZlIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdFNpemVDaGFuZ2VkIHx8IG92ZXJmbG93QW1vdW50LmMgfHwgaGVpZ2h0QXV0b0NoYW5nZWQgfHwgd2lkdGhBdXRvQ2hhbmdlZCB8fCByZXNpemVDaGFuZ2VkIHx8IGJveFNpemluZ0NoYW5nZWQgfHwgcGFkZGluZ0Fic29sdXRlQ2hhbmdlZCB8fCBpZ25vcmVPdmVybGF5U2Nyb2xsYmFySGlkaW5nQ2hhbmdlZCB8fCBjc3NEaXJlY3Rpb25DaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlTGVuZ3RoKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldCh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVMZW5ndGgoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFuYWdlIGludGVyYWN0aXZpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZ0NoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0ludGVyYWN0aXZlKHRydWUsIHNjcm9sbGJhcnNDbGlja1Njcm9sbGluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NoYW5nZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0ludGVyYWN0aXZlKGZhbHNlLCBzY3JvbGxiYXJzRHJhZ1Njcm9sbGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGxiYWNrczpcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25EaXJlY3Rpb25DaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSVEw6IF9pc1JUTCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcjogY3NzRGlyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGNzc0RpcmVjdGlvbkNoYW5nZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvbkhvc3RTaXplQ2hhbmdlZCcsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBfaG9zdFNpemVDYWNoZS53LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBfaG9zdFNpemVDYWNoZS5oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIGhvc3RTaXplQ2hhbmdlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uQ29udGVudFNpemVDaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlLncsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IF9jb250ZW50U2Nyb2xsU2l6ZUNhY2hlLmhcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgY29udGVudFNpemVDaGFuZ2VkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25PdmVyZmxvd0NoYW5nZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBoYXNPdmVyZmxvdy54LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaGFzT3ZlcmZsb3cueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhTY3JvbGxhYmxlOiBoaWRlT3ZlcmZsb3cueHMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5U2Nyb2xsYWJsZTogaGlkZU92ZXJmbG93LnlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpcHBlZDogaGlkZU92ZXJmbG93LnggfHwgaGlkZU92ZXJmbG93LnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgaGFzT3ZlcmZsb3cuYyB8fCBoaWRlT3ZlcmZsb3cuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uT3ZlcmZsb3dBbW91bnRDaGFuZ2VkJywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogb3ZlcmZsb3dBbW91bnQueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG92ZXJmbG93QW1vdW50LnlcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgb3ZlcmZsb3dBbW91bnQuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2ZpeCBib2R5IG1pbiBzaXplXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkgJiYgX2JvZHlNaW5TaXplQ2FjaGUgJiYgKF9oYXNPdmVyZmxvd0NhY2hlLmMgfHwgX2JvZHlNaW5TaXplQ2FjaGUuYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9pdHMgcG9zc2libGUgdGhhdCBubyBtaW4gc2l6ZSB3YXMgbWVhc3VyZWQgdW50aWwgbm93LCBiZWNhdXNlIHRoZSBjb250ZW50IGFycmFuZ2UgZWxlbWVudCB3YXMganVzdCBhZGRlZCBub3csIGluIHRoaXMgY2FzZSwgbWVhc3VyZSBub3cgdGhlIG1pbiBzaXplLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9ib2R5TWluU2l6ZUNhY2hlLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5TWluU2l6ZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgJiYgX2hhc092ZXJmbG93Q2FjaGUueClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jc3MoX3N0ck1pbk1pbnVzICsgX3N0cldpZHRoLCBfYm9keU1pblNpemVDYWNoZS53ICsgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9oYXNPdmVyZmxvd0NhY2hlLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuY3NzKF9zdHJNaW5NaW51cyArIF9zdHJIZWlnaHQsIF9ib2R5TWluU2l6ZUNhY2hlLmggKyBfb3ZlcmxheVNjcm9sbGJhckR1bW15U2l6ZS54KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2JvZHlNaW5TaXplQ2FjaGUuYyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pbml0aWFsaXplZCAmJiBjaGFuZ2VkT3B0aW9ucy51cGRhdGVPbkxvYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRWxlbWVudHNPbkxvYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZnJlZXplUmVzaXplT2JzZXJ2ZXIoX3NpemVPYnNlcnZlckVsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2ZyZWV6ZVJlc2l6ZU9ic2VydmVyKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCwgZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvblVwZGF0ZWQnLCB7IGZvcmNlZDogZm9yY2UgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBmb3VuZCBlbGVtZW50cyBvZiB3aGljaCB0aGUgbG9hZCBldmVudCBzaGFsbCBiZSBoYW5kbGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50c09uTG9hZCgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIV9pc1RleHRhcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2hVcGRhdGVPbkxvYWQoZnVuY3Rpb24gKGksIHVwZGF0ZU9uTG9hZFNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGVudEVsZW1lbnQuZmluZCh1cGRhdGVPbkxvYWRTZWxlY3RvcikuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHVwZGF0ZU9uTG9hZENhbGxiYWNrIGFwcGxpZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pbkEoZWwsIF91cGRhdGVPbkxvYWRFbG1zKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZU9uTG9hZEVsbXMucHVzaChlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSyhlbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vZmYoX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSwgdXBkYXRlT25Mb2FkQ2FsbGJhY2spXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oX3VwZGF0ZU9uTG9hZEV2ZW50TmFtZSwgdXBkYXRlT25Mb2FkQ2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IE9wdGlvbnMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIG5ldyBvcHRpb25zIGJ1dCBkb2Vzbid0IGNhbGwgdGhlIHVwZGF0ZSBtZXRob2QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbmV3T3B0aW9ucyBUaGUgb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBuZXcgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBBIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgY2hhbmdlZCBvcHRpb25zLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRPcHRpb25zKG5ld09wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRhdGVkT3B0cyA9IF9wbHVnaW5zT3B0aW9ucy5fdmFsaWRhdGUobmV3T3B0aW9ucywgX3BsdWdpbnNPcHRpb25zLl90ZW1wbGF0ZSwgdHJ1ZSwgX2N1cnJlbnRPcHRpb25zKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBfY3VycmVudE9wdGlvbnMgPSBleHRlbmREZWVwKHt9LCBfY3VycmVudE9wdGlvbnMsIHZhbGlkYXRlZE9wdHMuX2RlZmF1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jdXJyZW50UHJlcGFyZWRPcHRpb25zID0gZXh0ZW5kRGVlcCh7fSwgX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMsIHZhbGlkYXRlZE9wdHMuX3ByZXBhcmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlZE9wdHMuX3ByZXBhcmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gU3RydWN0dXJlID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVpbGRzIG9yIGRlc3Ryb3lzIHRoZSB3cmFwcGVyIGFuZCBoZWxwZXIgRE9NIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERPTSBzaGFsbCBiZSBidWlsZCBvciBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVpbGRzIG9yIGRlc3Ryb3lzIHRoZSB3cmFwcGVyIGFuZCBoZWxwZXIgRE9NIGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGRlc3Ryb3kgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIERPTSBzaGFsbCBiZSBidWlsZCBvciBkZXN0cm95ZWQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU3RydWN0dXJlRE9NKGRlc3Ryb3kpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyUGFyZW50ID0gJ3BhcmVudCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZVJlc2l6ZU9ic2VydmVySG9zdCA9ICdvcy1yZXNpemUtb2JzZXJ2ZXItaG9zdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZVRleHRhcmVhRWxlbWVudEZ1bGwgPSBfY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50ICsgX3N0clNwYWNlICsgX2NsYXNzTmFtZVRleHRJbmhlcml0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUNsYXNzID0gX2lzVGV4dGFyZWEgPyBfc3RyU3BhY2UgKyBfY2xhc3NOYW1lVGV4dEluaGVyaXQgOiBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkb3B0QXR0cnMgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy50ZXh0YXJlYS5pbmhlcml0ZWRBdHRycztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRvcHRBdHRyc01hcCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcHBseUFkb3B0ZWRBdHRycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGx5QWRvcHRlZEF0dHJzRWxtID0gZGVzdHJveSA/IF90YXJnZXRFbGVtZW50IDogX2hvc3RFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlYWNoKGFkb3B0QXR0cnNNYXAsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSh2YWx1ZSkgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gTEVYSUNPTi5jKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUFkb3B0ZWRBdHRyc0VsbS5hZGRDbGFzcyh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBseUFkb3B0ZWRBdHRyc0VsbS5hdHRyKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0RWxlbWVudENsYXNzTmFtZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RFbGVtZW50Rm9yZWlnbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RUZXh0YXJlYUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0UmVzaXplRGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0UlRMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhckhvcml6b250YWxIaWRkZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0U2Nyb2xsYmFyVmVydGljYWxIaWRkZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0VHJhbnNpdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZUhvc3RTY3JvbGxpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3csXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc05hbWVIb3N0T3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lSG9zdE92ZXJmbG93WSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVRoZW1lTm9uZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVRleHRhcmVhRWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NsYXNzTmFtZVRleHRJbmhlcml0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NOYW1lQ2FjaGVdLmpvaW4oX3N0clNwYWNlKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEVsZW1lbnRDU1MgPSB7fTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgaG9zdCBlbGVtZW50IGFzIGZpcnN0IGVsZW1lbnQsIGJlY2F1c2UgdGhhdCdzIHRoZSBtb3N0IHVwcGVyIGVsZW1lbnQgYW5kIHJlcXVpcmVkIGZvciB0aGUgb3RoZXIgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQgPSBfaG9zdEVsZW1lbnQgfHwgKF9pc1RleHRhcmVhID8gKF9kb21FeGlzdHMgPyBfdGFyZ2V0RWxlbWVudFtzdHJQYXJlbnRdKClbc3RyUGFyZW50XSgpW3N0clBhcmVudF0oKVtzdHJQYXJlbnRdKCkgOiBGUkFNRVdPUksoZ2VuZXJhdGVEaXYoX2NsYXNzTmFtZUhvc3RUZXh0YXJlYUVsZW1lbnQpKSkgOiBfdGFyZ2V0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50ID0gX2NvbnRlbnRFbGVtZW50IHx8IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVDb250ZW50RWxlbWVudCArIHRleHRhcmVhQ2xhc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQgPSBfdmlld3BvcnRFbGVtZW50IHx8IHNlbGVjdE9yR2VuZXJhdGVEaXZCeUNsYXNzKF9jbGFzc05hbWVWaWV3cG9ydEVsZW1lbnQgKyB0ZXh0YXJlYUNsYXNzKTtcclxuICAgICAgICAgICAgICAgICAgICBfcGFkZGluZ0VsZW1lbnQgPSBfcGFkZGluZ0VsZW1lbnQgfHwgc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVBhZGRpbmdFbGVtZW50ICsgdGV4dGFyZWFDbGFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3NpemVPYnNlcnZlckVsZW1lbnQgPSBfc2l6ZU9ic2VydmVyRWxlbWVudCB8fCBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhjbGFzc05hbWVSZXNpemVPYnNlcnZlckhvc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUNvdmVyRWxlbWVudCA9IF90ZXh0YXJlYUNvdmVyRWxlbWVudCB8fCAoX2lzVGV4dGFyZWEgPyBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lVGV4dGFyZWFDb3ZlckVsZW1lbnQpIDogdW5kZWZpbmVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9hZGQgdGhpcyBjbGFzcyB0byB3b3JrYXJvdW5kIGNsYXNzIGNoYW5naW5nIGlzc3VlcyB3aXRoIFVJIGZyYW1ld29ya3MgZXNwZWNpYWxseSBWdWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdEVsZW1lbnRGb3JlaWduKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9vbiBkZXN0cm95LCByZW1vdmUgYWxsIGdlbmVyYXRlZCBjbGFzcyBuYW1lcyBmcm9tIHRoZSBob3N0IGVsZW1lbnQgYmVmb3JlIGNvbGxlY3RpbmcgdGhlIGFkb3B0ZWQgYXR0cmlidXRlcyBcclxuICAgICAgICAgICAgICAgICAgICAvL3RvIHByZXZlbnQgYWRvcHRpbmcgZ2VuZXJhdGVkIGNsYXNzIG5hbWVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ob3N0RWxlbWVudCwgaG9zdEVsZW1lbnRDbGFzc05hbWVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb2xsZWN0IGFsbCBhZG9wdGVkIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgICAgICBhZG9wdEF0dHJzID0gdHlwZShhZG9wdEF0dHJzKSA9PSBUWVBFUy5zID8gYWRvcHRBdHRycy5zcGxpdChfc3RyU3BhY2UpIDogYWRvcHRBdHRycztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EoYWRvcHRBdHRycykgJiYgX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChhZG9wdEF0dHJzLCBmdW5jdGlvbiAoaSwgdikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUodikgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkb3B0QXR0cnNNYXBbdl0gPSBkZXN0cm95ID8gX2hvc3RFbGVtZW50LmF0dHIodikgOiBfdGFyZ2V0RWxlbWVudC5hdHRyKHYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzVGV4dGFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMuc2l6ZUF1dG9DYXBhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdEVsZW1lbnRDU1NbX3N0cldpZHRoXSA9IF90YXJnZXRFbGVtZW50LmNzcyhfc3RyV2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gX3RhcmdldEVsZW1lbnQuY3NzKF9zdHJIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGFyZ2V0RWxlbWVudC5hZGRDbGFzcyhfY2xhc3NOYW1lVGV4dEluaGVyaXQpLndyYXAoX2hvc3RFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2pRdWVyeSBjbG9uZXMgZWxlbWVudHMgaW4gd3JhcCBmdW5jdGlvbnMsIHNvIHdlIGhhdmUgdG8gc2VsZWN0IHRoZW0gYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudCA9IF90YXJnZXRFbGVtZW50W3N0clBhcmVudF0oKS5jc3MoaG9zdEVsZW1lbnRDU1MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kb21FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYWRkIHRoZSBjb3JyZWN0IGNsYXNzIHRvIHRoZSB0YXJnZXQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3RhcmdldEVsZW1lbnQsIF9pc1RleHRhcmVhID8gY2xhc3NOYW1lVGV4dGFyZWFFbGVtZW50RnVsbCA6IF9jbGFzc05hbWVIb3N0RWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy93cmFwIHRoZSBjb250ZW50IGludG8gdGhlIGdlbmVyYXRlZCBlbGVtZW50cyB0byBjcmVhdGUgdGhlIHJlcXVpcmVkIERPTVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2hvc3RFbGVtZW50LndyYXBJbm5lcihfY29udGVudEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLndyYXBJbm5lcihfdmlld3BvcnRFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC53cmFwSW5uZXIoX3BhZGRpbmdFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wcmVwZW5kKF9zaXplT2JzZXJ2ZXJFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2pRdWVyeSBjbG9uZXMgZWxlbWVudHMgaW4gd3JhcCBmdW5jdGlvbnMsIHNvIHdlIGhhdmUgdG8gc2VsZWN0IHRoZW0gYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudCA9IGZpbmRGaXJzdChfaG9zdEVsZW1lbnQsIF9zdHJEb3QgKyBfY2xhc3NOYW1lQ29udGVudEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudCA9IGZpbmRGaXJzdChfaG9zdEVsZW1lbnQsIF9zdHJEb3QgKyBfY2xhc3NOYW1lVmlld3BvcnRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudCA9IGZpbmRGaXJzdChfaG9zdEVsZW1lbnQsIF9zdHJEb3QgKyBfY2xhc3NOYW1lUGFkZGluZ0VsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5wcmVwZW5kKF90ZXh0YXJlYUNvdmVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbHlBZG9wdGVkQXR0cnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3ZpZXdwb3J0RWxlbWVudCwgX2NsYXNzTmFtZVZpZXdwb3J0TmF0aXZlU2Nyb2xsYmFyc0ludmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfdmlld3BvcnRFbGVtZW50LCBfY2xhc3NOYW1lVmlld3BvcnROYXRpdmVTY3JvbGxiYXJzT3ZlcmxhaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzQm9keSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9odG1sRWxlbWVudCwgX2NsYXNzTmFtZUhUTUxFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zaXplT2JzZXJ2ZXJFbGVtZW50TmF0aXZlID0gX3NpemVPYnNlcnZlckVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudE5hdGl2ZSA9IF9ob3N0RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3BhZGRpbmdFbGVtZW50TmF0aXZlID0gX3BhZGRpbmdFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50TmF0aXZlID0gX3ZpZXdwb3J0RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRFbGVtZW50TmF0aXZlID0gX2NvbnRlbnRFbGVtZW50WzBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmlld3BvcnRBdHRyc0Zyb21UYXJnZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZG9tRXhpc3RzICYmIF9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jbGVhciBzaXplIG9ic2VydmVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2l6ZU9ic2VydmVyRWxlbWVudC5jaGlsZHJlbigpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoZSBzdHlsZSBwcm9wZXJ0eSBhbmQgY2xhc3NlcyBmcm9tIGFscmVhZHkgZ2VuZXJhdGVkIGVsZW1lbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYWNoKFtfcGFkZGluZ0VsZW1lbnQsIF92aWV3cG9ydEVsZW1lbnQsIF9jb250ZW50RWxlbWVudCwgX3RleHRhcmVhQ292ZXJFbGVtZW50XSwgZnVuY3Rpb24gKGksIGVsbSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoZWxtLnJlbW92ZUF0dHIoTEVYSUNPTi5zKSwgX2NsYXNzTmFtZXNEeW5hbWljRGVzdHJveSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGQgY2xhc3NlcyB0byB0aGUgaG9zdCBlbGVtZW50IHdoaWNoIHdhcyByZW1vdmVkIHByZXZpb3VzbHkgdG8gbWF0Y2ggdGhlIGV4cGVjdGVkIERPTVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfaXNUZXh0YXJlYSA/IF9jbGFzc05hbWVIb3N0VGV4dGFyZWFFbGVtZW50IDogX2NsYXNzTmFtZUhvc3RFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHNpemUgb2JzZXJ2ZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfc2l6ZU9ic2VydmVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy91bndyYXAgdGhlIGNvbnRlbnQgdG8gcmVzdG9yZSBET01cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50RWxlbWVudC5jb250ZW50cygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVud3JhcCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVud3JhcCgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnVud3JhcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LnVud3JhcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfaG9zdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfdGV4dGFyZWFDb3ZlckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGx5QWRvcHRlZEF0dHJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50LnJlbW92ZUF0dHIoTEVYSUNPTi5zKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNCb2R5KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2h0bWxFbGVtZW50LCBfY2xhc3NOYW1lSFRNTEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEFkZHMgb3IgcmVtb3ZlcyBhbGwgd3JhcHBlciBlbGVtZW50cyBpbnRlcmFjdGl2aXR5IGV2ZW50cy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBFdmVudHMgc2hhbGwgYmUgYWRkZWQgb3IgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTdHJ1Y3R1cmVFdmVudHMoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhS2V5RG93blJlc3RyaWN0ZWRLZXlDb2RlcyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgMTEyLCAxMTMsIDExNCwgMTE1LCAxMTYsIDExNywgMTE4LCAxMTksIDEyMCwgMTIxLCAxMjMsICAgIC8vRjEgdG8gRjEyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDMzLCAzNCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3BhZ2UgdXAsIHBhZ2UgZG93blxyXG4gICAgICAgICAgICAgICAgICAgICAgICAzNywgMzgsIDM5LCA0MCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9sZWZ0LCB1cCwgcmlnaHQsIGRvd24gYXJyb3dzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDE2LCAxNywgMTgsIDE5LCAyMCwgMTQ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NoaWZ0LCBDdHJsLCBBbHQsIFBhdXNlLCBDYXBzTG9jaywgTnVtTG9ja1xyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYVVwZGF0ZUludGVydmFsSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFN0b3BUaW1lb3V0SWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFN0b3BEZWxheSA9IDE3NTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyRm9jdXMgPSAnZm9jdXMnO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVUZXh0YXJlYShkb0NsZWFySW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFVcGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlKF9zdHJBdXRvKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvQ2xlYXJJbnRlcnZhbCAmJiBfYXV0b1VwZGF0ZVJlY29tbWVuZGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0ZXh0YXJlYVVwZGF0ZUludGVydmFsSUQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uU2Nyb2xsKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShfcnRsU2Nyb2xsQmVoYXZpb3IuaSAmJiBfbm9ybWFsaXplUlRMQ2FjaGUgPyA5OTk5OTk5IDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90YXJnZXRFbGVtZW50W19zdHJTY3JvbGxUb3BdKDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25Ecm9wKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRhcmVhKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdGV4dGFyZWFPbkZvY3VzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGV4dGFyZWFIYXNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKF9ob3N0RWxlbWVudCwgc3RyRm9jdXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0ZXh0YXJlYU9uRm9jdXNvdXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0YXJlYUhhc0ZvY3VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfaG9zdEVsZW1lbnQsIHN0ckZvY3VzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25LZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGtleUNvZGUsIHRleHRhcmVhS2V5RG93blJlc3RyaWN0ZWRLZXlDb2RlcykgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdFtMRVhJQ09OLmxdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYVVwZGF0ZUludGVydmFsSUQgPSBzZXRJbnRlcnZhbCh1cGRhdGVUZXh0YXJlYSwgMTAwMCAvIDYwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGtleUNvZGUsIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdCkgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRhcmVhS2V5RG93bktleUNvZGVzTGlzdC5wdXNoKGtleUNvZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHRleHRhcmVhT25LZXlVcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGluQXJyYXkoa2V5Q29kZSwgdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGtleUNvZGUsIHRleHRhcmVhS2V5RG93blJlc3RyaWN0ZWRLZXlDb2RlcykgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0YXJlYUtleURvd25LZXlDb2Rlc0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGV4dGFyZWFLZXlEb3duS2V5Q29kZXNMaXN0W0xFWElDT04ubF0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dGFyZWEodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY29udGVudE9uVHJhbnNpdGlvbkVuZChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2F1dG9VcGRhdGVDYWNoZSA9PT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50IHx8IGV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaXplQWZmZWN0aW5nQ1NTUHJvcGVydHkoZXZlbnQucHJvcGVydHlOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHZpZXdwb3J0T25TY3JvbGwoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxTdG9wVGltZW91dElkICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHNjcm9sbFN0b3BUaW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUodHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFNjcm9sbGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uU2Nyb2xsU3RhcnQnLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9pZiBhIHNjcm9sbGJhcnMgaGFuZGxlIGdldHMgZHJhZ2dlZCwgdGhlIG1vdXNlbW92ZSBldmVudCBpcyByZXNwb25zaWJsZSBmb3IgcmVmcmVzaGluZyB0aGUgaGFuZGxlIG9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iZWNhdXNlIGlmIENTUyBzY3JvbGwtc25hcCBpcyB1c2VkLCB0aGUgaGFuZGxlIG9mZnNldCBnZXRzIG9ubHkgcmVmcmVzaGVkIG9uIGV2ZXJ5IHNuYXAgcG9pbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBsb29rcyBsYWdneSAmIGNsdW5reSwgaXQgbG9va3MgbXVjaCBiZXR0ZXIgaWYgdGhlIG9mZnNldCByZWZyZXNoZXMgd2l0aCB0aGUgbW91c2Vtb3ZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvblNjcm9sbCcsIGV2ZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxTdG9wVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vT25TY3JvbGxTdG9wOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc2Nyb2xsU3RvcFRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFN0b3BUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVPdmVybGF5U2Nyb2xsYmFyc0FyZUFjdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFNjcm9sbGluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaENhbGxiYWNrKCdvblNjcm9sbFN0b3AnLCBldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2Nyb2xsU3RvcERlbGF5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfaXNUZXh0YXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX21zaWVWZXJzaW9uID4gOSB8fCAhX2F1dG9VcGRhdGVSZWNvbW1lbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3RhcmdldEVsZW1lbnQsICdpbnB1dCcsIHVwZGF0ZVRleHRhcmVhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKF90YXJnZXRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyS2V5RG93bkV2ZW50LCBfc3RyS2V5VXBFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3RleHRhcmVhT25LZXlEb3duLCB0ZXh0YXJlYU9uS2V5VXBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoX3RhcmdldEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0clNjcm9sbCwgJ2Ryb3AnLCBzdHJGb2N1cywgc3RyRm9jdXMgKyAnb3V0J10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdGV4dGFyZWFPblNjcm9sbCwgdGV4dGFyZWFPbkRyb3AsIHRleHRhcmVhT25Gb2N1cywgdGV4dGFyZWFPbkZvY3Vzb3V0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfY29udGVudEVsZW1lbnQsIF9zdHJUcmFuc2l0aW9uRW5kRXZlbnQsIGNvbnRlbnRPblRyYW5zaXRpb25FbmQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihfdmlld3BvcnRFbGVtZW50LCBfc3RyU2Nyb2xsLCB2aWV3cG9ydE9uU2Nyb2xsLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFNjcm9sbGJhcnMgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCdWlsZHMgb3IgZGVzdHJveXMgYWxsIHNjcm9sbGJhciBET00gZWxlbWVudHMgKHNjcm9sbGJhciwgdHJhY2ssIGhhbmRsZSlcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXN0cm95IEluZGljYXRlcyB3aGV0aGVyIHRoZSBET00gc2hhbGwgYmUgYnVpbGQgb3IgZGVzdHJveWVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXR1cFNjcm9sbGJhcnNET00oZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NID0gZnVuY3Rpb24gKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyQ2xhc3NOYW1lID0gaXNIb3Jpem9udGFsID8gX2NsYXNzTmFtZVNjcm9sbGJhckhvcml6b250YWwgOiBfY2xhc3NOYW1lU2Nyb2xsYmFyVmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXIgPSBzZWxlY3RPckdlbmVyYXRlRGl2QnlDbGFzcyhfY2xhc3NOYW1lU2Nyb2xsYmFyICsgX3N0clNwYWNlICsgc2Nyb2xsYmFyQ2xhc3NOYW1lLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVNjcm9sbGJhclRyYWNrLCBzY3JvbGxiYXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlID0gc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVNjcm9sbGJhckhhbmRsZSwgc2Nyb2xsYmFyKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2RvbUV4aXN0cyAmJiAhZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyLmFwcGVuZCh0cmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjay5hcHBlbmQoaGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXI6IHNjcm9sbGJhcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90cmFjazogdHJhY2ssXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaGFuZGxlOiBoYW5kbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlc2V0U2Nyb2xsYmFyRE9NKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbGJhciA9IHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrID0gc2Nyb2xsYmFyVmFycy5fdHJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzY3JvbGxiYXJWYXJzLl9oYW5kbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cyAmJiBfaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goW3Njcm9sbGJhciwgdHJhY2ssIGhhbmRsZV0sIGZ1bmN0aW9uIChpLCBlbG0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbG0ucmVtb3ZlQXR0cihMRVhJQ09OLnMpLCBfY2xhc3NOYW1lc0R5bmFtaWNEZXN0cm95KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKHNjcm9sbGJhciB8fCBzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NKGlzSG9yaXpvbnRhbCkuX3Njcm9sbGJhcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhvcml6b250YWxFbGVtZW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydGljYWxFbGVtZW50cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXN0cm95KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6b250YWxFbGVtZW50cyA9IHNlbGVjdE9yR2VuZXJhdGVTY3JvbGxiYXJET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsRWxlbWVudHMgPSBzZWxlY3RPckdlbmVyYXRlU2Nyb2xsYmFyRE9NKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQgPSBob3Jpem9udGFsRWxlbWVudHMuX3Njcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckhvcml6b250YWxUcmFja0VsZW1lbnQgPSBob3Jpem9udGFsRWxlbWVudHMuX3RyYWNrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQgPSBob3Jpem9udGFsRWxlbWVudHMuX2hhbmRsZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCA9IHZlcnRpY2FsRWxlbWVudHMuX3Njcm9sbGJhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhclZlcnRpY2FsVHJhY2tFbGVtZW50ID0gdmVydGljYWxFbGVtZW50cy5fdHJhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJWZXJ0aWNhbEhhbmRsZUVsZW1lbnQgPSB2ZXJ0aWNhbEVsZW1lbnRzLl9oYW5kbGU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kb21FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5hZnRlcihfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYWRkaW5nRWxlbWVudC5hZnRlcihfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFNjcm9sbGJhckRPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRTY3JvbGxiYXJET00oKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhbGwgc2Nyb2xsYmFyIGludGVyYWN0aXZpdHkgZXZlbnRzLiAodHJhY2sgYW5kIGhhbmRsZSBkcmFnZ2luZywgY2xpY2tpbmcsIHNjcm9sbGluZylcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpc0hvcml6b250YWwgVHJ1ZSBpZiB0aGUgdGFyZ2V0IHNjcm9sbGJhciBpcyB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXIsIGZhbHNlIGlmIHRoZSB0YXJnZXQgc2Nyb2xsYmFyIGlzIHRoZSB2ZXJ0aWNhbCBzY3JvbGxiYXIuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU2Nyb2xsYmFyRXZlbnRzKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzID0gZ2V0U2Nyb2xsYmFyVmFycyhpc0hvcml6b250YWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJWYXJzSW5mbyA9IHNjcm9sbGJhclZhcnMuX2luZm87XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc2lkZUlGcmFtZSA9IF93aW5kb3dFbGVtZW50TmF0aXZlLnRvcCAhPT0gX3dpbmRvd0VsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHh5ID0gc2Nyb2xsYmFyVmFycy5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBYWSA9IHNjcm9sbGJhclZhcnMuX1hfWTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gX3N0clNjcm9sbCArIHNjcm9sbGJhclZhcnMuX0xlZnRfVG9wO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJBY3RpdmUgPSAnYWN0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyU25hcEhhbmRsZSA9ICdzbmFwSGFuZGxlJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQ2xpY2tFdmVudCA9ICdjbGljayc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbER1cmF0aW9uRmFjdG9yID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5jcmVhc2VEZWNyZWFzZVNjcm9sbEFtb3VudEtleUNvZGVzID0gWzE2LCAxN107IC8vc2hpZnQsIGN0cmxcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tUaW1lb3V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25TY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93bk9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfbXNpZVZlcnNpb24gJiYgaW5zaWRlSUZyYW1lID8gZXZlbnRbJ3NjcmVlbicgKyBYWV0gOiBDT01QQVRJQklMSVRZLnBhZ2UoZXZlbnQpW3h5XTsgLy91c2Ugc2NyZWVuIGNvb3JkaW5hdGVzIGluIEVER0UgJiBJRSBiZWNhdXNlIHRoZSBwYWdlIHZhbHVlcyBhcmUgaW5jb3JyZWN0IGluIGZyYW1lcy5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UHJlcGFyZWRTY3JvbGxiYXJzT3B0aW9uKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50UHJlcGFyZWRPcHRpb25zLnNjcm9sbGJhcnNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGluY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbER1cmF0aW9uRmFjdG9yID0gMC41O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBkZWNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEdXJhdGlvbkZhY3RvciA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHN0b3BDbGlja0V2ZW50UHJvcGFnYXRpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRLZXlEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbkFycmF5KGV2ZW50LmtleUNvZGUsIGluY3JlYXNlRGVjcmVhc2VTY3JvbGxBbW91bnRLZXlDb2RlcykgPiAtMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRLZXlVcChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5BcnJheShldmVudC5rZXlDb2RlLCBpbmNyZWFzZURlY3JlYXNlU2Nyb2xsQW1vdW50S2V5Q29kZXMpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uTW91c2VUb3VjaERvd25Db250aW51ZShldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1RvdWNoRXZlbnQgPSBvcmlnaW5hbEV2ZW50LnRvdWNoZXMgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zbGVlcGluZyB8fCBfZGVzdHJveWVkIHx8IG5hdGl2ZU92ZXJsYXlTY3JvbGxiYXJzQXJlQWN0aXZlKCkgfHwgIV9zY3JvbGxiYXJzRHJhZ1Njcm9sbGluZ0NhY2hlIHx8IChpc1RvdWNoRXZlbnQgJiYgIWdldFByZXBhcmVkU2Nyb2xsYmFyc09wdGlvbigndG91Y2hTdXBwb3J0JykpID8gZmFsc2UgOiBDT01QQVRJQklMSVRZLm1CdG4oZXZlbnQpID09PSAxIHx8IGlzVG91Y2hFdmVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnREcmFnTW92ZShldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWNrTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX3RyYWNrTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZUxlbmd0aCA9IHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUmFuZ2UgPSBzY3JvbGxiYXJWYXJzSW5mby5fbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFJhdyA9IChnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQpIC0gbW91c2VEb3duT2Zmc2V0KSAqIG1vdXNlRG93bkludmVydGVkU2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRGVsdGFQZXJjZW50ID0gc2Nyb2xsUmF3IC8gKHRyYWNrTGVuZ3RoIC0gaGFuZGxlTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEZWx0YSA9IChzY3JvbGxSYW5nZSAqIHNjcm9sbERlbHRhUGVyY2VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YSA9IGlzRmluaXRlKHNjcm9sbERlbHRhKSA/IHNjcm9sbERlbHRhIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfaXNSVEwgJiYgaXNIb3Jpem9udGFsICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IuaSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxEZWx0YSAqPSAtMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W3Njcm9sbF0oTUFUSC5yb3VuZChtb3VzZURvd25TY3JvbGwgKyBzY3JvbGxEZWx0YSkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwsIG1vdXNlRG93blNjcm9sbCArIHNjcm9sbERlbHRhKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9zdXBwb3J0UGFzc2l2ZUV2ZW50cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50TW91c2VUb3VjaFVwKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRNb3VzZVRvdWNoVXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCBldmVudC5vcmlnaW5hbEV2ZW50O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LCBfc3RyTW91c2VUb3VjaFVwRXZlbnQsIF9zdHJLZXlEb3duRXZlbnQsIF9zdHJLZXlVcEV2ZW50LCBfc3RyU2VsZWN0U3RhcnRFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnREcmFnTW92ZSwgZG9jdW1lbnRNb3VzZVRvdWNoVXAsIGRvY3VtZW50S2V5RG93biwgZG9jdW1lbnRLZXlVcCwgZG9jdW1lbnRPblNlbGVjdFN0YXJ0XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnJBRigpKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LCBzdHJDbGlja0V2ZW50LCBzdG9wQ2xpY2tFdmVudFByb3BhZ2F0aW9uLCB0cnVlLCB7IF9jYXB0dXJlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjcm9sbGJhclZhcnMuX2hhbmRsZSwgc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3Moc2Nyb2xsYmFyVmFycy5fdHJhY2ssIHN0ckFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhciwgc3RyQWN0aXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNjcm9sbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duT2Zmc2V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25JbnZlcnRlZFNjYWxlID0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY3JlYXNlVHJhY2tTY3JvbGxBbW91bnQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFja1RpbWVvdXQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsU3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYWNrVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1RpbWVvdXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5iQ1JdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbW91c2VJbnNpZGVIb3N0ID0gZXZlbnQuY2xpZW50WCA+PSByZWN0LmxlZnQgJiYgZXZlbnQuY2xpZW50WCA8PSByZWN0LnJpZ2h0ICYmIGV2ZW50LmNsaWVudFkgPj0gcmVjdC50b3AgJiYgZXZlbnQuY2xpZW50WSA8PSByZWN0LmJvdHRvbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2lmIG1vdXNlIGlzIG91dHNpZGUgaG9zdCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdXNlSW5zaWRlSG9zdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0T25Nb3VzZUxlYXZlKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhcnNBdXRvSGlkZShmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25IYW5kbGVNb3VzZVRvdWNoRG93bihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uSGFuZGxlTW91c2VUb3VjaERvd25BY3Rpb24oZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvbkhhbmRsZU1vdXNlVG91Y2hEb3duQWN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNjcm9sbCA9IF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TY3JvbGwgPSBpc05hTihtb3VzZURvd25TY3JvbGwpID8gMCA6IG1vdXNlRG93blNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9pc1JUTCAmJiBpc0hvcml6b250YWwgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5uIHx8ICFfaXNSVEwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TY3JvbGwgPSBtb3VzZURvd25TY3JvbGwgPCAwID8gMCA6IG1vdXNlRG93blNjcm9sbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bkludmVydGVkU2NhbGUgPSBnZXRIb3N0RWxlbWVudEludmVydGVkU2NhbGUoKVt4eV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bk9mZnNldCA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0hhbmRsZXNEZWZpbmVTY3JvbGxQb3MgPSAhZ2V0UHJlcGFyZWRTY3JvbGxiYXJzT3B0aW9uKHN0clNuYXBIYW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjcm9sbGJhclZhcnMuX2hhbmRsZSwgc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3Moc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLCBzdHJBY3RpdmUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LCBfc3RyTW91c2VUb3VjaFVwRXZlbnQsIF9zdHJTZWxlY3RTdGFydEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudERyYWdNb3ZlLCBkb2N1bWVudE1vdXNlVG91Y2hVcCwgZG9jdW1lbnRPblNlbGVjdFN0YXJ0XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuckFGKCkoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsIHN0ckNsaWNrRXZlbnQsIHN0b3BDbGlja0V2ZW50UHJvcGFnYXRpb24sIGZhbHNlLCB7IF9jYXB0dXJlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX21zaWVWZXJzaW9uIHx8ICFfZG9jdW1lbnRNaXhlZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG9uVHJhY2tNb3VzZVRvdWNoRG93bihldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZVRvVmlld3BvcnRSYXRpbyA9IHNjcm9sbGJhclZhcnMuX2luZm8uX2hhbmRsZUxlbmd0aCAvIE1hdGgucm91bmQoTUFUSC5taW4oMSwgX3ZpZXdwb3J0U2l6ZVtzY3JvbGxiYXJWYXJzLl93X2hdIC8gX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGVbc2Nyb2xsYmFyVmFycy5fd19oXSkgKiBzY3JvbGxiYXJWYXJzLl9pbmZvLl90cmFja0xlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRGlzdGFuY2UgPSBNQVRILnJvdW5kKF92aWV3cG9ydFNpemVbc2Nyb2xsYmFyVmFycy5fd19oXSAqIGhhbmRsZVRvVmlld3BvcnRSYXRpbyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsQmFzZUR1cmF0aW9uID0gMjcwICogaGFuZGxlVG9WaWV3cG9ydFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEZpcnN0SXRlcmF0aW9uRGVsYXkgPSA0MDAgKiBoYW5kbGVUb1ZpZXdwb3J0UmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tPZmZzZXQgPSBzY3JvbGxiYXJWYXJzLl90cmFjay5vZmZzZXQoKVtzY3JvbGxiYXJWYXJzLl9sZWZ0X3RvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3RybEtleSA9IGV2ZW50LmN0cmxLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudFNjcm9sbCA9IGV2ZW50LnNoaWZ0S2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbnRTY3JvbGxUcmFuc2l0aW9uID0gaW5zdGFudFNjcm9sbCAmJiBjdHJsS2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzRmlyc3RJdGVyYXRpb24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVhc2luZyA9ICdsaW5lYXInO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlYXNlU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmlzaGVkQ29uZGl0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEFjdGlvbkZpbnNpc2hlZCA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFNjcm9sbGJhckhhbmRsZU9mZnNldChpc0hvcml6b250YWwsIHRyYW5zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxBY3Rpb25JbnN0YW50RmluaXNoZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQWN0aW9uRmluc2lzaGVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25IYW5kbGVNb3VzZVRvdWNoRG93bkFjdGlvbihldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbEFjdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlT2Zmc2V0ID0gKG1vdXNlRG93bk9mZnNldCAtIHRyYWNrT2Zmc2V0KSAqIG1vdXNlRG93bkludmVydGVkU2NhbGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVPZmZzZXQgPSBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tMZW5ndGggPSBzY3JvbGxiYXJWYXJzSW5mby5fdHJhY2tMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVMZW5ndGggPSBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsUmFuZ2UgPSBzY3JvbGxiYXJWYXJzSW5mby5fbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclNjcm9sbCA9IHNjcm9sbGJhclZhcnNJbmZvLl9jdXJyZW50U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsRHVyYXRpb24gPSBzY3JvbGxCYXNlRHVyYXRpb24gKiBzY3JvbGxEdXJhdGlvbkZhY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXREZWxheSA9IGlzRmlyc3RJdGVyYXRpb24gPyBNQVRILm1heChzY3JvbGxGaXJzdEl0ZXJhdGlvbkRlbGF5LCBzY3JvbGxEdXJhdGlvbikgOiBzY3JvbGxEdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IHNjcm9sbFJhbmdlICogKChtb3VzZU9mZnNldCAtIChoYW5kbGVMZW5ndGggLyAyKSkgLyAodHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGgpKTsgLy8gMTAwJSAqIHBvc2l0aW9uUGVyY2VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnRsSXNOb3JtYWwgPSBfaXNSVEwgJiYgaXNIb3Jpem9udGFsICYmICgoIV9ydGxTY3JvbGxCZWhhdmlvci5pICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IubikgfHwgX25vcm1hbGl6ZVJUTENhY2hlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlY3JlYXNlU2Nyb2xsQ29uZGl0aW9uID0gcnRsSXNOb3JtYWwgPyBoYW5kbGVPZmZzZXQgPCBtb3VzZU9mZnNldCA6IGhhbmRsZU9mZnNldCA+IG1vdXNlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsT2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25PYmogPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlYXNpbmc6IGVhc2luZyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IGZ1bmN0aW9uIChub3cpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNIYW5kbGVzRGVmaW5lU2Nyb2xsUG9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXShub3cpOyAvL2h0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2lzc3Vlcy80MzQwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCBub3cpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gaXNGaW5pdGUoaW5zdGFudFNjcm9sbFBvc2l0aW9uKSA/IGluc3RhbnRTY3JvbGxQb3NpdGlvbiA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IF9pc1JUTCAmJiBpc0hvcml6b250YWwgJiYgIV9ydGxTY3JvbGxCZWhhdmlvci5pID8gKHNjcm9sbFJhbmdlIC0gaW5zdGFudFNjcm9sbFBvc2l0aW9uKSA6IGluc3RhbnRTY3JvbGxQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vX2Jhc2Uuc2Nyb2xsU3RvcCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbnRTY3JvbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXShpbnN0YW50U2Nyb2xsUG9zaXRpb24pOyAvL3Njcm9sbCBpbnN0YW50bHkgdG8gbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFudFNjcm9sbFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2dldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGFmdGVyIGluc3RhbnQgc2Nyb2xsIChpbiBjYXNlIENTUyBTbmFwIFBvaW50cyBhcmUgdXNlZCkgdG8gZ2V0IHRoZSBjb3JyZWN0IHNuYXBwZWQgc2Nyb2xsIHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9hbmQgdGhlIGFuaW1hdGlvbiBzdG9wcyBhdCB0aGUgY29ycmVjdCBwb2ludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc2Nyb2xsIGJhY2sgdG8gdGhlIHBvc2l0aW9uIGJlZm9yZSBpbnN0YW50IHNjcm9sbGluZyBzbyBhbmltYXRpb24gY2FuIGJlIHBlcmZvcm1lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbc2Nyb2xsXShjdXJyU2Nyb2xsKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudFNjcm9sbFBvc2l0aW9uID0gcnRsSXNOb3JtYWwgJiYgX3J0bFNjcm9sbEJlaGF2aW9yLmkgPyAoc2Nyb2xsUmFuZ2UgLSBpbnN0YW50U2Nyb2xsUG9zaXRpb24pIDogaW5zdGFudFNjcm9sbFBvc2l0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRTY3JvbGxQb3NpdGlvbiA9IHJ0bElzTm9ybWFsICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uID8gLWluc3RhbnRTY3JvbGxQb3NpdGlvbiA6IGluc3RhbnRTY3JvbGxQb3NpdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsT2JqW3h5XSA9IGluc3RhbnRTY3JvbGxQb3NpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS5zY3JvbGwoc2Nyb2xsT2JqLCBleHRlbmREZWVwKGFuaW1hdGlvbk9iaiwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTMwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogc2Nyb2xsQWN0aW9uSW5zdGFudEZpbmlzaGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbEFjdGlvbkluc3RhbnRGaW5pc2hlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVhc2VTY3JvbGwgPSBpc0ZpcnN0SXRlcmF0aW9uID8gZGVjcmVhc2VTY3JvbGxDb25kaXRpb24gOiBkZWNyZWFzZVNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkQ29uZGl0aW9uID0gcnRsSXNOb3JtYWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChkZWNyZWFzZVNjcm9sbCA/IGhhbmRsZU9mZnNldCArIGhhbmRsZUxlbmd0aCA+PSBtb3VzZU9mZnNldCA6IGhhbmRsZU9mZnNldCA8PSBtb3VzZU9mZnNldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChkZWNyZWFzZVNjcm9sbCA/IGhhbmRsZU9mZnNldCA8PSBtb3VzZU9mZnNldCA6IGhhbmRsZU9mZnNldCArIGhhbmRsZUxlbmd0aCA+PSBtb3VzZU9mZnNldCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkQ29uZGl0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYWNrVGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2Uuc2Nyb2xsU3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrVGltZW91dCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxBY3Rpb25GaW5zaXNoZWQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KHNjcm9sbEFjdGlvbiwgdGltZW91dERlbGF5KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsT2JqW3h5XSA9IChkZWNyZWFzZVNjcm9sbCA/ICctPScgOiAnKz0nKSArIHNjcm9sbERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9iYXNlLnNjcm9sbChzY3JvbGxPYmosIGV4dGVuZERlZXAoYW5pbWF0aW9uT2JqLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBzY3JvbGxEdXJhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmlyc3RJdGVyYXRpb24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3RybEtleSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNyZWFzZVRyYWNrU2Nyb2xsQW1vdW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZSA9IGdldEhvc3RFbGVtZW50SW52ZXJ0ZWRTY2FsZSgpW3h5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93bk9mZnNldCA9IENPTVBBVElCSUxJVFkucGFnZShldmVudClbeHldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlc0RlZmluZVNjcm9sbFBvcyA9ICFnZXRQcmVwYXJlZFNjcm9sbGJhcnNPcHRpb24oc3RyU25hcEhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhfYm9keUVsZW1lbnQsIF9jbGFzc05hbWVEcmFnZ2luZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRDbGFzcyhzY3JvbGxiYXJWYXJzLl90cmFjaywgc3RyQWN0aXZlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzKHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhciwgc3RyQWN0aXZlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc3BvbnNpdmVFdmVudExpc3RlbmVyKF9kb2N1bWVudEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoVXBFdmVudCwgX3N0cktleURvd25FdmVudCwgX3N0cktleVVwRXZlbnQsIF9zdHJTZWxlY3RTdGFydEV2ZW50XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnRNb3VzZVRvdWNoVXAsIGRvY3VtZW50S2V5RG93biwgZG9jdW1lbnRLZXlVcCwgZG9jdW1lbnRPblNlbGVjdFN0YXJ0XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsQWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnBydkQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ09NUEFUSUJJTElUWS5zdHBQKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblRyYWNrTW91c2VUb3VjaEVudGVyKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vbWFrZSBzdXJlIGJvdGggc2Nyb2xsYmFycyB3aWxsIHN0YXkgdmlzaWJsZSBpZiBvbmUgc2Nyb2xsYmFyIGlzIGhvdmVyZWQgaWYgYXV0b0hpZGUgaXMgXCJzY3JvbGxcIiBvciBcIm1vdmVcIi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhcnNIYW5kbGVIb3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblRyYWNrTW91c2VUb3VjaExlYXZlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJzSGFuZGxlSG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZVNjcm9sbCB8fCBfc2Nyb2xsYmFyc0F1dG9IaWRlTW92ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZnJlc2hTY3JvbGxiYXJzQXV0b0hpZGUoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBvblNjcm9sbGJhck1vdXNlVG91Y2hEb3duKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihzY3JvbGxiYXJWYXJzLl9oYW5kbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdHJNb3VzZVRvdWNoRG93bkV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkhhbmRsZU1vdXNlVG91Y2hEb3duKTtcclxuICAgICAgICAgICAgICAgICAgICBhZGREZXN0cm95RXZlbnRMaXN0ZW5lcihzY3JvbGxiYXJWYXJzLl90cmFjayxcclxuICAgICAgICAgICAgICAgICAgICAgICAgW19zdHJNb3VzZVRvdWNoRG93bkV2ZW50LCBfc3RyTW91c2VFbnRlciwgX3N0ck1vdXNlTGVhdmVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBbb25UcmFja01vdXNlVG91Y2hEb3duLCBvblRyYWNrTW91c2VUb3VjaEVudGVyLCBvblRyYWNrTW91c2VUb3VjaExlYXZlXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RyTW91c2VUb3VjaERvd25FdmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25TY3JvbGxiYXJNb3VzZVRvdWNoRG93bik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3VwcG9ydFRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVzdHJveUV2ZW50TGlzdGVuZXIoc2Nyb2xsYmFyVmFycy5fc2Nyb2xsYmFyLCBfc3RyVHJhbnNpdGlvbkVuZEV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IHNjcm9sbGJhclZhcnMuX3Njcm9sbGJhclswXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlTGVuZ3RoKGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGlzSG9yaXpvbnRhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNob3dzIG9yIGhpZGVzIHRoZSBnaXZlbiBzY3JvbGxiYXIgYW5kIGFwcGxpZWQgYSBjbGFzcyBuYW1lIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgc2Nyb2xsYmFyIGlzIHNjcm9sbGFibGUgb3Igbm90LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGlzSG9yaXpvbnRhbCBUcnVlIGlmIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciBpcyB0aGUgdGFyZ2V0LCBmYWxzZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIHRoZSB0YXJnZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2hhbGxCZVZpc2libGUgVHJ1ZSBpZiB0aGUgc2Nyb2xsYmFyIHNoYWxsIGJlIHNob3duLCBmYWxzZSBpZiBoaWRkZW4uXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY2FuU2Nyb2xsIFRydWUgaWYgdGhlIHNjcm9sbGJhciBpcyBzY3JvbGxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hTY3JvbGxiYXJBcHBlYXJhbmNlKGlzSG9yaXpvbnRhbCwgc2hhbGxCZVZpc2libGUsIGNhblNjcm9sbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJIaWRkZW5DbGFzc05hbWUgPSBpc0hvcml6b250YWwgPyBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhckhvcml6b250YWxIaWRkZW4gOiBfY2xhc3NOYW1lSG9zdFNjcm9sbGJhclZlcnRpY2FsSGlkZGVuO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxiYXJFbGVtZW50ID0gaXNIb3Jpem9udGFsID8gX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50IDogX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3MoX2hvc3RFbGVtZW50LCBzY3JvbGxiYXJIaWRkZW5DbGFzc05hbWUsICFzaGFsbEJlVmlzaWJsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkUmVtb3ZlQ2xhc3Moc2Nyb2xsYmFyRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhclVudXNhYmxlLCAhY2FuU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEF1dG9zaG93cyAvIGF1dG9oaWRlcyBib3RoIHNjcm9sbGJhcnMgd2l0aC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzaGFsbEJlVmlzaWJsZSBUcnVlIGlmIHRoZSBzY3JvbGxiYXJzIHNoYWxsIGJlIGF1dG9zaG93biAob25seSB0aGUgY2FzZSBpZiB0aGV5IGFyZSBoaWRkZW4gYnkgYSBhdXRvaGlkZSksIGZhbHNlIGlmIHRoZSBzaGFsbCBiZSBhdXRvIGhpZGRlbi5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZWxheWZyZWUgVHJ1ZSBpZiB0aGUgc2Nyb2xsYmFycyBzaGFsbCBiZSBoaWRkZW4gd2l0aG91dCBhIGRlbGF5LCBmYWxzZSBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsYmFyc0F1dG9IaWRlKHNoYWxsQmVWaXNpYmxlLCBkZWxheWZyZWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3Njcm9sbGJhcnNBdXRvSGlkZVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNoYWxsQmVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaWYoX2hhc092ZXJmbG93Q2FjaGUueCAmJiBfaGlkZU92ZXJmbG93Q2FjaGUueHMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2lmKF9oYXNPdmVyZmxvd0NhY2hlLnkgJiYgX2hpZGVPdmVyZmxvd0NhY2hlLnlzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW55QWN0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQWN0aXZlID0gJ2FjdGl2ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfc2Nyb2xsYmFyc0hhbmRsZUhvdmVyZWQgJiYgIV9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbnlBY3RpdmUgPSBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQuaGFzQ2xhc3Moc3RyQWN0aXZlKSB8fCBfc2Nyb2xsYmFyVmVydGljYWxIYW5kbGVFbGVtZW50Lmhhc0NsYXNzKHN0ckFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlBY3RpdmUgJiYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3Njcm9sbGJhckhvcml6b250YWxFbGVtZW50LCBfY2xhc3NOYW1lU2Nyb2xsYmFyQXV0b0hpZGRlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlBY3RpdmUgJiYgKF9zY3JvbGxiYXJzQXV0b0hpZGVTY3JvbGwgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZU1vdmUgfHwgX3Njcm9sbGJhcnNBdXRvSGlkZUxlYXZlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX3Njcm9sbGJhclZlcnRpY2FsRWxlbWVudCwgX2NsYXNzTmFtZVNjcm9sbGJhckF1dG9IaWRkZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Njcm9sbGJhcnNBdXRvSGlkZURlbGF5ID4gMCAmJiBkZWxheWZyZWUgIT09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc2Nyb2xsYmFyc0F1dG9IaWRlVGltZW91dElkID0gc2V0VGltZW91dChoaWRlLCBfc2Nyb2xsYmFyc0F1dG9IaWRlRGVsYXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmcmVzaGVzIHRoZSBoYW5kbGUgbGVuZ3RoIG9mIHRoZSBnaXZlbiBzY3JvbGxiYXIuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNIb3Jpem9udGFsIFRydWUgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIGhhbmRsZSBzaGFsbCBiZSByZWZyZXNoZWQsIGZhbHNlIGlmIHRoZSB2ZXJ0aWNhbCBvbmUgc2hhbGwgYmUgcmVmcmVzaGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiByZWZyZXNoU2Nyb2xsYmFySGFuZGxlTGVuZ3RoKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0luZm8gPSBzY3JvbGxiYXJWYXJzLl9pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWdpdCA9IDEwMDAwMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nZXQgYW5kIGFwcGx5IGludGVuZGVkIGhhbmRsZSBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlUmF0aW8gPSBNQVRILm1pbigxLCBfdmlld3BvcnRTaXplW3Njcm9sbGJhclZhcnMuX3dfaF0gLyBfY29udGVudFNjcm9sbFNpemVDYWNoZVtzY3JvbGxiYXJWYXJzLl93X2hdKTtcclxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDU1Nbc2Nyb2xsYmFyVmFycy5fd2lkdGhfaGVpZ2h0XSA9IChNQVRILmZsb29yKGhhbmRsZVJhdGlvICogMTAwICogZGlnaXQpIC8gZGlnaXQpICsgJyUnOyAvL3RoZSBsYXN0ICogZGlnaXQgLyBkaWdpdCBpcyBmb3IgZmxvb3JpbmcgdG8gdGhlIDR0aCBkaWdpdFxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdGl2ZU92ZXJsYXlTY3JvbGxiYXJzQXJlQWN0aXZlKCkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnMuX2hhbmRsZS5jc3MoaGFuZGxlQ1NTKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9tZWFzdXJlIHRoZSBoYW5kbGUgbGVuZ3RoIHRvIHJlc3BlY3QgbWluICYgbWF4IGxlbmd0aFxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVMZW5ndGggPSBzY3JvbGxiYXJWYXJzLl9oYW5kbGVbMF1bJ29mZnNldCcgKyBzY3JvbGxiYXJWYXJzLl9XaWR0aF9IZWlnaHRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9oYW5kbGVMZW5ndGhSYXRpbyA9IGhhbmRsZVJhdGlvO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmVmcmVzaGVzIHRoZSBoYW5kbGUgb2Zmc2V0IG9mIHRoZSBnaXZlbiBzY3JvbGxiYXIuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNIb3Jpem9udGFsIFRydWUgaWYgdGhlIGhvcml6b250YWwgc2Nyb2xsYmFyIGhhbmRsZSBzaGFsbCBiZSByZWZyZXNoZWQsIGZhbHNlIGlmIHRoZSB2ZXJ0aWNhbCBvbmUgc2hhbGwgYmUgcmVmcmVzaGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHNjcm9sbE9yVHJhbnNpdGlvbiBUaGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBnaXZlbiBzY3JvbGxiYXIgYXhpcyB0byB3aGljaCB0aGUgaGFuZGxlIHNoYWxsIGJlIG1vdmVkIG9yIGEgYm9vbGVhbiB3aGljaCBpbmRpY2F0ZXMgd2hldGhlciBhIHRyYW5zaXRpb24gc2hhbGwgYmUgYXBwbGllZC4gSWYgdW5kZWZpbmVkIG9yIGJvb2xlYW4gaWYgdGhlIGN1cnJlbnQgc2Nyb2xsLW9mZnNldCBpcyB0YWtlbi4gKGlmIGlzSG9yaXpvbnRhbCA/IHNjcm9sbExlZnQgOiBzY3JvbGxUb3ApXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hTY3JvbGxiYXJIYW5kbGVPZmZzZXQoaXNIb3Jpem9udGFsLCBzY3JvbGxPclRyYW5zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHR5cGUoc2Nyb2xsT3JUcmFuc2l0aW9uKSA9PSBUWVBFUy5iO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSAyNTA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUlRMaXNIb3Jpem9udGFsID0gX2lzUlRMICYmIGlzSG9yaXpvbnRhbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFycyA9IGdldFNjcm9sbGJhclZhcnMoaXNIb3Jpem9udGFsKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsYmFyVmFyc0luZm8gPSBzY3JvbGxiYXJWYXJzLl9pbmZvO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJUcmFuc2xhdGVCcmFjZSA9ICd0cmFuc2xhdGUoJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyVHJhbnNmb3JtID0gVkVORE9SUy5fY3NzUHJvcGVydHkoJ3RyYW5zZm9ybScpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJUcmFuc2l0aW9uID0gVkVORE9SUy5fY3NzUHJvcGVydHkoJ3RyYW5zaXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbmF0aXZlU2Nyb2xsID0gaXNIb3Jpem9udGFsID8gX3ZpZXdwb3J0RWxlbWVudFtfc3RyU2Nyb2xsTGVmdF0oKSA6IF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbFRvcF0oKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFNjcm9sbCA9IHNjcm9sbE9yVHJhbnNpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IHRyYW5zaXRpb24gPyBuYXRpdmVTY3JvbGwgOiBzY3JvbGxPclRyYW5zaXRpb247XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vbWVhc3VyZSB0aGUgaGFuZGxlIGxlbmd0aCB0byByZXNwZWN0IG1pbiAmIG1heCBsZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlTGVuZ3RoID0gc2Nyb2xsYmFyVmFyc0luZm8uX2hhbmRsZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhY2tMZW5ndGggPSBzY3JvbGxiYXJWYXJzLl90cmFja1swXVsnb2Zmc2V0JyArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhbmRsZVRyYWNrRGlmZiA9IHRyYWNrTGVuZ3RoIC0gaGFuZGxlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGVWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9ET05UIHVzZSB0aGUgdmFyaWFibGUgJ19jb250ZW50U2Nyb2xsU2l6ZUNhY2hlW3Njcm9sbGJhclZhcnMuX3dfaF0nIGluc3RlYWQgb2YgJ192aWV3cG9ydEVsZW1lbnRbMF1bJ3Njcm9sbCcgKyBzY3JvbGxiYXJWYXJzLl9XaWR0aF9IZWlnaHRdJ1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGEgYml0IGJlaGluZCBkdXJpbmcgdGhlIHNtYWxsIGRlbGF5IHdoZW4gY29udGVudCBzaXplIHVwZGF0ZXNcclxuICAgICAgICAgICAgICAgICAgICAvLyhkZWxheSA9IG11dGF0aW9uT2JzZXJ2ZXJDb250ZW50TGFnLCBpZiBpdHMgMCB0aGVuIHRoaXMgdmFyIGNvdWxkIGJlIHVzZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heFNjcm9sbCA9IChfdmlld3BvcnRFbGVtZW50TmF0aXZlW19zdHJTY3JvbGwgKyBzY3JvbGxiYXJWYXJzLl9XaWR0aF9IZWlnaHRdIC0gX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZVsnY2xpZW50JyArIHNjcm9sbGJhclZhcnMuX1dpZHRoX0hlaWdodF0pICogKF9ydGxTY3JvbGxCZWhhdmlvci5uICYmIGlzUlRMaXNIb3Jpem9udGFsID8gLTEgOiAxKTsgLy8qIC0xIGlmIHJ0bCBzY3JvbGwgbWF4IGlzIG5lZ2F0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdldFNjcm9sbFJhdGlvID0gZnVuY3Rpb24gKGJhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTmFOKGJhc2UgLyBtYXhTY3JvbGwpID8gMCA6IE1BVEgubWF4KDAsIE1BVEgubWluKDEsIGJhc2UgLyBtYXhTY3JvbGwpKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBnZXRIYW5kbGVPZmZzZXQgPSBmdW5jdGlvbiAoc2Nyb2xsUmF0aW8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IGhhbmRsZVRyYWNrRGlmZiAqIHNjcm9sbFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBpc05hTihvZmZzZXQpID8gMCA6IG9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gKGlzUlRMaXNIb3Jpem9udGFsICYmICFfcnRsU2Nyb2xsQmVoYXZpb3IuaSkgPyAodHJhY2tMZW5ndGggLSBoYW5kbGVMZW5ndGggLSBvZmZzZXQpIDogb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBNQVRILm1heCgwLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFJhdGlvID0gZ2V0U2Nyb2xsUmF0aW8obmF0aXZlU2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5zbmFwcGVkU2Nyb2xsUmF0aW8gPSBnZXRTY3JvbGxSYXRpbyhjdXJyZW50U2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFuZGxlT2Zmc2V0ID0gZ2V0SGFuZGxlT2Zmc2V0KHVuc25hcHBlZFNjcm9sbFJhdGlvKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc25hcHBlZEhhbmRsZU9mZnNldCA9IGdldEhhbmRsZU9mZnNldChzY3JvbGxSYXRpbyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9tYXhTY3JvbGwgPSBtYXhTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX2N1cnJlbnRTY3JvbGwgPSBuYXRpdmVTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyVmFyc0luZm8uX2N1cnJlbnRTY3JvbGxSYXRpbyA9IHNjcm9sbFJhdGlvO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT2Zmc2V0ID0gaXNSVExpc0hvcml6b250YWwgPyAtKHRyYWNrTGVuZ3RoIC0gaGFuZGxlTGVuZ3RoIC0gaGFuZGxlT2Zmc2V0KSA6IGhhbmRsZU9mZnNldDsgLy9pbiBweFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RyYW5zZm9ybU9mZnNldCA9ICh0cmFuc2Zvcm1PZmZzZXQgLyB0cmFja0xlbmd0aCAqIDEwMCkgKiAodHJhY2tMZW5ndGggLyBoYW5kbGVMZW5ndGgpOyAvL2luICVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlVmFsdWUgPSBpc0hvcml6b250YWwgPyBzdHJUcmFuc2xhdGVCcmFjZSArIHRyYW5zZm9ybU9mZnNldCArICdweCwgMCknIDogc3RyVHJhbnNsYXRlQnJhY2UgKyAnMCwgJyArIHRyYW5zZm9ybU9mZnNldCArICdweCknO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ1NTW3N0clRyYW5zZm9ybV0gPSB0cmFuc2xhdGVWYWx1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgb3IgY2xlYXIgdXAgdHJhbnNpdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRUcmFuc2l0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ1NTW3N0clRyYW5zaXRpb25dID0gdHJhbnNpdGlvbiAmJiBNQVRILmFicyhoYW5kbGVPZmZzZXQgLSBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlT2Zmc2V0KSA+IDEgPyBnZXRDU1NUcmFuc2l0aW9uU3RyaW5nKHNjcm9sbGJhclZhcnMuX2hhbmRsZSkgKyAnLCAnICsgKHN0clRyYW5zZm9ybSArIF9zdHJTcGFjZSArIHRyYW5zaXRpb25EdXJhdGlvbiArICdtcycpIDogX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUNTU1tzY3JvbGxiYXJWYXJzLl9sZWZ0X3RvcF0gPSBoYW5kbGVPZmZzZXQ7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL29ubHkgYXBwbHkgY3NzIGlmIG9mZnNldCBoYXMgY2hhbmdlZCBhbmQgb3ZlcmZsb3cgZXhpc3RzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbmF0aXZlT3ZlcmxheVNjcm9sbGJhcnNBcmVBY3RpdmUoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzLl9oYW5kbGUuY3NzKGhhbmRsZUNTUyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2NsZWFyIHVwIHRyYW5zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zdXBwb3J0VHJhbnNmb3JtICYmIF9zdXBwb3J0VHJhbnNpdGlvbiAmJiB0cmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzLl9oYW5kbGUub25lKF9zdHJUcmFuc2l0aW9uRW5kRXZlbnQsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnMuX2hhbmRsZS5jc3Moc3RyVHJhbnNpdGlvbiwgX3N0ckVtcHR5KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5faGFuZGxlT2Zmc2V0ID0gaGFuZGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIHNjcm9sbGJhclZhcnNJbmZvLl9zbmFwcGVkSGFuZGxlT2Zmc2V0ID0gc25hcHBlZEhhbmRsZU9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWYXJzSW5mby5fdHJhY2tMZW5ndGggPSB0cmFja0xlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlZnJlc2hlcyB0aGUgaW50ZXJhY3Rpdml0eSBvZiB0aGUgZ2l2ZW4gc2Nyb2xsYmFyIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaXNUcmFjayBUcnVlIGlmIHRoZSB0cmFjayBlbGVtZW50IGlzIHRoZSB0YXJnZXQsIGZhbHNlIGlmIHRoZSBoYW5kbGUgZWxlbWVudCBpcyB0aGUgdGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlIFRydWUgZm9yIGludGVyYWN0aXZpdHkgZmFsc2UgZm9yIG5vIGludGVyYWN0aXZpdHkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHJlZnJlc2hTY3JvbGxiYXJzSW50ZXJhY3RpdmUoaXNUcmFjaywgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gdmFsdWUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudDEgPSBpc1RyYWNrID8gX3Njcm9sbGJhckhvcml6b250YWxUcmFja0VsZW1lbnQgOiBfc2Nyb2xsYmFySG9yaXpvbnRhbEhhbmRsZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQyID0gaXNUcmFjayA/IF9zY3JvbGxiYXJWZXJ0aWNhbFRyYWNrRWxlbWVudCA6IF9zY3JvbGxiYXJWZXJ0aWNhbEhhbmRsZUVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGlzVHJhY2sgPyBfY2xhc3NOYW1lU2Nyb2xsYmFyVHJhY2tPZmYgOiBfY2xhc3NOYW1lU2Nyb2xsYmFySGFuZGxlT2ZmO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50MVthY3Rpb25dKGNsYXNzTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDJbYWN0aW9uXShjbGFzc05hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIG9iamVjdCB3aGljaCBpcyB1c2VkIGZvciBmYXN0IGFjY2VzcyBmb3Igc3BlY2lmaWMgdmFyaWFibGVzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGlzSG9yaXpvbnRhbCBUcnVlIGlmIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhciB2YXJzIHNoYWxsIGJlIGFjY2Vzc2VkLCBmYWxzZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIHZhcnMgc2hhbGwgYmUgYWNjZXNzZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3doOiBzdHJpbmcsIFdIOiBzdHJpbmcsIGx0OiBzdHJpbmcsIF93aDogc3RyaW5nLCBfbHQ6IHN0cmluZywgdDogKiwgaDogKiwgYzoge30sIHM6ICp9fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRTY3JvbGxiYXJWYXJzKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF93aWR0aF9oZWlnaHQ6IGlzSG9yaXpvbnRhbCA/IF9zdHJXaWR0aCA6IF9zdHJIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9XaWR0aF9IZWlnaHQ6IGlzSG9yaXpvbnRhbCA/ICdXaWR0aCcgOiAnSGVpZ2h0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2xlZnRfdG9wOiBpc0hvcml6b250YWwgPyBfc3RyTGVmdCA6IF9zdHJUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9MZWZ0X1RvcDogaXNIb3Jpem9udGFsID8gJ0xlZnQnIDogJ1RvcCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF94X3k6IGlzSG9yaXpvbnRhbCA/IF9zdHJYIDogX3N0clksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9YX1k6IGlzSG9yaXpvbnRhbCA/ICdYJyA6ICdZJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3dfaDogaXNIb3Jpem9udGFsID8gJ3cnIDogJ2gnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfbF90OiBpc0hvcml6b250YWwgPyAnbCcgOiAndCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90cmFjazogaXNIb3Jpem9udGFsID8gX3Njcm9sbGJhckhvcml6b250YWxUcmFja0VsZW1lbnQgOiBfc2Nyb2xsYmFyVmVydGljYWxUcmFja0VsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9oYW5kbGU6IGlzSG9yaXpvbnRhbCA/IF9zY3JvbGxiYXJIb3Jpem9udGFsSGFuZGxlRWxlbWVudCA6IF9zY3JvbGxiYXJWZXJ0aWNhbEhhbmRsZUVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXI6IGlzSG9yaXpvbnRhbCA/IF9zY3JvbGxiYXJIb3Jpem9udGFsRWxlbWVudCA6IF9zY3JvbGxiYXJWZXJ0aWNhbEVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pbmZvOiBpc0hvcml6b250YWwgPyBfc2Nyb2xsSG9yaXpvbnRhbEluZm8gOiBfc2Nyb2xsVmVydGljYWxJbmZvXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFNjcm9sbGJhciBDb3JuZXIgPT09PS8vXHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCdWlsZHMgb3IgZGVzdHJveXMgdGhlIHNjcm9sbGJhciBjb3JuZXIgRE9NIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZGVzdHJveSBJbmRpY2F0ZXMgd2hldGhlciB0aGUgRE9NIHNoYWxsIGJlIGJ1aWxkIG9yIGRlc3Ryb3llZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0dXBTY3JvbGxiYXJDb3JuZXJET00oZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50ID0gX3Njcm9sbGJhckNvcm5lckVsZW1lbnQgfHwgc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoX2NsYXNzTmFtZVNjcm9sbGJhckNvcm5lciwgdHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzdHJveSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kb21FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9ob3N0RWxlbWVudC5hcHBlbmQoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2RvbUV4aXN0cyAmJiBfaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LnJlbW92ZUF0dHIoTEVYSUNPTi5zKSwgX2NsYXNzTmFtZXNEeW5hbWljRGVzdHJveSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX3Njcm9sbGJhckNvcm5lckVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYWxsIHNjcm9sbGJhciBjb3JuZXIgaW50ZXJhY3Rpdml0eSBldmVudHMuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHNldHVwU2Nyb2xsYmFyQ29ybmVyRXZlbnRzKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNpZGVJRnJhbWUgPSBfd2luZG93RWxlbWVudE5hdGl2ZS50b3AgIT09IF93aW5kb3dFbGVtZW50TmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25Qb3NpdGlvbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtb3VzZURvd25TaXplID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdXNlRG93bkludmVydGVkU2NhbGUgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb25uZWN0TXV0YXRpb25PYnNlcnZlcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnREcmFnTW92ZShldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhZ2VPZmZzZXQgPSBnZXRDb29yZGluYXRlcyhldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEVsZW1lbnRDU1MgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVzaXplSG9yaXpvbnRhbCB8fCBfcmVzaXplQm90aClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0RWxlbWVudENTU1tfc3RyV2lkdGhdID0gKG1vdXNlRG93blNpemUudyArIChwYWdlT2Zmc2V0LnggLSBtb3VzZURvd25Qb3NpdGlvbi54KSAqIG1vdXNlRG93bkludmVydGVkU2NhbGUueCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlc2l6ZVZlcnRpY2FsIHx8IF9yZXNpemVCb3RoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RFbGVtZW50Q1NTW19zdHJIZWlnaHRdID0gKG1vdXNlRG93blNpemUuaCArIChwYWdlT2Zmc2V0LnkgLSBtb3VzZURvd25Qb3NpdGlvbi55KSAqIG1vdXNlRG93bkludmVydGVkU2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdEVsZW1lbnQuY3NzKGhvc3RFbGVtZW50Q1NTKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkuc3RwUChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudE1vdXNlVG91Y2hVcChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9jdW1lbnRNb3VzZVRvdWNoVXAoZXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50SXNUcnVzdGVkID0gZXZlbnQgIT09IHVuZGVmaW5lZDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2RvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfc3RyU2VsZWN0U3RhcnRFdmVudCwgX3N0ck1vdXNlVG91Y2hNb3ZlRXZlbnQsIF9zdHJNb3VzZVRvdWNoVXBFdmVudF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZG9jdW1lbnRPblNlbGVjdFN0YXJ0LCBkb2N1bWVudERyYWdNb3ZlLCBkb2N1bWVudE1vdXNlVG91Y2hVcF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKF9ib2R5RWxlbWVudCwgX2NsYXNzTmFtZURyYWdnaW5nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LnJlbGVhc2VDYXB0dXJlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckNvcm5lckVsZW1lbnQucmVsZWFzZUNhcHR1cmUoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudElzVHJ1c3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXJzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUoX3N0ckF1dG8pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb25Nb3VzZVRvdWNoRG93bkNvbnRpbnVlKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbEV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzVG91Y2hFdmVudCA9IG9yaWdpbmFsRXZlbnQudG91Y2hlcyAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3NsZWVwaW5nIHx8IF9kZXN0cm95ZWQgPyBmYWxzZSA6IENPTVBBVElCSUxJVFkubUJ0bihldmVudCkgPT09IDEgfHwgaXNUb3VjaEV2ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyhldmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX21zaWVWZXJzaW9uICYmIGluc2lkZUlGcmFtZSA/IHsgeDogZXZlbnQuc2NyZWVuWCwgeTogZXZlbnQuc2NyZWVuWSB9IDogQ09NUEFUSUJJTElUWS5wYWdlKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGFkZERlc3Ryb3lFdmVudExpc3RlbmVyKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LCBfc3RyTW91c2VUb3VjaERvd25FdmVudCwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbk1vdXNlVG91Y2hEb3duQ29udGludWUoZXZlbnQpICYmICFfcmVzaXplTm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9tdXRhdGlvbk9ic2VydmVyc0Nvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RNdXRhdGlvbk9ic2VydmVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blBvc2l0aW9uID0gZ2V0Q29vcmRpbmF0ZXMoZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdXNlRG93blNpemUudyA9IF9ob3N0RWxlbWVudE5hdGl2ZVtMRVhJQ09OLm9XXSAtICghX2lzQm9yZGVyQm94ID8gX3BhZGRpbmdYIDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd25TaXplLmggPSBfaG9zdEVsZW1lbnROYXRpdmVbTEVYSUNPTi5vSF0gLSAoIV9pc0JvcmRlckJveCA/IF9wYWRkaW5nWSA6IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW91c2VEb3duSW52ZXJ0ZWRTY2FsZSA9IGdldEhvc3RFbGVtZW50SW52ZXJ0ZWRTY2FsZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX2RvY3VtZW50RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbX3N0clNlbGVjdFN0YXJ0RXZlbnQsIF9zdHJNb3VzZVRvdWNoTW92ZUV2ZW50LCBfc3RyTW91c2VUb3VjaFVwRXZlbnRdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkb2N1bWVudE9uU2VsZWN0U3RhcnQsIGRvY3VtZW50RHJhZ01vdmUsIGRvY3VtZW50TW91c2VUb3VjaFVwXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2JvZHlFbGVtZW50LCBfY2xhc3NOYW1lRHJhZ2dpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50LnNldENhcHR1cmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Njcm9sbGJhckNvcm5lckVsZW1lbnQuc2V0Q2FwdHVyZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENPTVBBVElCSUxJVFkucHJ2RChldmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZLnN0cFAoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIC8vPT09PSBVdGlscyA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIENhbGxzIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBnaXZlbiBuYW1lLiBUaGUgQ29udGV4dCBvZiB0aGlzIGNhbGxiYWNrIGlzIGFsd2F5cyBfYmFzZSAodGhpcykuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IHdoaWNoIHNoYWxsIGJlIGNhbGxlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhcmdzIFRoZSBhcmdzIHdpdGggd2hpY2ggdGhlIGNhbGxiYWNrIHNoYWxsIGJlIGNhbGxlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBkZXBlbmRlbnQgQm9vbGVhbiB3aGljaCBkZWNpZGVzIHdoZXRoZXIgdGhlIGNhbGxiYWNrIHNoYWxsIGJlIGZpcmVkLCB1bmRlZmluZWQgaXMgbGlrZSBhIFwidHJ1ZVwiIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBkaXNwYXRjaENhbGxiYWNrKG5hbWUsIGFyZ3MsIGRlcGVuZGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbnQgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfY3VycmVudFByZXBhcmVkT3B0aW9ucy5jYWxsYmFja3NbbmFtZV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRlbnNpb25Pbk5hbWUgPSBuYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXh0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbk9uTmFtZS5zdWJzdHIoMCwgMikgPT09ICdvbicpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25Pbk5hbWUgPSBleHRlbnNpb25Pbk5hbWUuc3Vic3RyKDIsIDEpLnRvTG93ZXJDYXNlKCkgKyBleHRlbnNpb25Pbk5hbWUuc3Vic3RyKDMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoY2FsbGJhY2spID09IFRZUEVTLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKF9iYXNlLCBhcmdzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goX2V4dGVuc2lvbnMsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dCA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShleHQub24pID09IFRZUEVTLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0Lm9uKGV4dGVuc2lvbk9uTmFtZSwgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghX2Rlc3Ryb3llZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrc0luaXRRZXVldWUucHVzaCh7IG46IG5hbWUsIGE6IGFyZ3MgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSBcInRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFwiIHByb3BlcnRpZXMsIHdpdGggYSBnaXZlbiBwcmVmaXgsIG9mIHRoZSBnaXZlbiBjc3Mgb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHRhcmdldENTU09iamVjdCBUaGUgY3NzIG9iamVjdCB0byB3aGljaCB0aGUgdmFsdWVzIHNoYWxsIGJlIGFwcGxpZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcHJlZml4IFRoZSBwcmVmaXggb2YgdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgY3NzIHByb3BlcnRpZXMuIChleGFtcGxlOiAncGFkZGluZy0nIGlzIGEgdmFsaWQgcHJlZml4KVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlcyBBIGFycmF5IG9mIHZhbHVlcyB3aGljaCBzaGFsbCBiZSBhcHBsaWVkIHRvIHRoZSBcInRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFwiIC1wcm9wZXJ0aWVzLiBUaGUgYXJyYXkgb3JkZXIgaXMgW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uXHJcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGlzIGFyZ3VtZW50IGlzIHVuZGVmaW5lZCB0aGUgdmFsdWUgJycgKGVtcHR5IHN0cmluZykgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBwcm9wZXJ0aWVzLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBzZXRUb3BSaWdodEJvdHRvbUxlZnQodGFyZ2V0Q1NTT2JqZWN0LCBwcmVmaXgsIHZhbHVlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHByZWZpeCB8fCBfc3RyRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzIHx8IFtfc3RyRW1wdHksIF9zdHJFbXB0eSwgX3N0ckVtcHR5LCBfc3RyRW1wdHldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDU1NPYmplY3RbcHJlZml4ICsgX3N0clRvcF0gPSB2YWx1ZXNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q1NTT2JqZWN0W3ByZWZpeCArIF9zdHJSaWdodF0gPSB2YWx1ZXNbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q1NTT2JqZWN0W3ByZWZpeCArIF9zdHJCb3R0b21dID0gdmFsdWVzWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldENTU09iamVjdFtwcmVmaXggKyBfc3RyTGVmdF0gPSB2YWx1ZXNbM107XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBcInRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdFwiIENTUyBwcm9wZXJ0aWVzIG9mIHRoZSBDU1MgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gcHJlZml4IGZyb20gdGhlIGhvc3QgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwcmVmaXggVGhlIHByZWZpeCBvZiB0aGUgXCJ0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRcIiBjc3MgcHJvcGVydGllcy4gKGV4YW1wbGU6ICdwYWRkaW5nLScgaXMgYSB2YWxpZCBwcmVmaXgpXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc3VmZml4IFRoZSBzdWZmaXggb2YgdGhlIFwidG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XCIgY3NzIHByb3BlcnRpZXMuIChleGFtcGxlOiAnYm9yZGVyLScgaXMgYSB2YWxpZCBwcmVmaXggd2l0aCAnLXdpZHRoJyBpcyBhIHZhbGlkIHN1ZmZpeClcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB6ZXJvWCBUcnVlIGlmIHRoZSB4IGF4aXMgc2hhbGwgYmUgMC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB6ZXJvWSBUcnVlIGlmIHRoZSB5IGF4aXMgc2hhbGwgYmUgMC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7fX0gVGhlIG9iamVjdCB3aGljaCBjb250YWlucyB0aGUgbnVtYmVycyBvZiB0aGUgcmVhZCBDU1MgcHJvcGVydGllcy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VG9wUmlnaHRCb3R0b21MZWZ0SG9zdChwcmVmaXgsIHN1ZmZpeCwgemVyb1gsIHplcm9ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VmZml4ID0gc3VmZml4IHx8IF9zdHJFbXB0eTtcclxuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ6IHplcm9ZID8gMCA6IHBhcnNlVG9aZXJvT3JOdW1iZXIoX2hvc3RFbGVtZW50LmNzcyhwcmVmaXggKyBfc3RyVG9wICsgc3VmZml4KSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHI6IHplcm9YID8gMCA6IHBhcnNlVG9aZXJvT3JOdW1iZXIoX2hvc3RFbGVtZW50LmNzcyhwcmVmaXggKyBfc3RyUmlnaHQgKyBzdWZmaXgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYjogemVyb1kgPyAwIDogcGFyc2VUb1plcm9Pck51bWJlcihfaG9zdEVsZW1lbnQuY3NzKHByZWZpeCArIF9zdHJCb3R0b20gKyBzdWZmaXgpKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbDogemVyb1ggPyAwIDogcGFyc2VUb1plcm9Pck51bWJlcihfaG9zdEVsZW1lbnQuY3NzKHByZWZpeCArIF9zdHJMZWZ0ICsgc3VmZml4KSlcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgQ1NTIHRyYW5zaXRpb24gc3RyaW5nIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRoZSB0cmFuc2l0aW9uIHN0cmluZyBzaGFsbCBiZSByZXR1cm5lZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBDU1MgdHJhbnNpdGlvbiBzdHJpbmcgZnJvbSB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q1NTVHJhbnNpdGlvblN0cmluZyhlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25TdHIgPSBWRU5ET1JTLl9jc3NQcm9wZXJ0eSgndHJhbnNpdGlvbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3NlbWJsZWRWYWx1ZSA9IGVsZW1lbnQuY3NzKHRyYW5zaXRpb25TdHIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3NlbWJsZWRWYWx1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFzc2VtYmxlZFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdFeHBTdHJpbmcgPSAnXFxcXHMqKCcgKyAnKFteLChdKyhcXFxcKC4rP1xcXFwpKT8pKycgKyAnKVtcXFxccyxdKic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ0V4cE1haW4gPSBuZXcgUmVnRXhwKHJlZ0V4cFN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZ0V4cFZhbGlkYXRlID0gbmV3IFJlZ0V4cCgnXignICsgcmVnRXhwU3RyaW5nICsgJykrJCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gJ3Byb3BlcnR5IGR1cmF0aW9uIHRpbWluZy1mdW5jdGlvbiBkZWxheScuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0clJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVBcnJheTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGo7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0Q3NzU3R5bGVCeUNvbW1hID0gZnVuY3Rpb24gKHN0cikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJSZXN1bHQgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdHIubWF0Y2gocmVnRXhwVmFsaWRhdGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0ci5tYXRjaChyZWdFeHBNYWluKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyUmVzdWx0LnB1c2goUmVnRXhwLiQxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKHJlZ0V4cE1haW4sIF9zdHJFbXB0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJSZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHByb3BlcnRpZXNbTEVYSUNPTi5sXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXJyYXkgPSBzcGxpdENzc1N0eWxlQnlDb21tYShlbGVtZW50LmNzcyh0cmFuc2l0aW9uU3RyICsgJy0nICsgcHJvcGVydGllc1tpXSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdmFsdWVBcnJheVtMRVhJQ09OLmxdOyBqKyspXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbal0gPSAocmVzdWx0W2pdID8gcmVzdWx0W2pdICsgX3N0clNwYWNlIDogX3N0ckVtcHR5KSArIHZhbHVlQXJyYXlbal07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignLCAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEdlbmVyYXRlcyBhIFJlZ3VsYXIgRXhwcmVzc2lvbiB3aGljaCBtYXRjaGVzIHdpdGggYSBzdHJpbmcgd2hpY2ggc3RhcnRzIHdpdGggJ29zLWhvc3QnLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSB3aXRoQ3VyckNsYXNzTmFtZU9wdGlvbiBUaGUgUmVndWxhciBFeHByZXNzaW9uIGFsc28gbWF0Y2hlcyBpZiB0aGUgc3RyaW5nIGlzIHRoZSBjdXJyZW50IENsYXNzTmFtZSBvcHRpb24gKG11bHRpcGxlIHZhbHVlcyBzcGxpdHRlZCBieSBzcGFjZSBwb3NzaWJsZSkuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhPbGRDbGFzc05hbWVPcHRpb24gVGhlIFJlZ3VsYXIgRXhwcmVzc2lvbiBhbHNvIG1hdGNoZXMgaWYgdGhlIHN0cmluZyBpcyB0aGUgb2xkIENsYXNzTmFtZSBvcHRpb24gKG11bHRpcGxlIHZhbHVlcyBzcGxpdHRlZCBieSBzcGFjZSBwb3NzaWJsZSkuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUhvc3RDbGFzc05hbWVSZWdFeHAod2l0aEN1cnJDbGFzc05hbWVPcHRpb24sIHdpdGhPbGRDbGFzc05hbWVPcHRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3BsaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFwcGVuZGl4O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhcHBlbmRDbGFzc2VzID0gZnVuY3Rpb24gKGNsYXNzZXMsIGNvbmRpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRpeCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZGl0aW9uICYmIHR5cGVvZiBjbGFzc2VzID09IFRZUEVTLnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gY2xhc3Nlcy5zcGxpdChfc3RyU3BhY2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwbGl0W0xFWElDT04ubF07IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRpeCArPSAnfCcgKyBzcGxpdFtpXSArICckJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0W2ldLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCAnXFxcXCQmJykgZm9yIGVzY2FwaW5nIHJlZ2V4IGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXBwZW5kaXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcoXicgKyBfY2xhc3NOYW1lSG9zdEVsZW1lbnQgKyAnKFstX10uK3wpJCknICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ2xhc3NlcyhfY2xhc3NOYW1lQ2FjaGUsIHdpdGhDdXJyQ2xhc3NOYW1lT3B0aW9uKSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZENsYXNzZXMoX29sZENsYXNzTmFtZSwgd2l0aE9sZENsYXNzTmFtZU9wdGlvbiksICdnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBob3N0LWVsZW1lbnRzIGludmVydGVkIHNjYWxlLiAoaW52ZXJ0ZWRTY2FsZSA9IDEgLyBzY2FsZSlcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBUaGUgc2NhbGUgb2YgdGhlIGhvc3QtZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0SG9zdEVsZW1lbnRJbnZlcnRlZFNjYWxlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWN0ID0gX3BhZGRpbmdFbGVtZW50TmF0aXZlW0xFWElDT04uYkNSXSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IF9zdXBwb3J0VHJhbnNmb3JtID8gMSAvIChNQVRILnJvdW5kKHJlY3Qud2lkdGgpIC8gX3BhZGRpbmdFbGVtZW50TmF0aXZlW0xFWElDT04ub1ddKSB8fCAxIDogMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogX3N1cHBvcnRUcmFuc2Zvcm0gPyAxIC8gKE1BVEgucm91bmQocmVjdC5oZWlnaHQpIC8gX3BhZGRpbmdFbGVtZW50TmF0aXZlW0xFWElDT04ub0hdKSB8fCAxIDogMVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgSFRNTEVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbyBUaGUgb2JqZWN0IHdoaWNoIHNoYWxsIGJlIGNoZWNrZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgSFRNTEVsZW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gaXNIVE1MRWxlbWVudChvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck93bmVyRG9jdW1lbnQgPSAnb3duZXJEb2N1bWVudCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckhUTUxFbGVtZW50ID0gJ0hUTUxFbGVtZW50JztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd25kID0gbyAmJiBvW3N0ck93bmVyRG9jdW1lbnRdID8gKG9bc3RyT3duZXJEb2N1bWVudF0ucGFyZW50V2luZG93IHx8IHdpbmRvdykgOiB3aW5kb3c7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHduZFtzdHJIVE1MRWxlbWVudF0gPT0gVFlQRVMubyA/IG8gaW5zdGFuY2VvZiB3bmRbc3RySFRNTEVsZW1lbnRdIDogLy9ET00yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvICYmIHR5cGVvZiBvID09IFRZUEVTLm8gJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09IFRZUEVTLnNcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ29tcGFyZXMgMiBhcnJheXMgYW5kIHJldHVybnMgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlbSBhcyBhIGFycmF5LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGExIFRoZSBmaXJzdCBhcnJheSB3aGljaCBzaGFsbCBiZSBjb21wYXJlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhMiBUaGUgc2Vjb25kIGFycmF5IHdoaWNoIHNoYWxsIGJlIGNvbXBhcmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge0FycmF5fSBUaGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGUgdHdvIGFycmF5cy5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0QXJyYXlEaWZmZXJlbmNlcyhhMSwgYTIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaWZmID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGs7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGExLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhW2ExW2ldXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGEyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW2EyW2ldXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhW2EyW2ldXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYVthMltpXV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gYSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlmZi5wdXNoKGspO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaWZmO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBaZXJvIG9yIHRoZSBudW1iZXIgdG8gd2hpY2ggdGhlIHZhbHVlIGNhbiBiZSBwYXJzZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHdoaWNoIHNoYWxsIGJlIHBhcnNlZC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB0b0Zsb2F0IEluZGljYXRlcyB3aGV0aGVyIHRoZSBudW1iZXIgc2hhbGwgYmUgcGFyc2VkIHRvIGEgZmxvYXQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlVG9aZXJvT3JOdW1iZXIodmFsdWUsIHRvRmxvYXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtID0gdG9GbG9hdCA/IHBhcnNlRmxvYXQodmFsdWUpIDogcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNOYU4obnVtKSA/IDAgOiBudW07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHNldmVyYWwgaW5mb3JtYXRpb24gb2YgdGhlIHRleHRhcmVhIGFuZCByZXR1cm5zIHRoZW0gYXMgYSBvYmplY3Qgb3IgdW5kZWZpbmVkIGlmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBpdC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7Y3Vyc29yUm93OiBOdW1iZXIsIGN1cnNvckNvbCwgcm93czogTnVtYmVyLCBjb2xzOiBudW1iZXIsIHdSb3c6IG51bWJlciwgcG9zOiBudW1iZXIsIG1heCA6IG51bWJlcn19IG9yIHVuZGVmaW5lZCBpZiBub3Qgc3VwcG9ydGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBnZXRUZXh0YXJlYUluZm8oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZWFkIG5lZWRlZCB2YWx1ZXNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFDdXJzb3JQb3NpdGlvbiA9IF90YXJnZXRFbGVtZW50TmF0aXZlLnNlbGVjdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0YXJlYUN1cnNvclBvc2l0aW9uID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhVmFsdWUgPSBfdGFyZ2V0RWxlbWVudC52YWwoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFMZW5ndGggPSB0ZXh0YXJlYVZhbHVlW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHRhcmVhUm93U3BsaXQgPSB0ZXh0YXJlYVZhbHVlLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFMYXN0Um93ID0gdGV4dGFyZWFSb3dTcGxpdFtMRVhJQ09OLmxdO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0YXJlYUN1cnJlbnRDdXJzb3JSb3dTcGxpdCA9IHRleHRhcmVhVmFsdWUuc3Vic3RyKDAsIHRleHRhcmVhQ3Vyc29yUG9zaXRpb24pLnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgd2lkZXN0Um93ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dGFyZWFMYXN0Q29sID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yUm93ID0gdGV4dGFyZWFDdXJyZW50Q3Vyc29yUm93U3BsaXRbTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vyc29yQ29sID0gdGV4dGFyZWFDdXJyZW50Q3Vyc29yUm93U3BsaXRbdGV4dGFyZWFDdXJyZW50Q3Vyc29yUm93U3BsaXRbTEVYSUNPTi5sXSAtIDFdW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0NvbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2V0IHdpZGVzdCBSb3cgYW5kIHRoZSBsYXN0IGNvbHVtbiBvZiB0aGUgdGV4dGFyZWFcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dGFyZWFSb3dTcGxpdFtMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm93Q29scyA9IHRleHRhcmVhUm93U3BsaXRbaV1bTEVYSUNPTi5sXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvd0NvbHMgPiB0ZXh0YXJlYUxhc3RDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZGVzdFJvdyA9IGkgKyAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dGFyZWFMYXN0Q29sID0gcm93Q29scztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvclJvdzogY3Vyc29yUm93LCAvL2N1cnNvclJvd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yQ29sdW1uOiBjdXJzb3JDb2wsIC8vY3Vyc29yQ29sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yb3dzOiB0ZXh0YXJlYUxhc3RSb3csIC8vcm93c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29sdW1uczogdGV4dGFyZWFMYXN0Q29sLCAvL2NvbHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3dpZGVzdFJvdzogd2lkZXN0Um93LCAvL3dSb3dcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2N1cnNvclBvc2l0aW9uOiB0ZXh0YXJlYUN1cnNvclBvc2l0aW9uLCAvL3Bvc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfY3Vyc29yTWF4OiB0ZXh0YXJlYUxlbmd0aCAvL21heFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgbmF0aXZlIG92ZXJsYXkgc2Nyb2xsYmFycyBhcmUgYWN0aXZlLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgbmF0aXZlIG92ZXJsYXkgc2Nyb2xsYmFycyBhcmUgYWN0aXZlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIG5hdGl2ZU92ZXJsYXlTY3JvbGxiYXJzQXJlQWN0aXZlKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2lnbm9yZU92ZXJsYXlTY3JvbGxiYXJIaWRpbmdDYWNoZSAmJiAoX25hdGl2ZVNjcm9sbGJhcklzT3ZlcmxhaWQueCAmJiBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC55KSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZXRzIHRoZSBlbGVtZW50IHdoaWNoIGlzIHVzZWQgdG8gbWVhc3VyZSB0aGUgY29udGVudCBzaXplLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFRleHRhcmVhQ292ZXIgaWYgdGFyZ2V0IGVsZW1lbnQgaXMgdGV4dGFyZWEgZWxzZSB0aGUgQ29udGVudEVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldENvbnRlbnRNZWFzdXJlRWxlbWVudCgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2lzVGV4dGFyZWEgPyBfdGV4dGFyZWFDb3ZlckVsZW1lbnRbMF0gOiBfY29udGVudEVsZW1lbnROYXRpdmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBHZW5lcmF0ZXMgYSBzdHJpbmcgd2hpY2ggcmVwcmVzZW50cyBhIEhUTUwgZGl2IHdpdGggdGhlIGdpdmVuIGNsYXNzZXMgb3IgYXR0cmlidXRlcy5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjbGFzc2VzT3JBdHRycyBUaGUgY2xhc3Mgb2YgdGhlIGRpdiBhcyBzdHJpbmcgb3IgYSBvYmplY3Qgd2hpY2ggcmVwcmVzZW50cyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgZGl2LiAoVGhlIGNsYXNzIGF0dHJpYnV0ZSBjYW4gYWxzbyBiZSB3cml0dGVuIGFzIFwiY2xhc3NOYW1lXCIuKVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbnRlbnQgVGhlIGNvbnRlbnQgb2YgdGhlIGRpdiBhcyBzdHJpbmcuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29uY2F0ZWQgc3RyaW5nIHdoaWNoIHJlcHJlc2VudHMgYSBIVE1MIGRpdiBhbmQgaXRzIGNvbnRlbnQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdlbmVyYXRlRGl2KGNsYXNzZXNPckF0dHJzLCBjb250ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICc8ZGl2ICcgKyAoY2xhc3Nlc09yQXR0cnMgPyB0eXBlKGNsYXNzZXNPckF0dHJzKSA9PSBUWVBFUy5zID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgJ2NsYXNzPVwiJyArIGNsYXNzZXNPckF0dHJzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzID0gX3N0ckVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEZSQU1FV09SSy5pc1BsYWluT2JqZWN0KGNsYXNzZXNPckF0dHJzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGNsYXNzZXNPckF0dHJzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRycyArPSAoa2V5ID09PSAnYycgPyAnY2xhc3MnIDoga2V5KSArICc9XCInICsgY2xhc3Nlc09yQXR0cnNba2V5XSArICdcIiAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF0dHJzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0ckVtcHR5KSArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb250ZW50IHx8IF9zdHJFbXB0eSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC9kaXY+JztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFNlbGVjdHMgb3IgZ2VuZXJhdGVzIGEgZGl2IHdpdGggdGhlIGdpdmVuIGNsYXNzIGF0dHJpYnV0ZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjbGFzc05hbWUgVGhlIGNsYXNzIG5hbWVzIChkaXZpZGVkIGJ5IHNwYWNlcykgb2YgdGhlIGRpdiB3aGljaCBzaGFsbCBiZSBzZWxlY3RlZCBvciBnZW5lcmF0ZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gc2VsZWN0UGFyZW50T3JPbmx5Q2hpbGRyZW4gVGhlIHBhcmVudCBlbGVtZW50IGZyb20gd2hpY2ggb2YgdGhlIGVsZW1lbnQgc2hhbGwgYmUgc2VsZWN0ZWQuIChpZiB1bmRlZmluZWQgb3IgYm9vbGVhbiBpdHMgaG9zdEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgKiBJZiBpdHMgYSBib29sZWFuIGl0IGRlY2lkZXMgd2hldGhlciBvbmx5IHRoZSBjaGlsZHJlbiBvZiB0aGUgaG9zdCBlbGVtZW50IHNoYWxsIGJlIHNlbGVjdGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFRoZSBnZW5lcmF0ZWQgb3Igc2VsZWN0ZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0T3JHZW5lcmF0ZURpdkJ5Q2xhc3MoY2xhc3NOYW1lLCBzZWxlY3RQYXJlbnRPck9ubHlDaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvbmx5Q2hpbGRyZW4gPSB0eXBlKHNlbGVjdFBhcmVudE9yT25seUNoaWxkcmVuKSA9PSBUWVBFUy5iO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RQYXJlbnQgPSBvbmx5Q2hpbGRyZW4gPyBfaG9zdEVsZW1lbnQgOiAoc2VsZWN0UGFyZW50T3JPbmx5Q2hpbGRyZW4gfHwgX2hvc3RFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfZG9tRXhpc3RzICYmICFzZWxlY3RQYXJlbnRbTEVYSUNPTi5sXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBudWxsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX2RvbUV4aXN0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3RQYXJlbnRbb25seUNoaWxkcmVuID8gJ2NoaWxkcmVuJyA6ICdmaW5kJ10oX3N0ckRvdCArIGNsYXNzTmFtZS5yZXBsYWNlKC9cXHMvZywgX3N0ckRvdCkpLmVxKDApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IEZSQU1FV09SSyhnZW5lcmF0ZURpdihjbGFzc05hbWUpKVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIHByb3BlcnR5IGZyb20gdGhlIGdpdmVuIG9iamVjdC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0eSB2YWx1ZSBzaGFsbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcHJvcGVydHkgb2Ygd2hpY2ggdGhlIHZhbHVlIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc2VhcmNoZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkIG9mIHRoZSBwcm9wZXJ0eSB3YXNuJ3QgZm91bmQuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldE9iamVjdFByb3BWYWwob2JqLCBwYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0cyA9IHBhdGguc3BsaXQoX3N0ckRvdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBzcGxpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmpbTEVYSUNPTi5oT1BdKHNwbGl0c1tpXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9ialtzcGxpdHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IHNwbGl0cy5sZW5ndGggJiYgdHlwZSh2YWwpID09IFRZUEVTLm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmogPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHByb3BlcnR5IHZhbHVlIHNoYWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBwYXRoIFRoZSBwcm9wZXJ0eSBvZiB3aGljaCB0aGUgdmFsdWUgc2hhbGwgYmUgc2V0LlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IHdoaWNoIHNoYWxsIGJlIHNldC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gc2V0T2JqZWN0UHJvcFZhbChvYmosIHBhdGgsIHZhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdHMgPSBwYXRoLnNwbGl0KF9zdHJEb3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGxpdHNMZW5ndGggPSBzcGxpdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZXh0ZW5kT2JqID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZE9ialJvb3QgPSBleHRlbmRPYmo7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBzcGxpdHNMZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kT2JqID0gZXh0ZW5kT2JqW3NwbGl0c1tpXV0gPSBpICsgMSA8IHNwbGl0c0xlbmd0aCA/IHt9IDogdmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSy5leHRlbmQob2JqLCBleHRlbmRPYmpSb290LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcdFxyXG4gICAgICAgICAgICAgICAgICogUnVucyBhIGFjdGlvbiBmb3IgZWFjaCBzZWxlY3RvciBpbnNpZGUgdGhlIHVwZGF0ZU9uTG9hZCBvcHRpb24uXHRcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFjdGlvbiBUaGUgYWN0aW9uIGZvciBlYWNoIHVwZGF0ZU9uTG9hZCBzZWxlY3RvciwgdGhlIGFyZ3VtZW50cyB0aGUgZnVuY3Rpb24gdGFrZXMgaXMgdGhlIGluZGV4IGFuZCB0aGUgdmFsdWUgKHRoZSBzZWxlY3RvcikuXHRcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZWFjaFVwZGF0ZU9uTG9hZChhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlT25Mb2FkID0gX2N1cnJlbnRQcmVwYXJlZE9wdGlvbnMudXBkYXRlT25Mb2FkO1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU9uTG9hZCA9IHR5cGUodXBkYXRlT25Mb2FkKSA9PSBUWVBFUy5zID8gdXBkYXRlT25Mb2FkLnNwbGl0KF9zdHJTcGFjZSkgOiB1cGRhdGVPbkxvYWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmlzQSh1cGRhdGVPbkxvYWQpICYmICFfZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2godXBkYXRlT25Mb2FkLCBhY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFV0aWxzIENhY2hlID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ29tcGFyZXMgdHdvIHZhbHVlcyBvciBvYmplY3RzIGFuZCByZXR1cm5zIHRydWUgaWYgdGhleSBhcmVuJ3QgZXF1YWwuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gY3VycmVudCBUaGUgZmlyc3QgdmFsdWUgb3Igb2JqZWN0IHdoaWNoIHNoYWxsIGJlIGNvbXBhcmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNhY2hlIFRoZSBzZWNvbmQgdmFsdWUgb3Igb2JqZWN0IHdoaWNoIHNoYWxsIGJlIGNvbXBhcmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGZvcmNlIElmIHRydWUgdGhlIHJldHVybmVkIHZhbHVlIGlzIGFsd2F5cyB0cnVlLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYm90aCB2YWx1ZXMgb3Igb2JqZWN0cyBhcmVuJ3QgZXF1YWwgb3IgZm9yY2UgaXMgdHJ1ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja0NhY2hlKGN1cnJlbnQsIGNhY2hlLCBmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvcmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlKGN1cnJlbnQpID09IFRZUEVTLm8gJiYgdHlwZShjYWNoZSkgPT0gVFlQRVMubykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wICE9PSAnYycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFtMRVhJQ09OLmhPUF0ocHJvcCkgJiYgY2FjaGVbTEVYSUNPTi5oT1BdKHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGVja0NhY2hlKGN1cnJlbnRbcHJvcF0sIGNhY2hlW3Byb3BdKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudCAhPT0gY2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy89PT09IFNob3J0Y3V0cyA9PT09Ly9cclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIGpRdWVyeSBleHRlbmQgbWV0aG9kIHNob3J0Y3V0IHdpdGggYSBhcHBlbmRlZCBcInRydWVcIiBhcyBmaXJzdCBhcmd1bWVudC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZXh0ZW5kRGVlcCgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRlJBTUVXT1JLLmV4dGVuZC5hcHBseSh0aGlzLCBbdHJ1ZV0uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogalF1ZXJ5IGFkZENsYXNzIG1ldGhvZCBzaG9ydGN1dC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1ld29ya1Byb3RvLmFkZENsYXNzLmNhbGwoZWwsIGNsYXNzZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogalF1ZXJ5IHJlbW92ZUNsYXNzIG1ldGhvZCBzaG9ydGN1dC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1ld29ya1Byb3RvLnJlbW92ZUNsYXNzLmNhbGwoZWwsIGNsYXNzZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQWRkcyBvciByZW1vdmVzIHRoZSBnaXZlbiBjbGFzc2VzIGRlcGVuZGVudCBvbiB0aGUgYm9vbGVhbiB2YWx1ZS4gVHJ1ZSBmb3IgYWRkLCBmYWxzZSBmb3IgcmVtb3ZlLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBhZGRSZW1vdmVDbGFzcyhlbCwgY2xhc3NlcywgZG9BZGQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9BZGQgPyBhZGRDbGFzcyhlbCwgY2xhc3NlcykgOiByZW1vdmVDbGFzcyhlbCwgY2xhc3Nlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBqUXVlcnkgcmVtb3ZlIG1ldGhvZCBzaG9ydGN1dC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZXdvcmtQcm90by5yZW1vdmUuY2FsbChlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGaW5kcyB0aGUgZmlyc3QgY2hpbGQgZWxlbWVudCB3aXRoIHRoZSBnaXZlbiBzZWxlY3RvciBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBlbCBUaGUgcm9vdCBlbGVtZW50IGZyb20gd2hpY2ggdGhlIHNlbGVjdG9yIHNoYWxsIGJlIHZhbGlkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHNlbGVjdG9yIFRoZSBzZWxlY3RvciBvZiB0aGUgc2VhcmNoZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfSBUaGUgZmlyc3QgZWxlbWVudCB3aGljaCBpcyBhIGNoaWxkIG9mIHRoZSBnaXZlbiBlbGVtZW50IGFuZCBtYXRjaGVzIHRoZSBnaXZlbnMgc2VsZWN0b3IuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRGaXJzdChlbCwgc2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1ld29ya1Byb3RvLmZpbmQuY2FsbChlbCwgc2VsZWN0b3IpLmVxKDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLz09PT0gQVBJID09PT0vL1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUHV0cyB0aGUgaW5zdGFuY2UgdG8gc2xlZXAuIEl0IHdvbnQgcmVzcG9uZCB0byBhbnkgY2hhbmdlcyBpbiB0aGUgRE9NIGFuZCB3b24ndCB1cGRhdGUuIFNjcm9sbGJhciBJbnRlcmFjdGl2aXR5IGlzIGFsc28gZGlzYWJsZWQgYXMgd2VsbCBhcyB0aGUgcmVzaXplIGhhbmRsZS5cclxuICAgICAgICAgICAgICAgICAqIFRoaXMgYmVoYXZpb3IgY2FuIGJlIHJlc2V0IGJ5IGNhbGxpbmcgdGhlIHVwZGF0ZSBtZXRob2QuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIF9iYXNlLnNsZWVwID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF9zbGVlcGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVXBkYXRlcyB0aGUgcGx1Z2luIGFuZCBET00gdG8gdGhlIGN1cnJlbnQgb3B0aW9ucy5cclxuICAgICAgICAgICAgICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiBhIHVwZGF0ZSBpcyAxMDAlIHJlcXVpcmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGZvcmNlIFRydWUgaWYgZXZlcnkgcHJvcGVydHkgc2hhbGwgYmUgdXBkYXRlZCBhbmQgdGhlIGNhY2hlIHNoYWxsIGJlIGlnbm9yZWQuXHJcbiAgICAgICAgICAgICAgICAgKiAhSU5URVJOQUwgVVNBR0UhIDogZm9yY2UgY2FuIGJlIGEgc3RyaW5nIFwiYXV0b1wiLCBcInN5bmNcIiBvciBcInpvb21cIiB0b29cclxuICAgICAgICAgICAgICAgICAqIGlmIFwiYXV0b1wiIHRoZW4gYmVmb3JlIGEgcmVhbCB1cGRhdGUgdGhlIGNvbnRlbnQgc2l6ZSBhbmQgaG9zdCBlbGVtZW50IGF0dHJpYnV0ZXMgZ2V0cyBjaGVja2VkLCBhbmQgaWYgdGhleSBjaGFuZ2VkIG9ubHkgdGhlbiB0aGUgdXBkYXRlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZC5cclxuICAgICAgICAgICAgICAgICAqIGlmIFwic3luY1wiIHRoZW4gdGhlIGFzeW5jIHVwZGF0ZSBwcm9jZXNzIChNdXRhdGlvbk9ic2VydmVyIG9yIFVwZGF0ZUxvb3ApIGdldHMgc3luY2hyb25pemVkIGFuZCBhIGNvcnJlc3BvbmRpbmcgdXBkYXRlIHRha2VzIHBsYWNlIGlmIG9uZSB3YXMgbmVlZGVkIGR1ZSB0byBwZW5kaW5nIGNoYW5nZXMuXHJcbiAgICAgICAgICAgICAgICAgKiBpZiBcInpvb21cIiB0aGVuIGEgdXBkYXRlIHRha2VzIHBsYWNlIHdoZXJlIGl0J3MgYXNzdW1lZCB0aGF0IGNvbnRlbnQgYW5kIGhvc3Qgc2l6ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnx1bmRlZmluZWR9IFxyXG4gICAgICAgICAgICAgICAgICogSWYgZm9yY2UgaXMgXCJzeW5jXCIgdGhlbiBhIGJvb2xlYW4gaXMgcmV0dXJuZWQgd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgYSB1cGRhdGUgd2FzIG5lZWRlZCBkdWUgdG8gcGVuZGluZyBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICogSWYgZm9yY2UgaXMgXCJhdXRvXCIgdGhlbiBhIGJvb2xlYW4gaXMgcmV0dXJuZWQgd2hldGhlciBhIHVwZGF0ZSB3YXMgbmVlZGVkIGR1ZSB0byBhdHRyaWJ1dGUgb3Igc2l6ZSBjaGFuZ2VzLlxyXG4gICAgICAgICAgICAgICAgICogdW5kZWZpbmVkIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UudXBkYXRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kZXN0cm95ZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJzQ2hhbmdlZDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFNpemVDO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1N0cmluZyA9IHR5cGUoZm9yY2UpID09IFRZUEVTLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvVXBkYXRlQXV0bztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXV0SG9zdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbXV0Q29udGVudDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3JjZSA9PT0gX3N0ckF1dG8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzQ2hhbmdlZCA9IG1lYW5pbmdmdWxBdHRyc0NoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRTaXplQyA9IHVwZGF0ZUF1dG9Db250ZW50U2l6ZUNoYW5nZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvVXBkYXRlQXV0byA9IGF0dHJzQ2hhbmdlZCB8fCBjb250ZW50U2l6ZUM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9VcGRhdGVBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRlbnRTaXplQ2hhbmdlZDogY29udGVudFNpemVDLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2hhbmdlZE9wdGlvbnM6IF9pbml0aWFsaXplZCA/IHVuZGVmaW5lZCA6IF9jdXJyZW50UHJlcGFyZWRPcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yY2UgPT09IF9zdHJTeW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0SG9zdCA9IF9tdXRhdGlvbk9ic2VydmVySG9zdENhbGxiYWNrKF9tdXRhdGlvbk9ic2VydmVySG9zdC50YWtlUmVjb3JkcygpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtdXRDb250ZW50ID0gX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50Q2FsbGJhY2soX211dGF0aW9uT2JzZXJ2ZXJDb250ZW50LnRha2VSZWNvcmRzKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0SG9zdCA9IF9iYXNlLnVwZGF0ZShfc3RyQXV0byk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9yY2UgPT09ICd6b29tJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaG9zdFNpemVDaGFuZ2VkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZW50U2l6ZUNoYW5nZWQ6IHRydWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IF9zbGVlcGluZyB8fCBmb3JjZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3NsZWVwaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Jhc2UudXBkYXRlKF9zdHJTeW5jKSB8fCBmb3JjZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSh7IF9mb3JjZTogZm9yY2UgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVFbGVtZW50c09uTG9hZCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9VcGRhdGVBdXRvIHx8IG11dEhvc3QgfHwgbXV0Q29udGVudDtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IG9wdGlvbnMuIFRoZSB1cGRhdGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgaWYgbmV3IG9wdGlvbnMgd2VyZSBzZXQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbmV3T3B0aW9ucyBJZiBuZXcgb3B0aW9ucyBhcmUgZ2l2ZW4sIHRoZW4gdGhlIG5ldyBvcHRpb25zIHdpbGwgYmUgc2V0LCBpZiBuZXcgb3B0aW9ucyBhcmVuJ3QgZ2l2ZW4gKHVuZGVmaW5lZCBvciBhIG5vdCBhIHBsYWluIG9iamVjdCkgdGhlbiB0aGUgY3VycmVudCBvcHRpb25zIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWUgSWYgbmV3IG9wdGlvbnMgaXMgYSBwcm9wZXJ0eSBwYXRoIHN0cmluZywgdGhlbiB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZCB0byBzZXQgdGhlIG9wdGlvbiB0byB3aGljaCB0aGUgcHJvcGVydHkgcGF0aCBzdHJpbmcgbGVhZHMuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2Uub3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdPcHRpb25zLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZE9wcztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gY3VycmVudCBvcHRpb25zIGlmIG5ld09wdGlvbnMgYXJlIHVuZGVmaW5lZCBvciBlbXB0eVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChGUkFNRVdPUksuaXNFbXB0eU9iamVjdChuZXdPcHRpb25zKSB8fCAhRlJBTUVXT1JLLmlzUGxhaW5PYmplY3QobmV3T3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUobmV3T3B0aW9ucykgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T2JqZWN0UHJvcFZhbChvcHRpb24sIG5ld09wdGlvbnMsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkT3BzID0gc2V0T3B0aW9ucyhvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRPYmplY3RQcm9wVmFsKF9jdXJyZW50T3B0aW9ucywgbmV3T3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50T3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRPcHMgPSBzZXRPcHRpb25zKG5ld09wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFGUkFNRVdPUksuaXNFbXB0eU9iamVjdChjaGFuZ2VkT3BzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoeyBfY2hhbmdlZE9wdGlvbnM6IGNoYW5nZWRPcHMgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJlc3RvcmUgdGhlIERPTSwgZGlzY29ubmVjdHMgYWxsIG9ic2VydmVycywgcmVtb3ZlIGFsbCByZXNpemUgb2JzZXJ2ZXJzIGFuZCBwdXQgdGhlIGluc3RhbmNlIHRvIHNsZWVwLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoaXMgaW5zdGFuY2UgZnJvbSBhdXRvIHVwZGF0ZSBsb29wXHJcbiAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZUxvb3AucmVtb3ZlKF9iYXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9kaXNjb25uZWN0IGFsbCBtdXRhdGlvbiBvYnNlcnZlcnNcclxuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0TXV0YXRpb25PYnNlcnZlcnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIHJlc2l6ZSBvYnNlcnZlcnNcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc2l6ZU9ic2VydmVyKF9zaXplT2JzZXJ2ZXJFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc2l6ZU9ic2VydmVyKF9zaXplQXV0b09ic2VydmVyRWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCBleHRlbnNpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZXh0TmFtZSBpbiBfZXh0ZW5zaW9ucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Jhc2UucmVtb3ZlRXh0KGV4dE5hbWUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgJ2Rlc3Ryb3knIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChfZGVzdHJveUV2ZW50c1tMRVhJQ09OLmxdID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Rlc3Ryb3lFdmVudHMucG9wKCkoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIGV2ZW50cyBmcm9tIGhvc3QgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwSG9zdE1vdXNlVG91Y2hFdmVudHModHJ1ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIGFsbCBoZWxwZXIgLyBkZXRlY3Rpb24gZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnRlbnRHbHVlRWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlKF9jb250ZW50R2x1ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfY29udGVudEFycmFuZ2VFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUoX2NvbnRlbnRBcnJhbmdlRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9zaXplQXV0b09ic2VydmVyQWRkZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZShfc2l6ZUF1dG9PYnNlcnZlckVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3JlbW92ZSBhbGwgZ2VuZXJhdGVkIERPTVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU2Nyb2xsYmFyc0RPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckNvcm5lckRPTSh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFN0cnVjdHVyZURPTSh0cnVlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIGdlbmVyYXRlZCBpbWFnZSBsb2FkIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3VwZGF0ZU9uTG9hZEVsbXNbTEVYSUNPTi5sXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksoX3VwZGF0ZU9uTG9hZEVsbXNbaV0pLm9mZihfdXBkYXRlT25Mb2FkRXZlbnROYW1lLCB1cGRhdGVPbkxvYWRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZU9uTG9hZEVsbXMgPSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zbGVlcGluZyA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlIHRoaXMgaW5zdGFuY2UgZnJvbSB0aGUgaW5zdGFuY2VzIGxpc3RcclxuICAgICAgICAgICAgICAgICAgICBJTlNUQU5DRVMocGx1Z2luVGFyZ2V0RWxlbWVudCwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25EZXN0cm95ZWQnKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9yZW1vdmUgYWxsIHByb3BlcnRpZXMgYW5kIG1ldGhvZHNcclxuICAgICAgICAgICAgICAgICAgICAvL2ZvciAodmFyIHByb3BlcnR5IGluIF9iYXNlKVxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIGRlbGV0ZSBfYmFzZVtwcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9fYmFzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTY3JvbGxzIHRvIGEgZ2l2ZW4gcG9zaXRpb24gb3IgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICAgICAgICogMS4gQ2FuIGJlIFwiY29vcmRpbmF0ZXNcIiB3aGljaCBsb29rcyBsaWtlOlxyXG4gICAgICAgICAgICAgICAgICogICAgeyB4IDogPywgeSA6ID8gfSBPUiAgICAgICAgICBPYmplY3Qgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAqICAgIHsgbGVmdCA6ID8sIHRvcCA6ID8gfSBPUiAgICAgT2JqZWN0IHdpdGggbGVmdCBhbmQgdG9wIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAqICAgIHsgbCA6ID8sIHQgOiA/IH0gT1IgICAgICAgICAgT2JqZWN0IHdpdGggbCBhbmQgdCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgKiAgICBbID8sID8gXSBPUiAgICAgICAgICAgICAgICAgIEFycmF5IHdoZXJlIHRoZSBmaXJzdCB0d28gZWxlbWVudCBhcmUgdGhlIGNvb3JkaW5hdGVzIChmaXJzdCBpcyB4LCBzZWNvbmQgaXMgeSlcclxuICAgICAgICAgICAgICAgICAqICAgID8gICAgICAgICAgICAgICAgICAgICAgICAgICAgQSBzaW5nbGUgdmFsdWUgd2hpY2ggc3RheXMgZm9yIGJvdGggYXhpc1xyXG4gICAgICAgICAgICAgICAgICogICAgQSB2YWx1ZSBjYW4gYmUgYSBudW1iZXIsIGEgc3RyaW5nIG9yIGEgY2FsY3VsYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgT3BlcmF0b3JzOlxyXG4gICAgICAgICAgICAgICAgICogICAgW05PTkVdICBUaGUgY3VycmVudCBzY3JvbGwgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnKz0nICAgIFRoZSB2YWx1ZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjdXJyZW50IHNjcm9sbCBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAqICAgICctPScgICAgVGhlIHZhbHVlIHdpbGwgYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBjdXJyZW50IHNjcm9sbCBvZmZzZXRcclxuICAgICAgICAgICAgICAgICAqICAgICcqPScgICAgVGhlIGN1cnJlbnQgc2Nyb2xsIHdpbCBiZSBtdWx0aXBsaWNhdGVkIGJ5IHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqICAgICcvPScgICAgVGhlIGN1cnJlbnQgc2Nyb2xsIHdpbCBiZSBkaXZpZGVkIGJ5IHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBVbml0czpcclxuICAgICAgICAgICAgICAgICAqICAgIFtOT05FXSAgVGhlIHZhbHVlIGlzIHRoZSBmaW5hbCBzY3JvbGwgYW1vdW50LiAgICAgICAgICAgICAgICAgICBmaW5hbCA9ICh2YWx1ZSAqIDEpXHJcbiAgICAgICAgICAgICAgICAgKiAgICAncHgnICAgIFNhbWUgYXMgbm9uZVxyXG4gICAgICAgICAgICAgICAgICogICAgJyUnICAgICBUaGUgdmFsdWUgaXMgZGVwZW5kZW50IG9uIHRoZSBjdXJyZW50IHNjcm9sbCB2YWx1ZS4gICAgIGZpbmFsID0gKChjdXJyZW50U2Nyb2xsVmFsdWUgLyAxMDApICogdmFsdWUpXHJcbiAgICAgICAgICAgICAgICAgKiAgICAndncnICAgIFRoZSB2YWx1ZSBpcyBtdWx0aXBsaWNhdGVkIGJ5IHRoZSB2aWV3cG9ydCB3aWR0aC4gICAgICAgZmluYWwgPSAodmFsdWUgKiB2aWV3cG9ydFdpZHRoKVxyXG4gICAgICAgICAgICAgICAgICogICAgJ3ZoJyAgICBUaGUgdmFsdWUgaXMgbXVsdGlwbGljYXRlZCBieSB0aGUgdmlld3BvcnQgaGVpZ2h0LiAgICAgIGZpbmFsID0gKHZhbHVlICogdmlld3BvcnRIZWlnaHQpXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogICAgZXhhbXBsZSBmaW5hbCB2YWx1ZXM6XHJcbiAgICAgICAgICAgICAgICAgKiAgICAyMDAsICcyMDBweCcsICc1MCUnLCAnMXZ3JywgJzF2aCcsICcrPTIwMCcsICcvPTF2dycsICcqPTJweCcsICctPTV2aCcsICcrPTMzJScsICcrPSA1MCUgLSAycHgnLCAnLT0gMXZ3IC0gNTAlJ1xyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIDIuIENhbiBiZSBhIEhUTUwgb3IgalF1ZXJ5IGVsZW1lbnQ6XHJcbiAgICAgICAgICAgICAgICAgKiAgICBUaGUgZmluYWwgc2Nyb2xsIG9mZnNldCBpcyB0aGUgb2Zmc2V0ICh3aXRob3V0IG1hcmdpbikgb2YgdGhlIGdpdmVuIEhUTUwgLyBqUXVlcnkgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAzLiBDYW4gYmUgYSBvYmplY3Qgd2l0aCBhIEhUTUwgb3IgalF1ZXJ5IGVsZW1lbnQgd2l0aCBhZGRpdGlvbmFsIHNldHRpbmdzOlxyXG4gICAgICAgICAgICAgICAgICogICAge1xyXG4gICAgICAgICAgICAgICAgICogICAgICBlbCA6IFtIVE1MRWxlbWVudCwgalF1ZXJ5IGVsZW1lbnRdLCAgICAgICAgICAgICBNVVNUIGJlIHNwZWNpZmllZCwgZWxzZSB0aGlzIG9iamVjdCBpc24ndCB2YWxpZC5cclxuICAgICAgICAgICAgICAgICAqICAgICAgc2Nyb2xsIDogW3N0cmluZywgYXJyYXksIG9iamVjdF0sICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyAnYWx3YXlzJy5cclxuICAgICAgICAgICAgICAgICAqICAgICAgYmxvY2sgOiBbc3RyaW5nLCBhcnJheSwgb2JqZWN0XSwgICAgICAgICAgICAgICAgRGVmYXVsdCB2YWx1ZSBpcyAnYmVnaW4nLlxyXG4gICAgICAgICAgICAgICAgICogICAgICBtYXJnaW4gOiBbbnVtYmVyLCBib29sZWFuLCBhcnJheSwgb2JqZWN0XSAgICAgICBEZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgICogICAgfVxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIFBvc3NpYmxlIHNjcm9sbCBzZXR0aW5ncyBhcmU6XHJcbiAgICAgICAgICAgICAgICAgKiAgICAnYWx3YXlzJyAgICAgIFNjcm9sbHMgYWx3YXlzLlxyXG4gICAgICAgICAgICAgICAgICogICAgJ2lmbmVlZGVkJyAgICBTY3JvbGxzIG9ubHkgaWYgdGhlIGVsZW1lbnQgaXNudCBmdWxseSBpbiB2aWV3LlxyXG4gICAgICAgICAgICAgICAgICogICAgJ25ldmVyJyAgICAgICBTY3JvbGxzIG5ldmVyLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqICAgIFBvc3NpYmxlIGJsb2NrIHNldHRpbmdzIGFyZTpcclxuICAgICAgICAgICAgICAgICAqICAgICdiZWdpbicgICBCb3RoIGF4aXMgc2hhbGwgYmUgZG9ja2VkIHRvIHRoZSBcImJlZ2luXCIgZWRnZS4gLSBUaGUgZWxlbWVudCB3aWxsIGJlIGRvY2tlZCB0byB0aGUgdG9wIGFuZCBsZWZ0IGVkZ2Ugb2YgdGhlIHZpZXdwb3J0LlxyXG4gICAgICAgICAgICAgICAgICogICAgJ2VuZCcgICAgIEJvdGggYXhpcyBzaGFsbCBiZSBkb2NrZWQgdG8gdGhlIFwiZW5kXCIgZWRnZS4gLSBUaGUgZWxlbWVudCB3aWxsIGJlIGRvY2tlZCB0byB0aGUgYm90dG9tIGFuZCByaWdodCBlZGdlIG9mIHRoZSB2aWV3cG9ydC4gKElmIGRpcmVjdGlvbiBpcyBSVEwgdG8gdGhlIGJvdHRvbSBhbmQgbGVmdCBlZGdlLilcclxuICAgICAgICAgICAgICAgICAqICAgICdjZW50ZXInICBCb3RoIGF4aXMgc2hhbGwgYmUgZG9ja2VkIHRvIFwiY2VudGVyXCIuIC0gVGhlIGVsZW1lbnQgd2lsbCBiZSBjZW50ZXJlZCBpbiB0aGUgdmlld3BvcnQuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAnbmVhcmVzdCcgVGhlIGVsZW1lbnQgd2lsbCBiZSBkb2NrZWQgdG8gdGhlIG5lYXJlc3QgZWRnZShzKS5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiAgICBQb3NzaWJsZSBtYXJnaW4gc2V0dGluZ3MgYXJlOiAtLSBUaGUgYWN0dWFsIG1hcmdpbiBvZiB0aGUgZWxlbWVudCB3b250IGJlIGFmZmVjdCwgdGhpcyBvcHRpb24gYWZmZWN0cyBvbmx5IHRoZSBmaW5hbCBzY3JvbGwgb2Zmc2V0LlxyXG4gICAgICAgICAgICAgICAgICogICAgW0JPT0xFQU5dICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB0cnVlIHRoZSBjc3MgbWFyZ2luIG9mIHRoZSBlbGVtZW50IHdpbGwgYmUgdXNlZCwgaWYgZmFsc2Ugbm8gbWFyZ2luIHdpbGwgYmUgdXNlZC5cclxuICAgICAgICAgICAgICAgICAqICAgIFtOVU1CRVJdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIG1hcmdpbiB3aWxsIGJlIHVzZWQgZm9yIGFsbCBlZGdlcy5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSBzY3JvbGwgYW5pbWF0aW9uLCBPUiBhIGpRdWVyeSBhbmltYXRpb24gY29uZmlndXJhdGlvbiBvYmplY3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZWFzaW5nIFRoZSBhbmltYXRpb24gZWFzaW5nLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGNvbXBsZXRlIFRoZSBhbmltYXRpb24gY29tcGxldGUgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e1xyXG4gICAgICAgICAgICAgICAgICogICBwb3NpdGlvbjoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgcmF0aW86IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sXHJcbiAgICAgICAgICAgICAgICAgKiAgIG1heDoge3g6IG51bWJlciwgeTogbnVtYmVyfSxcclxuICAgICAgICAgICAgICAgICAqICAgaGFuZGxlT2Zmc2V0OiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LFxyXG4gICAgICAgICAgICAgICAgICogICBoYW5kbGVMZW5ndGg6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sXHJcbiAgICAgICAgICAgICAgICAgKiAgIGhhbmRsZUxlbmd0aFJhdGlvOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9LCB0XHJcbiAgICAgICAgICAgICAgICAgKiAgIHJhY2tMZW5ndGg6IHt4OiBudW1iZXIsIHk6IG51bWJlcn0sXHJcbiAgICAgICAgICAgICAgICAgKiAgIGlzUlRMOiBib29sZWFuLFxyXG4gICAgICAgICAgICAgICAgICogICBpc1JUTE5vcm1hbGl6ZWQ6IGJvb2xlYW5cclxuICAgICAgICAgICAgICAgICAqICB9fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5zY3JvbGwgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIGR1cmF0aW9uLCBlYXNpbmcsIGNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgY29vcmRpbmF0ZXMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5mb1ggPSBfc2Nyb2xsSG9yaXpvbnRhbEluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbmZvWSA9IF9zY3JvbGxWZXJ0aWNhbEluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVJbnZlcnQgPSBfbm9ybWFsaXplUlRMQ2FjaGUgJiYgX2lzUlRMICYmIF9ydGxTY3JvbGxCZWhhdmlvci5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplTmVnYXRlID0gX25vcm1hbGl6ZVJUTENhY2hlICYmIF9pc1JUTCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFggPSBpbmZvWC5fY3VycmVudFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFhSYXRpbyA9IGluZm9YLl9jdXJyZW50U2Nyb2xsUmF0aW87XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhTY3JvbGxYID0gaW5mb1guX21heFNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWFJhdGlvID0gbm9ybWFsaXplSW52ZXJ0ID8gMSAtIHNjcm9sbFhSYXRpbyA6IHNjcm9sbFhSYXRpbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCA9IG5vcm1hbGl6ZUludmVydCA/IG1heFNjcm9sbFggLSBzY3JvbGxYIDogc2Nyb2xsWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsWCAqPSBub3JtYWxpemVOZWdhdGUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFNjcm9sbFggKj0gbm9ybWFsaXplTmVnYXRlID8gLTEgOiAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2Nyb2xsWCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5fY3VycmVudFNjcm9sbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGlvOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2Nyb2xsWFJhdGlvLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9jdXJyZW50U2Nyb2xsUmF0aW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBtYXhTY3JvbGxYLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9tYXhTY3JvbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVPZmZzZXQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbmZvWC5faGFuZGxlT2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9oYW5kbGVPZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVMZW5ndGg6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBpbmZvWC5faGFuZGxlTGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGluZm9ZLl9oYW5kbGVMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVMZW5ndGhSYXRpbzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZm9YLl9oYW5kbGVMZW5ndGhSYXRpbyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5faGFuZGxlTGVuZ3RoUmF0aW9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja0xlbmd0aDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGluZm9YLl90cmFja0xlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBpbmZvWS5fdHJhY2tMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbmFwcGVkSGFuZGxlT2Zmc2V0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5mb1guX3NuYXBwZWRIYW5kbGVPZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5mb1kuX3NuYXBwZWRIYW5kbGVPZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JUTDogX2lzUlRMLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSVExOb3JtYWxpemVkOiBfbm9ybWFsaXplUlRMQ2FjaGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9iYXNlLnVwZGF0ZShfc3RyU3luYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxpemVSVEwgPSBfbm9ybWFsaXplUlRMQ2FjaGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzWEF4aXNQcm9wcyA9IFtfc3RyWCwgX3N0ckxlZnQsICdsJ107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzWUF4aXNQcm9wcyA9IFtfc3RyWSwgX3N0clRvcCwgJ3QnXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXNPcGVyYXRvcnMgPSBbJys9JywgJy09JywgJyo9JywgJy89J107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uSXNPYmplY3QgPSB0eXBlKGR1cmF0aW9uKSA9PSBUWVBFUy5vO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wbGV0ZUNhbGxiYWNrID0gZHVyYXRpb25Jc09iamVjdCA/IGR1cmF0aW9uLmNvbXBsZXRlIDogY29tcGxldGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsU2Nyb2xsID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwZWNpYWxFYXNpbmcgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9TY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkb1Njcm9sbFRvcDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyRW5kID0gJ2VuZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckJlZ2luID0gJ2JlZ2luJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyQ2VudGVyID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ck5lYXJlc3QgPSAnbmVhcmVzdCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0ckFsd2F5cyA9ICdhbHdheXMnO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdHJOZXZlciA9ICduZXZlcic7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0cklmTmVlZGVkID0gJ2lmbmVlZGVkJztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RyTGVuZ3RoID0gTEVYSUNPTi5sO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5nc0F4aXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldHRpbmdzU2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5nc0Jsb2NrO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXR0aW5nc01hcmdpbjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50T2JqU2V0dGluZ3NBeGlzVmFsdWVzID0gW19zdHJYLCBfc3RyWSwgJ3h5JywgJ3l4J107XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRPYmpTZXR0aW5nc0Jsb2NrVmFsdWVzID0gW3N0ckJlZ2luLCBzdHJFbmQsIHN0ckNlbnRlciwgc3RyTmVhcmVzdF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRPYmpTZXR0aW5nc1Njcm9sbFZhbHVlcyA9IFtzdHJBbHdheXMsIHN0ck5ldmVyLCBzdHJJZk5lZWRlZF07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID0gY29vcmRpbmF0ZXNbTEVYSUNPTi5oT1BdKCdlbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUVsZW1lbnQgPSBjb29yZGluYXRlc0lzRWxlbWVudE9iaiA/IGNvb3JkaW5hdGVzLmVsIDogY29vcmRpbmF0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3NpYmxlRWxlbWVudElzSlF1ZXJ5ID0gcG9zc2libGVFbGVtZW50IGluc3RhbmNlb2YgRlJBTUVXT1JLIHx8IEpRVUVSWSA/IHBvc3NpYmxlRWxlbWVudCBpbnN0YW5jZW9mIEpRVUVSWSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3NzaWJsZUVsZW1lbnRJc0hUTUxFbGVtZW50ID0gcG9zc2libGVFbGVtZW50SXNKUXVlcnkgPyBmYWxzZSA6IGlzSFRNTEVsZW1lbnQocG9zc2libGVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlU2Nyb2xsYmFySW5mb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1Njcm9sbExlZnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9TY3JvbGxUb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZyZXNoU2Nyb2xsYmFySGFuZGxlT2Zmc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm94eUNvbXBsZXRlQ2FsbGJhY2sgPSB0eXBlKGNvbXBsZXRlQ2FsbGJhY2spICE9IFRZUEVTLmYgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVNjcm9sbGJhckluZm9zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrU2V0dGluZ3NTdHJpbmdWYWx1ZShjdXJyVmFsdWUsIGFsbG93ZWRWYWx1ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbG93ZWRWYWx1ZXNbc3RyTGVuZ3RoXTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyclZhbHVlID09PSBhbGxvd2VkVmFsdWVzW2ldKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UmF3U2Nyb2xsKGlzWCwgY29vcmRpbmF0ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVQcm9wcyA9IGlzWCA/IGNvb3JkaW5hdGVzWEF4aXNQcm9wcyA6IGNvb3JkaW5hdGVzWUF4aXNQcm9wcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSB0eXBlKGNvb3JkaW5hdGVzKSA9PSBUWVBFUy5zIHx8IHR5cGUoY29vcmRpbmF0ZXMpID09IFRZUEVTLm4gPyBbY29vcmRpbmF0ZXMsIGNvb3JkaW5hdGVzXSA6IGNvb3JkaW5hdGVzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKENPTVBBVElCSUxJVFkuaXNBKGNvb3JkaW5hdGVzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1ggPyBjb29yZGluYXRlc1swXSA6IGNvb3JkaW5hdGVzWzFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlKGNvb3JkaW5hdGVzKSA9PSBUWVBFUy5vKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2RlY2lkZXMgUlRMIG5vcm1hbGl6YXRpb24gXCJoYWNrXCIgd2l0aCAublxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9ub3JtYWxpemVSVEwgPSB0eXBlKGNvb3JkaW5hdGVzLm4pID09IFRZUEVTLmIgPyBjb29yZGluYXRlcy5uIDogbm9ybWFsaXplUlRMOyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb29yZGluYXRlUHJvcHNbc3RyTGVuZ3RoXTsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb29yZGluYXRlUHJvcHNbaV0gaW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb29yZGluYXRlc1tjb29yZGluYXRlUHJvcHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldEZpbmFsU2Nyb2xsKGlzWCwgcmF3U2Nyb2xsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc1N0cmluZyA9IHR5cGUocmF3U2Nyb2xsKSA9PSBUWVBFUy5zO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxJbmZvID0gaXNYID8gX3Njcm9sbEhvcml6b250YWxJbmZvIDogX3Njcm9sbFZlcnRpY2FsSW5mbztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJTY3JvbGwgPSBzY3JvbGxJbmZvLl9jdXJyZW50U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4U2Nyb2xsID0gc2Nyb2xsSW5mby5fbWF4U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdCA9ICcgKiAnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzUlRMaXNYID0gX2lzUlRMICYmIGlzWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZVNob3J0Y3V0cyA9IGlzUlRMaXNYICYmIF9ydGxTY3JvbGxCZWhhdmlvci5uICYmICFub3JtYWxpemVSVEw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHJSZXBsYWNlID0gJ3JlcGxhY2UnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZhbEZ1bmMgPSBldmFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zc2libGVPcGVyYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NoZWNrIG9wZXJhdG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmF3U2Nyb2xsW3N0ckxlbmd0aF0gPiAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zc2libGVPcGVyYXRvciA9IHJhd1Njcm9sbC5zdWJzdHIoMCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluQXJyYXkocG9zc2libGVPcGVyYXRvciwgY29vcmRpbmF0ZXNPcGVyYXRvcnMpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yID0gcG9zc2libGVPcGVyYXRvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSB1bml0cyBhbmQgc2hvcnRjdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdTY3JvbGwgPSBvcGVyYXRvciA/IHJhd1Njcm9sbC5zdWJzdHIoMikgOiByYXdTY3JvbGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdTY3JvbGwgPSByYXdTY3JvbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvbWluL2csIDApIC8vJ21pbicgPSAwJVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC88L2csIDApICAgLy8nPCcgICA9IDAlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oL21heC9nLCAobm9ybWFsaXplU2hvcnRjdXRzID8gJy0nIDogX3N0ckVtcHR5KSArIF9zdHJIdW5kcmVkUGVyY2VudCkgICAgLy8nbWF4JyA9IDEwMCVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzdHJSZXBsYWNlXSgvPi9nLCAobm9ybWFsaXplU2hvcnRjdXRzID8gJy0nIDogX3N0ckVtcHR5KSArIF9zdHJIdW5kcmVkUGVyY2VudCkgICAgICAvLyc+JyAgID0gMTAwJVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC9weC9nLCBfc3RyRW1wdHkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc3RyUmVwbGFjZV0oLyUvZywgbXVsdCArIChtYXhTY3JvbGwgKiAoaXNSVExpc1ggJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm4gPyAtMSA6IDEpIC8gMTAwLjApKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC92dy9nLCBtdWx0ICsgX3ZpZXdwb3J0U2l6ZS53KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3N0clJlcGxhY2VdKC92aC9nLCBtdWx0ICsgX3ZpZXdwb3J0U2l6ZS5oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IHBhcnNlVG9aZXJvT3JOdW1iZXIoaXNOYU4ocmF3U2Nyb2xsKSA/IHBhcnNlVG9aZXJvT3JOdW1iZXIoZXZhbEZ1bmMocmF3U2Nyb2xsKSwgdHJ1ZSkudG9GaXhlZCgpIDogcmF3U2Nyb2xsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudCA9IHJhd1Njcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFtb3VudCAhPT0gdW5kZWZpbmVkICYmICFpc05hTihhbW91bnQpICYmIHR5cGUoYW1vdW50KSA9PSBUWVBFUy5uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsaXplSXNSVExpc1ggPSBub3JtYWxpemVSVEwgJiYgaXNSVExpc1g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3BlcmF0b3JDdXJyU2Nyb2xsID0gY3VyclNjcm9sbCAqIChub3JtYWxpemVJc1JUTGlzWCAmJiBfcnRsU2Nyb2xsQmVoYXZpb3IubiA/IC0xIDogMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW52ZXJ0ID0gbm9ybWFsaXplSXNSVExpc1ggJiYgX3J0bFNjcm9sbEJlaGF2aW9yLmk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVnYXRlID0gbm9ybWFsaXplSXNSVExpc1ggJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRvckN1cnJTY3JvbGwgPSBpbnZlcnQgPyAobWF4U2Nyb2xsIC0gb3BlcmF0b3JDdXJyU2Nyb2xsKSA6IG9wZXJhdG9yQ3VyclNjcm9sbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcrPSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBvcGVyYXRvckN1cnJTY3JvbGwgKyBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJy09JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IG9wZXJhdG9yQ3VyclNjcm9sbCAtIGFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnKj0nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gb3BlcmF0b3JDdXJyU2Nyb2xsICogYW1vdW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcvPSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBvcGVyYXRvckN1cnJTY3JvbGwgLyBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsVmFsdWUgPSBhbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSA9IGludmVydCA/IG1heFNjcm9sbCAtIGZpbmFsVmFsdWUgOiBmaW5hbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxWYWx1ZSAqPSBuZWdhdGUgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFZhbHVlID0gaXNSVExpc1ggJiYgX3J0bFNjcm9sbEJlaGF2aW9yLm4gPyBNQVRILm1pbigwLCBNQVRILm1heChtYXhTY3JvbGwsIGZpbmFsVmFsdWUpKSA6IE1BVEgubWF4KDAsIE1BVEgubWluKG1heFNjcm9sbCwgZmluYWxWYWx1ZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmaW5hbFZhbHVlID09PSBjdXJyU2Nyb2xsID8gdW5kZWZpbmVkIDogZmluYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0UGVyQXhpc1ZhbHVlKHZhbHVlLCB2YWx1ZUludGVybmFsVHlwZSwgZGVmYXVsdFZhbHVlLCBhbGxvd2VkVmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHREZWZhdWx0ID0gW2RlZmF1bHRWYWx1ZSwgZGVmYXVsdFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlVHlwZSA9IHR5cGUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWVBcnJMZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUFyckl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3ZhbHVlIGNhbiBiZSBbIHN0cmluZywgb3IgYXJyYXkgb2YgdHdvIHN0cmluZ3MgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVUeXBlID09IHZhbHVlSW50ZXJuYWxUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZSwgdmFsdWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlVHlwZSA9PSBUWVBFUy5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUFyckxlbmd0aCA9IHZhbHVlW3N0ckxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVBcnJMZW5ndGggPiAyIHx8IHZhbHVlQXJyTGVuZ3RoIDwgMSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlc3VsdERlZmF1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVBcnJMZW5ndGggPT09IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlWzFdID0gZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZUFyckxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlQXJySXRlbSA9IHZhbHVlW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSh2YWx1ZUFyckl0ZW0pICE9IHZhbHVlSW50ZXJuYWxUeXBlIHx8ICFjaGVja1NldHRpbmdzU3RyaW5nVmFsdWUodmFsdWVBcnJJdGVtLCBhbGxvd2VkVmFsdWVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHREZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVUeXBlID09IFRZUEVTLm8pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IFt2YWx1ZVtfc3RyWF0gfHwgZGVmYXVsdFZhbHVlLCB2YWx1ZVtfc3RyWV0gfHwgZGVmYXVsdFZhbHVlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXN1bHREZWZhdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB4OiB2YWx1ZVswXSwgeTogdmFsdWVbMV0gfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVNYXJnaW4obWFyZ2luVG9wUmlnaHRCb3R0b21MZWZ0QXJyYXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyclZhbHVlVHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlRGlyZWN0aW9ucyA9IFtfc3RyVG9wLCBfc3RyUmlnaHQsIF9zdHJCb3R0b20sIF9zdHJMZWZ0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hcmdpblRvcFJpZ2h0Qm90dG9tTGVmdEFycmF5W3N0ckxlbmd0aF07IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHZhbHVlRGlyZWN0aW9uc1tzdHJMZW5ndGhdKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyclZhbHVlID0gbWFyZ2luVG9wUmlnaHRCb3R0b21MZWZ0QXJyYXlbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyVmFsdWVUeXBlID0gdHlwZShjdXJyVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJWYWx1ZVR5cGUgPT0gVFlQRVMuYilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXJyVmFsdWUgPyBwYXJzZVRvWmVyb09yTnVtYmVyKGZpbmFsRWxlbWVudC5jc3MoX3N0ck1hcmdpbk1pbnVzICsgdmFsdWVEaXJlY3Rpb25zW2ldKSkgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXJyVmFsdWVUeXBlID09IFRZUEVTLm4gPyBjdXJyVmFsdWUgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3NpYmxlRWxlbWVudElzSlF1ZXJ5IHx8IHBvc3NpYmxlRWxlbWVudElzSFRNTEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9nZXQgc2V0dGluZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpbiA9IGNvb3JkaW5hdGVzSXNFbGVtZW50T2JqID8gY29vcmRpbmF0ZXMubWFyZ2luIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF4aXMgPSBjb29yZGluYXRlc0lzRWxlbWVudE9iaiA/IGNvb3JkaW5hdGVzLmF4aXMgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gY29vcmRpbmF0ZXNJc0VsZW1lbnRPYmogPyBjb29yZGluYXRlcy5zY3JvbGwgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBjb29yZGluYXRlc0lzRWxlbWVudE9iaiA/IGNvb3JkaW5hdGVzLmJsb2NrIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hcmdpbkRlZmF1bHQgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXJnaW5UeXBlID0gdHlwZShtYXJnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFyZ2luTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEVsZW1lbnQgPSBwb3NzaWJsZUVsZW1lbnRJc0pRdWVyeSA/IHBvc3NpYmxlRWxlbWVudCA6IEZSQU1FV09SSyhwb3NzaWJsZUVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsRWxlbWVudFtzdHJMZW5ndGhdID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9tYXJnaW4gY2FuIGJlIFsgYm9vbGVhbiwgbnVtYmVyLCBhcnJheSBvZiAyLCBhcnJheSBvZiA0LCBvYmplY3QgXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmdpblR5cGUgPT0gVFlQRVMubiB8fCBtYXJnaW5UeXBlID09IFRZUEVTLmIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gZ2VuZXJhdGVNYXJnaW4oW21hcmdpbiwgbWFyZ2luLCBtYXJnaW4sIG1hcmdpbl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWFyZ2luVHlwZSA9PSBUWVBFUy5hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVuZ3RoID0gbWFyZ2luW3N0ckxlbmd0aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmdpbkxlbmd0aCA9PT0gMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gZ2VuZXJhdGVNYXJnaW4oW21hcmdpblswXSwgbWFyZ2luWzFdLCBtYXJnaW5bMF0sIG1hcmdpblsxXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcmdpbkxlbmd0aCA+PSA0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBnZW5lcmF0ZU1hcmdpbihtYXJnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gbWFyZ2luRGVmYXVsdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hcmdpblR5cGUgPT0gVFlQRVMubylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW4gPSBnZW5lcmF0ZU1hcmdpbihbbWFyZ2luW19zdHJUb3BdLCBtYXJnaW5bX3N0clJpZ2h0XSwgbWFyZ2luW19zdHJCb3R0b21dLCBtYXJnaW5bX3N0ckxlZnRdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luID0gbWFyZ2luRGVmYXVsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Jsb2NrID0gdHlwZShibG9jaykgPT09IFRZUEVTLmIgPyBibG9jayA/IFsgc3RyTmVhcmVzdCwgc3RyQmVnaW4gXSA6IFsgc3RyTmVhcmVzdCwgc3RyRW5kIF0gOiBibG9jaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQXhpcyA9IGNoZWNrU2V0dGluZ3NTdHJpbmdWYWx1ZShheGlzLCBlbGVtZW50T2JqU2V0dGluZ3NBeGlzVmFsdWVzKSA/IGF4aXMgOiAneHknO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NTY3JvbGwgPSBnZXRQZXJBeGlzVmFsdWUoc2Nyb2xsLCBUWVBFUy5zLCBzdHJBbHdheXMsIGVsZW1lbnRPYmpTZXR0aW5nc1Njcm9sbFZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Jsb2NrID0gZ2V0UGVyQXhpc1ZhbHVlKGJsb2NrLCBUWVBFUy5zLCBzdHJCZWdpbiwgZWxlbWVudE9ialNldHRpbmdzQmxvY2tWYWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NNYXJnaW4gPSBtYXJnaW47XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0U2Nyb2xsID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGw6IF9zY3JvbGxIb3Jpem9udGFsSW5mby5fY3VycmVudFNjcm9sbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0OiBfc2Nyb2xsVmVydGljYWxJbmZvLl9jdXJyZW50U2Nyb2xsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHBhZGRpbmcgZWxlbWVudCBpbnN0ZWFkIG9mIHZpZXdwb3J0IGVsZW1lbnQgYmVjYXVzZSBwYWRkaW5nIGVsZW1lbnQgaGFzIG5ldmVyIHBhZGRpbmcsIG1hcmdpbiBvciBwb3NpdGlvbiBhcHBsaWVkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0ID0gX3BhZGRpbmdFbGVtZW50Lm9mZnNldCgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZ2V0IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudE9mZnNldCA9IGZpbmFsRWxlbWVudC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb05vdFNjcm9sbCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZXR0aW5nc1Njcm9sbC54ID09IHN0ck5ldmVyIHx8IHNldHRpbmdzQXhpcyA9PSBfc3RyWSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZXR0aW5nc1Njcm9sbC55ID09IHN0ck5ldmVyIHx8IHNldHRpbmdzQXhpcyA9PSBfc3RyWFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRPZmZzZXRbX3N0clRvcF0gLT0gc2V0dGluZ3NNYXJnaW5bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50T2Zmc2V0W19zdHJMZWZ0XSAtPSBzZXR0aW5nc01hcmdpblszXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogTUFUSC5yb3VuZChlbGVtZW50T2Zmc2V0W19zdHJMZWZ0XSAtIHZpZXdwb3J0T2Zmc2V0W19zdHJMZWZ0XSArIHZpZXdwb3J0U2Nyb2xsLmwpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1BVEgucm91bmQoZWxlbWVudE9mZnNldFtfc3RyVG9wXSAtIHZpZXdwb3J0T2Zmc2V0W19zdHJUb3BdICsgdmlld3BvcnRTY3JvbGwudClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2lzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfcnRsU2Nyb2xsQmVoYXZpb3IubiAmJiAhX3J0bFNjcm9sbEJlaGF2aW9yLmkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcy54ID0gTUFUSC5yb3VuZCh2aWV3cG9ydE9mZnNldFtfc3RyTGVmdF0gLSBlbGVtZW50T2Zmc2V0W19zdHJMZWZ0XSArIHZpZXdwb3J0U2Nyb2xsLmwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcnRsU2Nyb2xsQmVoYXZpb3IubiAmJiBub3JtYWxpemVSVEwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcy54ICo9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcnRsU2Nyb2xsQmVoYXZpb3IuaSAmJiBub3JtYWxpemVSVEwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTY3JvbGxDb29yZGluYXRlcy54ID0gTUFUSC5yb3VuZCh2aWV3cG9ydE9mZnNldFtfc3RyTGVmdF0gLSBlbGVtZW50T2Zmc2V0W19zdHJMZWZ0XSArIChfc2Nyb2xsSG9yaXpvbnRhbEluZm8uX21heFNjcm9sbCAtIHZpZXdwb3J0U2Nyb2xsLmwpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL21lYXN1cmluZyBpcyByZXF1aXJlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQmxvY2sueCAhPSBzdHJCZWdpbiB8fCBzZXR0aW5nc0Jsb2NrLnkgIT0gc3RyQmVnaW4gfHwgc2V0dGluZ3NTY3JvbGwueCA9PSBzdHJJZk5lZWRlZCB8fCBzZXR0aW5nc1Njcm9sbC55ID09IHN0cklmTmVlZGVkIHx8IF9pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZWFzdXJpbmdFbG0gPSBmaW5hbEVsZW1lbnRbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0VsZW1lbnRTaXplID0gX3N1cHBvcnRUcmFuc2Zvcm0gPyBtZWFzdXJpbmdFbG1bTEVYSUNPTi5iQ1JdKCkgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtZWFzdXJpbmdFbG1bTEVYSUNPTi5vV10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbWVhc3VyaW5nRWxtW0xFWElDT04ub0hdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFNpemUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHc6IHJhd0VsZW1lbnRTaXplW19zdHJXaWR0aF0gKyBzZXR0aW5nc01hcmdpblszXSArIHNldHRpbmdzTWFyZ2luWzFdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoOiByYXdFbGVtZW50U2l6ZVtfc3RySGVpZ2h0XSArIHNldHRpbmdzTWFyZ2luWzBdICsgc2V0dGluZ3NNYXJnaW5bMl1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaW5hbGl6ZUJsb2NrID0gZnVuY3Rpb24gKGlzWCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFycyA9IGdldFNjcm9sbGJhclZhcnMoaXNYKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdoID0gdmFycy5fd19oO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbHQgPSB2YXJzLl9sZWZ0X3RvcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHh5ID0gdmFycy5feF95O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tJc0VuZCA9IHNldHRpbmdzQmxvY2tbeHldID09IChpc1ggPyBfaXNSVEwgPyBzdHJCZWdpbiA6IHN0ckVuZCA6IHN0ckVuZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja0lzQ2VudGVyID0gc2V0dGluZ3NCbG9ja1t4eV0gPT0gc3RyQ2VudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tJc05lYXJlc3QgPSBzZXR0aW5nc0Jsb2NrW3h5XSA9PSBzdHJOZWFyZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsTmV2ZXIgPSBzZXR0aW5nc1Njcm9sbFt4eV0gPT0gc3RyTmV2ZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3JvbGxJZk5lZWRlZCA9IHNldHRpbmdzU2Nyb2xsW3h5XSA9PSBzdHJJZk5lZWRlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZwU2l6ZSA9IF92aWV3cG9ydFNpemVbd2hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdnBPZmZzZXQgPSB2aWV3cG9ydE9mZnNldFtsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbFNpemUgPSBlbGVtZW50U2l6ZVt3aF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbE9mZnNldCA9IGVsZW1lbnRPZmZzZXRbbHRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGl2aWRlID0gYmxvY2tJc0NlbnRlciA/IDIgOiAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudENlbnRlck9mZnNldCA9IGVsT2Zmc2V0ICsgKGVsU2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmlld3BvcnRDZW50ZXJPZmZzZXQgPSB2cE9mZnNldCArICh2cFNpemUgLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzSW5WaWV3ID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsU2l6ZSA8PSB2cFNpemVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIGVsT2Zmc2V0ID49IHZwT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiBlbE9mZnNldCArIGVsU2l6ZSA8PSB2cE9mZnNldCArIHZwU2l6ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxOZXZlcilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvTm90U2Nyb2xsW3h5XSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkb05vdFNjcm9sbFt4eV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja0lzTmVhcmVzdCB8fCBzY3JvbGxJZk5lZWRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvTm90U2Nyb2xsW3h5XSA9IHNjcm9sbElmTmVlZGVkID8gaXNJblZpZXcgOiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0lzRW5kID0gZWxTaXplIDwgdnBTaXplID8gZWxlbWVudENlbnRlck9mZnNldCA+IHZpZXdwb3J0Q2VudGVyT2Zmc2V0IDogZWxlbWVudENlbnRlck9mZnNldCA8IHZpZXdwb3J0Q2VudGVyT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzW3h5XSAtPSBibG9ja0lzRW5kIHx8IGJsb2NrSXNDZW50ZXIgPyAoKHZwU2l6ZSAvIGRpdmlkZSkgLSAoZWxTaXplIC8gZGl2aWRlKSkgKiAoaXNYICYmIF9pc1JUTCAmJiBub3JtYWxpemVSVEwgPyAtMSA6IDEpIDogMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxpemVCbG9jayh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZUJsb2NrKGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9Ob3RTY3JvbGwueSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9Ob3RTY3JvbGwueClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudFNjcm9sbENvb3JkaW5hdGVzLng7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMgPSBlbGVtZW50U2Nyb2xsQ29vcmRpbmF0ZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxMZWZ0XSA9IGdldEZpbmFsU2Nyb2xsKHRydWUsIGdldFJhd1Njcm9sbCh0cnVlLCBjb29yZGluYXRlcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxUb3BdID0gZ2V0RmluYWxTY3JvbGwoZmFsc2UsIGdldFJhd1Njcm9sbChmYWxzZSwgY29vcmRpbmF0ZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICBkb1Njcm9sbExlZnQgPSBmaW5hbFNjcm9sbFtfc3RyU2Nyb2xsTGVmdF0gIT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBkb1Njcm9sbFRvcCA9IGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxUb3BdICE9PSB1bmRlZmluZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoZG9TY3JvbGxMZWZ0IHx8IGRvU2Nyb2xsVG9wKSAmJiAoZHVyYXRpb24gPiAwIHx8IGR1cmF0aW9uSXNPYmplY3QpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbklzT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbi5jb21wbGV0ZSA9IHByb3h5Q29tcGxldGVDYWxsYmFjaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuYW5pbWF0ZShmaW5hbFNjcm9sbCwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IHByb3h5Q29tcGxldGVDYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLmlzQShlYXNpbmcpIHx8IEZSQU1FV09SSy5pc1BsYWluT2JqZWN0KGVhc2luZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nW19zdHJTY3JvbGxMZWZ0XSA9IGVhc2luZ1swXSB8fCBlYXNpbmcueDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjaWFsRWFzaW5nW19zdHJTY3JvbGxUb3BdID0gZWFzaW5nWzFdIHx8IGVhc2luZy55O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMuc3BlY2lhbEVhc2luZyA9IHNwZWNpYWxFYXNpbmc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmVhc2luZyA9IGVhc2luZztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnQuYW5pbWF0ZShmaW5hbFNjcm9sbCwgYW5pbWF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb1Njcm9sbExlZnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XShmaW5hbFNjcm9sbFtfc3RyU2Nyb2xsTGVmdF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9TY3JvbGxUb3ApXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50W19zdHJTY3JvbGxUb3BdKGZpbmFsU2Nyb2xsW19zdHJTY3JvbGxUb3BdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlU2Nyb2xsYmFySW5mb3MoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogU3RvcHMgYWxsIHNjcm9sbCBhbmltYXRpb25zLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMgeyp9IFRoZSBjdXJyZW50IE92ZXJsYXlTY3JvbGxiYXJzIGluc3RhbmNlIChmb3IgY2hhaW5pbmcpLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5zY3JvbGxTdG9wID0gZnVuY3Rpb24gKHBhcmFtMSwgcGFyYW0yLCBwYXJhbTMpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LnN0b3AocGFyYW0xLCBwYXJhbTIsIHBhcmFtMyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9iYXNlO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFJldHVybnMgYWxsIHJlbGV2YW50IGVsZW1lbnRzLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGVsZW1lbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBlbGVtZW50IHdoaWNoIHNoYWxsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t0YXJnZXQ6ICosIGhvc3Q6ICosIHBhZGRpbmc6ICosIHZpZXdwb3J0OiAqLCBjb250ZW50OiAqLCBzY3JvbGxiYXJIb3Jpem9udGFsOiB7c2Nyb2xsYmFyOiAqLCB0cmFjazogKiwgaGFuZGxlOiAqfSwgc2Nyb2xsYmFyVmVydGljYWw6IHtzY3JvbGxiYXI6ICosIHRyYWNrOiAqLCBoYW5kbGU6ICp9LCBzY3JvbGxiYXJDb3JuZXI6ICp9IHwgKn1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IF90YXJnZXRFbGVtZW50TmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBfaG9zdEVsZW1lbnROYXRpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IF9wYWRkaW5nRWxlbWVudE5hdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQ6IF92aWV3cG9ydEVsZW1lbnROYXRpdmUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IF9jb250ZW50RWxlbWVudE5hdGl2ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFySG9yaXpvbnRhbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyOiBfc2Nyb2xsYmFySG9yaXpvbnRhbEVsZW1lbnRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjazogX3Njcm9sbGJhckhvcml6b250YWxUcmFja0VsZW1lbnRbMF0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGU6IF9zY3JvbGxiYXJIb3Jpem9udGFsSGFuZGxlRWxlbWVudFswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJWZXJ0aWNhbDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nyb2xsYmFyOiBfc2Nyb2xsYmFyVmVydGljYWxFbGVtZW50WzBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2s6IF9zY3JvbGxiYXJWZXJ0aWNhbFRyYWNrRWxlbWVudFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZTogX3Njcm9sbGJhclZlcnRpY2FsSGFuZGxlRWxlbWVudFswXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxiYXJDb3JuZXI6IF9zY3JvbGxiYXJDb3JuZXJFbGVtZW50WzBdXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZShlbGVtZW50TmFtZSkgPT0gVFlQRVMucyA/IGdldE9iamVjdFByb3BWYWwob2JqLCBlbGVtZW50TmFtZSkgOiBvYmo7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogUmV0dXJucyBhIG9iamVjdCB3aGljaCBkZXNjcmliZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBzdGF0ZVByb3BlcnR5IEEgc3BlY2lmaWMgcHJvcGVydHkgZnJvbSB0aGUgc3RhdGUgb2JqZWN0IHdoaWNoIHNoYWxsIGJlIHJldHVybmVkLlxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3t3aWR0aEF1dG8sIGhlaWdodEF1dG8sIG92ZXJmbG93QW1vdW50LCBoaWRlT3ZlcmZsb3csIGhhc092ZXJmbG93LCBjb250ZW50U2Nyb2xsU2l6ZSwgdmlld3BvcnRTaXplLCBob3N0U2l6ZSwgYXV0b1VwZGF0ZX0gfCAqfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZVByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJlcGFyZShvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFGUkFNRVdPUksuaXNQbGFpbk9iamVjdChvYmopKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dGVuZGVkID0gZXh0ZW5kRGVlcCh7fSwgb2JqKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkW0xFWElDT04uaE9QXShmcm9tKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkW3RvXSA9IGV4dGVuZGVkW2Zyb21dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBleHRlbmRlZFtmcm9tXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlUHJvcGVydHlOYW1lKCd3JywgX3N0cldpZHRoKTsgLy9jaGFuZ2UgdyB0byB3aWR0aFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VQcm9wZXJ0eU5hbWUoJ2gnLCBfc3RySGVpZ2h0KTsgLy9jaGFuZ2UgaCB0byBoZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV4dGVuZGVkLmM7IC8vZGVsZXRlIGMgKHRoZSAnY2hhbmdlZCcgcHJvcClcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4dGVuZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdHJveWVkOiAhIXByZXBhcmUoX2Rlc3Ryb3llZCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsZWVwaW5nOiAhIXByZXBhcmUoX3NsZWVwaW5nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0b1VwZGF0ZTogcHJlcGFyZSghX211dGF0aW9uT2JzZXJ2ZXJzQ29ubmVjdGVkKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGhBdXRvOiBwcmVwYXJlKF93aWR0aEF1dG9DYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodEF1dG86IHByZXBhcmUoX2hlaWdodEF1dG9DYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IHByZXBhcmUoX2Nzc1BhZGRpbmdDYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93QW1vdW50OiBwcmVwYXJlKF9vdmVyZmxvd0Ftb3VudENhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZU92ZXJmbG93OiBwcmVwYXJlKF9oaWRlT3ZlcmZsb3dDYWNoZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc092ZXJmbG93OiBwcmVwYXJlKF9oYXNPdmVyZmxvd0NhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudFNjcm9sbFNpemU6IHByZXBhcmUoX2NvbnRlbnRTY3JvbGxTaXplQ2FjaGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3cG9ydFNpemU6IHByZXBhcmUoX3ZpZXdwb3J0U2l6ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3RTaXplOiBwcmVwYXJlKF9ob3N0U2l6ZUNhY2hlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnRNaXhlZDogcHJlcGFyZShfZG9jdW1lbnRNaXhlZClcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlKHN0YXRlUHJvcGVydHkpID09IFRZUEVTLnMgPyBnZXRPYmplY3RQcm9wVmFsKG9iaiwgc3RhdGVQcm9wZXJ0eSkgOiBvYmo7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogR2V0cyBhbGwgb3Igc3BlY2lmaWMgZXh0ZW5zaW9uIGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4dE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4dGVuc2lvbiBmcm9tIHdoaWNoIHRoZSBpbnN0YW5jZSBzaGFsbCBiZSBnb3QuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e319IFRoZSBpbnN0YW5jZSBvZiB0aGUgZXh0ZW5zaW9uIHdpdGggdGhlIGdpdmVuIG5hbWUgb3IgdW5kZWZpbmVkIGlmIHRoZSBpbnN0YW5jZSBjb3VsZG4ndCBiZSBmb3VuZC5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UuZXh0ID0gZnVuY3Rpb24gKGV4dE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcml2YXRlTWV0aG9kcyA9IF9leHRlbnNpb25zUHJpdmF0ZU1ldGhvZHMuc3BsaXQoJyAnKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoZXh0TmFtZSkgPT0gVFlQRVMucykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2V4dGVuc2lvbnNbTEVYSUNPTi5oT1BdKGV4dE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBleHRlbmREZWVwKHt9LCBfZXh0ZW5zaW9uc1tleHROYW1lXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IHByaXZhdGVNZXRob2RzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbcHJpdmF0ZU1ldGhvZHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIF9leHRlbnNpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gZXh0ZW5kRGVlcCh7fSwgX2Jhc2UuZXh0KGkpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBBZGRzIGEgZXh0ZW5zaW9uIHRvIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gZXh0TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIHdoaWNoIHNoYWxsIGJlIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbk9wdGlvbnMgVGhlIGV4dGVuc2lvbiBvcHRpb25zIHdoaWNoIHNoYWxsIGJlIHVzZWQuXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e319IFRoZSBpbnN0YW5jZSBvZiB0aGUgYWRkZWQgZXh0ZW5zaW9uIG9yIHVuZGVmaW5lZCBpZiB0aGUgZXh0ZW5zaW9uIGNvdWxkbid0IGJlIGFkZGVkIHByb3Blcmx5LlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBfYmFzZS5hZGRFeHQgPSBmdW5jdGlvbiAoZXh0TmFtZSwgZXh0ZW5zaW9uT3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWdpc3RlcmVkRXh0ZW5zaW9uT2JqID0gX3BsdWdpbi5leHRlbnNpb24oZXh0TmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUFkZGVkO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZUNvbnRyYWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb250cmFjdFJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJhY3RGdWxmaWxsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkRXh0ZW5zaW9uT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2V4dGVuc2lvbnNbTEVYSUNPTi5oT1BdKGV4dE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IHJlZ2lzdGVyZWRFeHRlbnNpb25PYmouZXh0ZW5zaW9uRmFjdG9yeS5jYWxsKF9iYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZERlZXAoe30sIHJlZ2lzdGVyZWRFeHRlbnNpb25PYmouZGVmYXVsdE9wdGlvbnMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZSQU1FV09SSyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDT01QQVRJQklMSVRZKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUNvbnRyYWN0ID0gaW5zdGFuY2UuY29udHJhY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoaW5zdGFuY2VDb250cmFjdCkgPT0gVFlQRVMuZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdFJlc3VsdCA9IGluc3RhbmNlQ29udHJhY3Qod2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3RGdWxmaWxsZWQgPSB0eXBlKGNvbnRyYWN0UmVzdWx0KSA9PSBUWVBFUy5iID8gY29udHJhY3RSZXN1bHQgOiBjb250cmFjdEZ1bGZpbGxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyYWN0RnVsZmlsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbnNpb25zW2V4dE5hbWVdID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlQWRkZWQgPSBpbnN0YW5jZS5hZGRlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoaW5zdGFuY2VBZGRlZCkgPT0gVFlQRVMuZilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlQWRkZWQoZXh0ZW5zaW9uT3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2UuZXh0KGV4dE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2UuZXh0KGV4dE5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkEgZXh0ZW5zaW9uIHdpdGggdGhlIG5hbWUgXFxcIlwiICsgZXh0TmFtZSArIFwiXFxcIiBpc24ndCByZWdpc3RlcmVkLlwiKTtcclxuICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmVzIGEgZXh0ZW5zaW9uIGZyb20gdGhpcyBpbnN0YW5jZS5cclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBleHROYW1lIFRoZSBuYW1lIG9mIHRoZSBleHRlbnNpb24gd2hpY2ggc2hhbGwgYmUgcmVtb3ZlZC5cclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBleHRlbnNpb24gd2FzIHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZSBlLmcuIGlmIHRoZSBleHRlbnNpb24gd2Fzbid0IGFkZGVkIGJlZm9yZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgX2Jhc2UucmVtb3ZlRXh0ID0gZnVuY3Rpb24gKGV4dE5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBfZXh0ZW5zaW9uc1tleHROYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VSZW1vdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX2V4dGVuc2lvbnNbZXh0TmFtZV07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVJlbW92ZWQgPSBpbnN0YW5jZS5yZW1vdmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZShpbnN0YW5jZVJlbW92ZWQpID09IFRZUEVTLmYpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVJlbW92ZWQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ29uc3RydWN0cyB0aGUgcGx1Z2luLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHBsdWdpbiBzaGFsbCBiZSBhcHBsaWVkLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGluaXRpYWwgb3B0aW9ucyBvZiB0aGUgcGx1Z2luLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbihzKSB3aGljaCBzaGFsbCBiZSBhZGRlZCByaWdodCBhZnRlciB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcGx1Z2luIHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhbGl6ZWQsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29uc3RydWN0KHRhcmdldEVsZW1lbnQsIG9wdGlvbnMsIGV4dGVuc2lvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdE9wdGlvbnMgPSBnbG9iYWxzLmRlZmF1bHRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJTdHlsaW5nID0gZ2xvYmFscy5uYXRpdmVTY3JvbGxiYXJTdHlsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9uYXRpdmVTY3JvbGxiYXJTaXplID0gZXh0ZW5kRGVlcCh7fSwgZ2xvYmFscy5uYXRpdmVTY3JvbGxiYXJTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZCA9IGV4dGVuZERlZXAoe30sIGdsb2JhbHMubmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX292ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUgPSBleHRlbmREZWVwKHt9LCBnbG9iYWxzLm92ZXJsYXlTY3JvbGxiYXJEdW1teVNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9ydGxTY3JvbGxCZWhhdmlvciA9IGV4dGVuZERlZXAoe30sIGdsb2JhbHMucnRsU2Nyb2xsQmVoYXZpb3IpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3BhcnNlICYgc2V0IG9wdGlvbnMgYnV0IGRvbid0IHVwZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgIHNldE9wdGlvbnMoZXh0ZW5kRGVlcCh7fSwgX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIF9jc3NDYWxjID0gZ2xvYmFscy5jc3NDYWxjO1xyXG4gICAgICAgICAgICAgICAgICAgIF9tc2llVmVyc2lvbiA9IGdsb2JhbHMubXNpZTtcclxuICAgICAgICAgICAgICAgICAgICBfYXV0b1VwZGF0ZVJlY29tbWVuZGVkID0gZ2xvYmFscy5hdXRvVXBkYXRlUmVjb21tZW5kZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgX3N1cHBvcnRUcmFuc2l0aW9uID0gZ2xvYmFscy5zdXBwb3J0VHJhbnNpdGlvbjtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwcG9ydFRyYW5zZm9ybSA9IGdsb2JhbHMuc3VwcG9ydFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwcG9ydFBhc3NpdmVFdmVudHMgPSBnbG9iYWxzLnN1cHBvcnRQYXNzaXZlRXZlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIF9zdXBwb3J0UmVzaXplT2JzZXJ2ZXIgPSBnbG9iYWxzLnN1cHBvcnRSZXNpemVPYnNlcnZlcjtcclxuICAgICAgICAgICAgICAgICAgICBfc3VwcG9ydE11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWxzLnN1cHBvcnRNdXRhdGlvbk9ic2VydmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIF9yZXN0cmljdGVkTWVhc3VyaW5nID0gZ2xvYmFscy5yZXN0cmljdGVkTWVhc3VyaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudEVsZW1lbnQgPSBGUkFNRVdPUksodGFyZ2V0RWxlbWVudC5vd25lckRvY3VtZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBfZG9jdW1lbnRFbGVtZW50TmF0aXZlID0gX2RvY3VtZW50RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICBfd2luZG93RWxlbWVudCA9IEZSQU1FV09SSyhfZG9jdW1lbnRFbGVtZW50TmF0aXZlLmRlZmF1bHRWaWV3IHx8IF9kb2N1bWVudEVsZW1lbnROYXRpdmUucGFyZW50V2luZG93KTtcclxuICAgICAgICAgICAgICAgICAgICBfd2luZG93RWxlbWVudE5hdGl2ZSA9IF93aW5kb3dFbGVtZW50WzBdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9odG1sRWxlbWVudCA9IGZpbmRGaXJzdChfZG9jdW1lbnRFbGVtZW50LCAnaHRtbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9ib2R5RWxlbWVudCA9IGZpbmRGaXJzdChfaHRtbEVsZW1lbnQsICdib2R5Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnQgPSBGUkFNRVdPUksodGFyZ2V0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RhcmdldEVsZW1lbnROYXRpdmUgPSBfdGFyZ2V0RWxlbWVudFswXTtcclxuICAgICAgICAgICAgICAgICAgICBfaXNUZXh0YXJlYSA9IF90YXJnZXRFbGVtZW50LmlzKCd0ZXh0YXJlYScpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9pc0JvZHkgPSBfdGFyZ2V0RWxlbWVudC5pcygnYm9keScpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9kb2N1bWVudE1peGVkID0gX2RvY3VtZW50RWxlbWVudE5hdGl2ZSAhPT0gZG9jdW1lbnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIE9uIGEgZGl2IEVsZW1lbnQgVGhlIGlmIGNoZWNrcyBvbmx5IHdoZXRoZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICogLSB0aGUgdGFyZ2V0RWxlbWVudCBoYXMgdGhlIGNsYXNzIFwib3MtaG9zdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgICogLSB0aGUgdGFyZ2V0RWxlbWVudCBoYXMgYSBhIGNoaWxkIHdpdGggdGhlIGNsYXNzIFwib3MtcGFkZGluZ1wiXHJcbiAgICAgICAgICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhhdCdzIHRoZSBjYXNlLCBpdHMgYXNzdW1lZCB0aGUgRE9NIGhhcyBhbHJlYWR5IHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxyXG4gICAgICAgICAgICAgICAgICAgICAqIChUaGUgXCIub3MtaG9zdFwiIGVsZW1lbnQgaXMgdGhlIHRhcmdldEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiAgPGRpdiBjbGFzcz1cIm9zLWhvc3RcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1yZXNpemUtb2JzZXJ2ZXItaG9zdFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXBhZGRpbmdcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtdmlld3BvcnRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLWNvbnRlbnRcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhciBvcy1zY3JvbGxiYXItaG9yaXpvbnRhbCBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLXRyYWNrXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItaGFuZGxlXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXIgb3Mtc2Nyb2xsYmFyLXZlcnRpY2FsXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci10cmFja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWhhbmRsZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWNvcm5lclwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAgICAgICAgICAgICAgICAgICAgKiBcclxuICAgICAgICAgICAgICAgICAgICAgKiBPbiBhIFRleHRhcmVhIEVsZW1lbnQgVGhlIGlmIGNoZWNrcyBvbmx5IHdoZXRoZXI6XHJcbiAgICAgICAgICAgICAgICAgICAgICogLSB0aGUgdGFyZ2V0RWxlbWVudCBoYXMgdGhlIGNsYXNzIFwib3MtdGV4dGFyZWFcIiBcclxuICAgICAgICAgICAgICAgICAgICAgKiAtIHRoZSB0YXJnZXRFbGVtZW50IGlzIGluc2lkZSBhIGVsZW1lbnQgd2l0aCB0aGUgY2xhc3MgXCJvcy1jb250ZW50XCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICogXHJcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhhdCdzIHRoZSBjYXNlLCBpdHMgYXNzdW1lZCB0aGUgRE9NIGhhcyBhbHJlYWR5IHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxyXG4gICAgICAgICAgICAgICAgICAgICAqIChUaGUgXCIub3MtdGV4dGFyZWFcIiAodGV4dGFyZWEpIGVsZW1lbnQgaXMgdGhlIHRhcmdldEVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiAgPGRpdiBjbGFzcz1cIm9zLWhvc3QtdGV4dGFyZWFcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1yZXNpemUtb2JzZXJ2ZXItaG9zdFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXBhZGRpbmcgb3MtdGV4dC1pbmhlcml0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXZpZXdwb3J0IG9zLXRleHQtaW5oZXJpdFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3MtY29udGVudCBvcy10ZXh0LWluaGVyaXRcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy10ZXh0YXJlYS1jb3ZlclwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwib3MtdGV4dGFyZWEgb3MtdGV4dC1pbmhlcml0XCI+PC90ZXh0YXJlYT5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXIgb3Mtc2Nyb2xsYmFyLWhvcml6b250YWwgXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci10cmFja1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyLWhhbmRsZVwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICA8ZGl2IGNsYXNzPVwib3Mtc2Nyb2xsYmFyIG9zLXNjcm9sbGJhci12ZXJ0aWNhbFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIDxkaXYgY2xhc3M9XCJvcy1zY3JvbGxiYXItdHJhY2tcIj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci1oYW5kbGVcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgPGRpdiBjbGFzcz1cIm9zLXNjcm9sbGJhci1jb3JuZXJcIj48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgKiAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgX2RvbUV4aXN0cyA9IF9pc1RleHRhcmVhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gX3RhcmdldEVsZW1lbnQuaGFzQ2xhc3MoX2NsYXNzTmFtZVRleHRhcmVhRWxlbWVudCkgJiYgX3RhcmdldEVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoX2NsYXNzTmFtZUNvbnRlbnRFbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IF90YXJnZXRFbGVtZW50Lmhhc0NsYXNzKF9jbGFzc05hbWVIb3N0RWxlbWVudCkgJiYgX3RhcmdldEVsZW1lbnQuY2hpbGRyZW4oX3N0ckRvdCArIF9jbGFzc05hbWVQYWRkaW5nRWxlbWVudClbTEVYSUNPTi5sXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluaXRCb2R5U2Nyb2xsO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5TW91c2VUb3VjaERvd25MaXN0ZW5lcjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVjayBpZiB0aGUgcGx1Z2luIGhhc24ndCB0byBiZSBpbml0aWFsaXplZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfbmF0aXZlU2Nyb2xsYmFySXNPdmVybGFpZC54ICYmIF9uYXRpdmVTY3JvbGxiYXJJc092ZXJsYWlkLnkgJiYgIV9jdXJyZW50UHJlcGFyZWRPcHRpb25zLm5hdGl2ZVNjcm9sbGJhcnNPdmVybGFpZC5pbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoQ2FsbGJhY2soJ29uSW5pdGlhbGl6YXRpb25XaXRoZHJhd24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9kb21FeGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwU3RydWN0dXJlRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJzRE9NKHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJDb3JuZXJET00odHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfc2xlZXBpbmcgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9iYXNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEJvZHlTY3JvbGwgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEJvZHlTY3JvbGwubCA9IE1BVEgubWF4KF90YXJnZXRFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgpLCBfaHRtbEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKCksIF93aW5kb3dFbGVtZW50W19zdHJTY3JvbGxMZWZ0XSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdEJvZHlTY3JvbGwudCA9IE1BVEgubWF4KF90YXJnZXRFbGVtZW50W19zdHJTY3JvbGxUb3BdKCksIF9odG1sRWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgpLCBfd2luZG93RWxlbWVudFtfc3RyU2Nyb2xsVG9wXSgpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlNb3VzZVRvdWNoRG93bkxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZpZXdwb3J0RWxlbWVudC5yZW1vdmVBdHRyKExFWElDT04udGkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dXBSZXNwb25zaXZlRXZlbnRMaXN0ZW5lcihfdmlld3BvcnRFbGVtZW50LCBfc3RyTW91c2VUb3VjaERvd25FdmVudCwgYm9keU1vdXNlVG91Y2hEb3duTGlzdGVuZXIsIHRydWUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2J1aWxkIE92ZXJsYXlTY3JvbGxiYXJzIERPTVxyXG4gICAgICAgICAgICAgICAgICAgIHNldHVwU3RydWN0dXJlRE9NKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJzRE9NKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJDb3JuZXJET00oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgT3ZlcmxheVNjcm9sbGJhcnMgZXZlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTdHJ1Y3R1cmVFdmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckV2ZW50cyh0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFNjcm9sbGJhckV2ZW50cyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBTY3JvbGxiYXJDb3JuZXJFdmVudHMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jcmVhdGUgbXV0YXRpb24gb2JzZXJ2ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTXV0YXRpb25PYnNlcnZlcnMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9idWlsZCByZXNpemUgb2JzZXJ2ZXIgZm9yIHRoZSBob3N0IGVsZW1lbnRcclxuICAgICAgICAgICAgICAgICAgICBzZXR1cFJlc2l6ZU9ic2VydmVyKF9zaXplT2JzZXJ2ZXJFbGVtZW50LCBob3N0T25SZXNpemVkKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9pc0JvZHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hcHBseSB0aGUgYm9keSBzY3JvbGwgdG8gaGFuZGxlIGl0IHJpZ2h0IGluIHRoZSB1cGRhdGUgbWV0aG9kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF92aWV3cG9ydEVsZW1lbnRbX3N0clNjcm9sbExlZnRdKGluaXRCb2R5U2Nyb2xsLmwpW19zdHJTY3JvbGxUb3BdKGluaXRCb2R5U2Nyb2xsLnQpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgdGhlIGZvY3VzIG9uIHRoZSB2aWV3cG9ydCBlbGVtZW50IHNvIHlvdSBkb250IGhhdmUgdG8gY2xpY2sgb24gdGhlIHBhZ2UgdG8gdXNlIGtleWJvYXJkIGtleXMgKHVwIC8gZG93biAvIHNwYWNlKSBmb3Igc2Nyb2xsaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHRhcmdldEVsZW1lbnQgJiYgX3ZpZXdwb3J0RWxlbWVudE5hdGl2ZS5mb2N1cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9zZXQgYSB0YWJpbmRleCB0byBtYWtlIHRoZSB2aWV3cG9ydEVsZW1lbnQgZm9jdXNhYmxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50LmF0dHIoTEVYSUNPTi50aSwgJy0xJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld3BvcnRFbGVtZW50TmF0aXZlLmZvY3VzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogdGhlIHRhYmluZGV4IGhhcyB0byBiZSByZW1vdmVkIGR1ZSB0bztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIHlvdSBzZXQgdGhlIHRhYmluZGV4IGF0dHJpYnV0ZSBvbiBhbiA8ZGl2PiwgdGhlbiBpdHMgY2hpbGQgY29udGVudCBjYW5ub3QgYmUgc2Nyb2xsZWQgd2l0aCB0aGUgYXJyb3cga2V5cyB1bmxlc3MgeW91IHNldCB0YWJpbmRleCBvbiB0aGUgY29udGVudCwgdG9vXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0dsb2JhbF9hdHRyaWJ1dGVzL3RhYmluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHVwUmVzcG9uc2l2ZUV2ZW50TGlzdGVuZXIoX3ZpZXdwb3J0RWxlbWVudCwgX3N0ck1vdXNlVG91Y2hEb3duRXZlbnQsIGJvZHlNb3VzZVRvdWNoRG93bkxpc3RlbmVyLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlIGZvciB0aGUgZmlyc3QgdGltZSAmIGluaXRpYWxpemUgY2FjaGVcclxuICAgICAgICAgICAgICAgICAgICBfYmFzZS51cGRhdGUoX3N0ckF1dG8pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL3RoZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQgbm93IVxyXG4gICAgICAgICAgICAgICAgICAgIF9pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hDYWxsYmFjaygnb25Jbml0aWFsaXplZCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NhbGwgYWxsIGNhbGxiYWNrcyB3aGljaCB3b3VsZCBmaXJlIGJlZm9yZSB0aGUgaW5pdGlhbGl6ZWQgd2FzIGNvbXBsZXRlXHJcbiAgICAgICAgICAgICAgICAgICAgZWFjaChfY2FsbGJhY2tzSW5pdFFldWV1ZSwgZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkgeyBkaXNwYXRjaENhbGxiYWNrKHZhbHVlLm4sIHZhbHVlLmEpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2tzSW5pdFFldWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FkZCBleHRlbnNpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUoZXh0ZW5zaW9ucykgPT0gVFlQRVMucylcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9ucyA9IFtleHRlbnNpb25zXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQ09NUEFUSUJJTElUWS5pc0EoZXh0ZW5zaW9ucykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhY2goZXh0ZW5zaW9ucywgZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkgeyBfYmFzZS5hZGRFeHQodmFsdWUpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChGUkFNRVdPUksuaXNQbGFpbk9iamVjdChleHRlbnNpb25zKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWFjaChleHRlbnNpb25zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyBfYmFzZS5hZGRFeHQoa2V5LCB2YWx1ZSk7IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2FkZCB0aGUgdHJhbnNpdGlvbiBjbGFzcyBmb3IgdHJhbnNpdGlvbnMgQUZURVIgdGhlIGZpcnN0IHVwZGF0ZSAmIEFGVEVSIHRoZSBhcHBsaWVkIGV4dGVuc2lvbnMgKGZvciBwcmV2ZW50aW5nIHVud2FudGVkIHRyYW5zaXRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3N1cHBvcnRUcmFuc2l0aW9uICYmICFfZGVzdHJveWVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkQ2xhc3MoX2hvc3RFbGVtZW50LCBfY2xhc3NOYW1lSG9zdFRyYW5zaXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sIDMzMyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfYmFzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoX3BsdWdpbi52YWxpZChjb25zdHJ1Y3QocGx1Z2luVGFyZ2V0RWxlbWVudCwgb3B0aW9ucywgZXh0ZW5zaW9ucykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgSU5TVEFOQ0VTKHBsdWdpblRhcmdldEVsZW1lbnQsIF9iYXNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Jhc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ldyBPdmVybGF5U2Nyb2xsYmFyc0luc3RhbmNlIG9iamVjdCBvciBjaGFuZ2VzIG9wdGlvbnMgaWYgYWxyZWFkeSBpbml0aWFsaXplZCBvciByZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gcGx1Z2luVGFyZ2V0RWxlbWVudHMgVGhlIGVsZW1lbnRzIHRvIHdoaWNoIHRoZSBQbHVnaW4gc2hhbGwgYmUgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBjdXN0b20gb3B0aW9ucyB3aXRoIHdoaWNoIHRoZSBwbHVnaW4gc2hhbGwgYmUgaW5pdGlhbGl6ZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb24ocykgd2hpY2ggc2hhbGwgYmUgYWRkZWQgcmlnaHQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3BsdWdpbiA9IHdpbmRvd1tQTFVHSU5OQU1FXSA9IGZ1bmN0aW9uIChwbHVnaW5UYXJnZXRFbGVtZW50cywgb3B0aW9ucywgZXh0ZW5zaW9ucykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tMRVhJQ09OLmxdID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBhcnIgPSBbXTtcclxuICAgICAgICAgICAgICAgIHZhciBvcHRzSXNQbGFpbk9iaiA9IEZSQU1FV09SSy5pc1BsYWluT2JqZWN0KG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGluc3Q7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vcGx1Z2luVGFyZ2V0RWxlbWVudHMgaXMgbnVsbCBvciB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgIGlmICghcGx1Z2luVGFyZ2V0RWxlbWVudHMpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHNJc1BsYWluT2JqIHx8ICFvcHRpb25zID8gcmVzdWx0IDogYXJyO1xyXG5cclxuICAgICAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAgICAgICBwbHVnaW5UYXJnZXRFbGVtZW50cyB3aWxsIGJlIGNvbnZlcnRlZCB0bzpcclxuICAgICAgICAgICAgICAgICAgIDEuIEEgalF1ZXJ5RWxlbWVudCBBcnJheVxyXG4gICAgICAgICAgICAgICAgICAgMi4gQSBIVE1MRWxlbWVudCBBcnJheVxyXG4gICAgICAgICAgICAgICAgICAgMy4gQSBBcnJheSB3aXRoIGEgc2luZ2xlIEhUTUwgRWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICAgc28gcGx1Z2luVGFyZ2V0RWxlbWVudHMgaXMgYWx3YXlzIGEgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgcGx1Z2luVGFyZ2V0RWxlbWVudHMgPSBwbHVnaW5UYXJnZXRFbGVtZW50c1tMRVhJQ09OLmxdICE9IHVuZGVmaW5lZCA/IHBsdWdpblRhcmdldEVsZW1lbnRzIDogW3BsdWdpblRhcmdldEVsZW1lbnRzWzBdIHx8IHBsdWdpblRhcmdldEVsZW1lbnRzXTtcclxuICAgICAgICAgICAgICAgIGluaXRPdmVybGF5U2Nyb2xsYmFyc1N0YXRpY3MoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luVGFyZ2V0RWxlbWVudHNbTEVYSUNPTi5sXSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0c0lzUGxhaW5PYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRlJBTUVXT1JLLmVhY2gocGx1Z2luVGFyZ2V0RWxlbWVudHMsIGZ1bmN0aW9uIChpLCB2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0ID0gdjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnN0ICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goT3ZlcmxheVNjcm9sbGJhcnNJbnN0YW5jZShpbnN0LCBvcHRpb25zLCBleHRlbnNpb25zLCBfcGx1Z2luc0dsb2JhbHMsIF9wbHVnaW5zQXV0b1VwZGF0ZUxvb3ApKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBGUkFNRVdPUksuZWFjaChwbHVnaW5UYXJnZXRFbGVtZW50cywgZnVuY3Rpb24gKGksIHYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3QgPSBJTlNUQU5DRVModik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgPT09ICchJyAmJiBfcGx1Z2luLnZhbGlkKGluc3QpKSB8fCAoQ09NUEFUSUJJTElUWS50eXBlKG9wdGlvbnMpID09IFRZUEVTLmYgJiYgb3B0aW9ucyh2LCBpbnN0KSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goaW5zdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goaW5zdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhcnJbTEVYSUNPTi5sXSA9PT0gMSA/IGFyclswXSA6IGFycjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUmV0dXJucyBhIG9iamVjdCB3aGljaCBjb250YWlucyBnbG9iYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBsdWdpbiBhbmQgZWFjaCBpbnN0YW5jZSBvZiBpdC5cclxuICAgICAgICAgICAgICogVGhlIHJldHVybmVkIG9iamVjdCBpcyBqdXN0IGEgY29weSwgdGhhdCBtZWFucyB0aGF0IGNoYW5nZXMgdG8gdGhlIHJldHVybmVkIG9iamVjdCB3b24ndCBoYXZlIGFueSBlZmZlY3QgdG8gdGhlIG9yaWdpbmFsIG9iamVjdC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9wbHVnaW4uZ2xvYmFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGluaXRPdmVybGF5U2Nyb2xsYmFyc1N0YXRpY3MoKTtcclxuICAgICAgICAgICAgICAgIHZhciBnbG9iYWxzID0gRlJBTUVXT1JLLmV4dGVuZCh0cnVlLCB7fSwgX3BsdWdpbnNHbG9iYWxzKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBnbG9iYWxzWydtc2llJ107XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFscztcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBHZXRzIG9yIFNldHMgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgZWFjaCBuZXcgcGx1Z2luIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gbmV3RGVmYXVsdE9wdGlvbnMgVGhlIG9iamVjdCB3aXRoIHdoaWNoIHRoZSBkZWZhdWx0IG9wdGlvbnMgc2hhbGwgYmUgZXh0ZW5kZWQuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBfcGx1Z2luLmRlZmF1bHRPcHRpb25zID0gZnVuY3Rpb24gKG5ld0RlZmF1bHRPcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBpbml0T3ZlcmxheVNjcm9sbGJhcnNTdGF0aWNzKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VyckRlZmF1bHRPcHRpb25zID0gX3BsdWdpbnNHbG9iYWxzLmRlZmF1bHRPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5ld0RlZmF1bHRPcHRpb25zID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIGN1cnJEZWZhdWx0T3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9zZXQgdGhlIG5ldyBkZWZhdWx0IG9wdGlvbnNcclxuICAgICAgICAgICAgICAgIF9wbHVnaW5zR2xvYmFscy5kZWZhdWx0T3B0aW9ucyA9IEZSQU1FV09SSy5leHRlbmQodHJ1ZSwge30sIGN1cnJEZWZhdWx0T3B0aW9ucywgX3BsdWdpbnNPcHRpb25zLl92YWxpZGF0ZShuZXdEZWZhdWx0T3B0aW9ucywgX3BsdWdpbnNPcHRpb25zLl90ZW1wbGF0ZSwgdHJ1ZSwgY3VyckRlZmF1bHRPcHRpb25zKS5fZGVmYXVsdCk7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHBhc3NlZCBpbnN0YW5jZSBpcyBhIG5vbi1kZXN0cm95ZWQgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBvc0luc3RhbmNlIFRoZSBwb3RlbnRpYWwgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2Ugd2hpY2ggc2hhbGwgYmUgY2hlY2tlZC5cclxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBhIG5vbi1kZXN0cm95ZWQgT3ZlcmxheVNjcm9sbGJhcnMgaW5zdGFuY2UsIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIF9wbHVnaW4udmFsaWQgPSBmdW5jdGlvbiAob3NJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9zSW5zdGFuY2UgaW5zdGFuY2VvZiBfcGx1Z2luICYmICFvc0luc3RhbmNlLmdldFN0YXRlKCkuZGVzdHJveWVkO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFJlZ2lzdGVycywgVW5yZWdpc3RlcnMgb3IgcmV0dXJucyBhIGV4dGVuc2lvbi5cclxuICAgICAgICAgICAgICogUmVnaXN0ZXI6IFBhc3MgdGhlIG5hbWUgYW5kIHRoZSBleHRlbnNpb24uIChkZWZhdWx0T3B0aW9ucyBpcyBvcHRpb25hbClcclxuICAgICAgICAgICAgICogVW5yZWdpc3RlcjogUGFzcyB0aGUgbmFtZSBhbmQgYW55dGhpbmcgZXhjZXB0IGEgZnVuY3Rpb24gYXMgZXh0ZW5zaW9uIHBhcmFtZXRlci5cclxuICAgICAgICAgICAgICogR2V0IGV4dGVuc2lvbjogUGFzcyB0aGUgbmFtZSBvZiB0aGUgZXh0ZW5zaW9uIHdoaWNoIHNoYWxsIGJlIGdvdC5cclxuICAgICAgICAgICAgICogR2V0IGFsbCBleHRlbnNpb25zOiBQYXNzIG5vIGFyZ3VtZW50cy5cclxuICAgICAgICAgICAgICogQHBhcmFtIGV4dGVuc2lvbk5hbWUgVGhlIG5hbWUgb2YgdGhlIGV4dGVuc2lvbiB3aGljaCBzaGFsbCBiZSByZWdpc3RlcmVkLCB1bnJlZ2lzdGVyZWQgb3IgcmV0dXJuZWQuXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSBleHRlbnNpb24gQSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdGhlIGluc3RhbmNlIG9mIHRoZSBleHRlbnNpb24gb3IgYW55dGhpbmcgb3RoZXIgdG8gcmVtb3ZlIGEgYWxyZWFkeSByZWdpc3RlcmVkIGV4dGVuc2lvbi5cclxuICAgICAgICAgICAgICogQHBhcmFtIGRlZmF1bHRPcHRpb25zIFRoZSBkZWZhdWx0IG9wdGlvbnMgd2hpY2ggc2hhbGwgYmUgdXNlZCBmb3IgdGhlIHJlZ2lzdGVyZWQgZXh0ZW5zaW9uLlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgX3BsdWdpbi5leHRlbnNpb24gPSBmdW5jdGlvbiAoZXh0ZW5zaW9uTmFtZSwgZXh0ZW5zaW9uLCBkZWZhdWx0T3B0aW9ucykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4dE5hbWVUeXBlU3RyaW5nID0gQ09NUEFUSUJJTElUWS50eXBlKGV4dGVuc2lvbk5hbWUpID09IFRZUEVTLnM7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXJnTGVuID0gYXJndW1lbnRzW0xFWElDT04ubF07XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXJnTGVuIDwgMSB8fCAhZXh0TmFtZVR5cGVTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3JldHVybiBhIGNvcHkgb2YgYWxsIGV4dGVuc2lvbiBvYmplY3RzXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZSQU1FV09SSy5leHRlbmQodHJ1ZSwgeyBsZW5ndGg6IF9wbHVnaW5zRXh0ZW5zaW9uc1tMRVhJQ09OLmxdIH0sIF9wbHVnaW5zRXh0ZW5zaW9ucyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHROYW1lVHlwZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChDT01QQVRJQklMSVRZLnR5cGUoZXh0ZW5zaW9uKSA9PSBUWVBFUy5mKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVnaXN0ZXIgZXh0ZW5zaW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9wbHVnaW5zRXh0ZW5zaW9ucy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbk5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25GYWN0b3J5OiBleHRlbnNpb24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IF9wbHVnaW5zRXh0ZW5zaW9uc1tMRVhJQ09OLmxdOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcGx1Z2luc0V4dGVuc2lvbnNbaV0ubmFtZSA9PT0gZXh0ZW5zaW9uTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmdMZW4gPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGx1Z2luc0V4dGVuc2lvbnMuc3BsaWNlKGksIDEpOyAvL3JlbW92ZSBleHRlbnNpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBGUkFNRVdPUksuZXh0ZW5kKHRydWUsIHt9LCBfcGx1Z2luc0V4dGVuc2lvbnNbaV0pOyAvL3JldHVybiBleHRlbnNpb24gd2l0aCB0aGUgZ2l2ZW4gbmFtZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIF9wbHVnaW47XHJcbiAgICAgICAgfSkoKTtcclxuXHJcbiAgICAgICAgaWYgKEpRVUVSWSAmJiBKUVVFUlkuZm4pIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBqUXVlcnkgaW5pdGlhbGl6YXRpb24gaW50ZXJmYWNlLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgaW5pdGlhbCBvcHRpb25zIGZvciB0aGUgY29uc3RydWN0aW9uIG9mIHRoZSBwbHVnaW4uIFRvIGluaXRpYWxpemUgdGhlIHBsdWdpbiwgdGhpcyBvcHRpb24gaGFzIHRvIGJlIGEgb2JqZWN0ISBJZiBpdCBpc24ndCBhIG9iamVjdCwgdGhlIGluc3RhbmNlKHMpIGFyZSByZXR1cm5lZCBhbmQgdGhlIHBsdWdpbiB3b250IGJlIGluaXRpYWxpemVkLlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9uKHMpIHdoaWNoIHNoYWxsIGJlIGFkZGVkIHJpZ2h0IGFmdGVyIGluaXRpYWxpemF0aW9uLlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn0gQWZ0ZXIgaW5pdGlhbGl6YXRpb24gaXQgcmV0dXJucyB0aGUgalF1ZXJ5IGVsZW1lbnQgYXJyYXksIGVsc2UgaXQgcmV0dXJucyB0aGUgaW5zdGFuY2Uocykgb2YgdGhlIGVsZW1lbnRzIHdoaWNoIGFyZSBzZWxlY3RlZC5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIEpRVUVSWS5mbi5vdmVybGF5U2Nyb2xsYmFycyA9IGZ1bmN0aW9uIChvcHRpb25zLCBleHRlbnNpb25zKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2VsZW1lbnRzID0gdGhpcztcclxuICAgICAgICAgICAgICAgIGlmIChKUVVFUlkuaXNQbGFpbk9iamVjdChvcHRpb25zKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIEpRVUVSWS5lYWNoKF9lbGVtZW50cywgZnVuY3Rpb24gKCkgeyBQTFVHSU4odGhpcywgb3B0aW9ucywgZXh0ZW5zaW9ucyk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZWxlbWVudHM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBMVUdJTihfZWxlbWVudHMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUExVR0lOO1xyXG4gICAgfVxyXG4pKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/overlayscrollbars/js/OverlayScrollbars.js\n");

/***/ }),

/***/ "./src/assets/icons/CloseIcon.tsx":
/*!****************************************!*\
  !*** ./src/assets/icons/CloseIcon.tsx ***!
  \****************************************/
/*! exports provided: CloseIcon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CloseIcon\", function() { return CloseIcon; });\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/assets/icons/CloseIcon.tsx\",\n    _this = undefined;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\nvar CloseIcon = function CloseIcon(props) {\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__[\"jsxDEV\"])(\"svg\", _objectSpread(_objectSpread({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"10.003\",\n    height: \"10\",\n    viewBox: \"0 0 10.003 10\"\n  }, props), {}, {\n    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__[\"jsxDEV\"])(\"path\", {\n      \"data-name\": \"_ionicons_svg_ios-close (5)\",\n      d: \"M166.686,165.55l3.573-3.573a.837.837,0,0,0-1.184-1.184l-3.573,3.573-3.573-3.573a.837.837,0,1,0-1.184,1.184l3.573,3.573-3.573,3.573a.837.837,0,0,0,1.184,1.184l3.573-3.573,3.573,3.573a.837.837,0,0,0,1.184-1.184Z\",\n      transform: \"translate(-160.5 -160.55)\",\n      fill: \"currentColor\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 7\n    }, _this)\n  }), void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 4,\n    columnNumber: 5\n  }, _this);\n};\n_c = CloseIcon;\n\nvar _c;\n\n$RefreshReg$(_c, \"CloseIcon\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9DbG9zZUljb24udHN4P2RhNzMiXSwibmFtZXMiOlsiQ2xvc2VJY29uIiwicHJvcHMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDTyxJQUFNQSxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDQyxLQUFELEVBQVc7QUFDbEMsc0JBQ0U7QUFDRSxTQUFLLEVBQUMsNEJBRFI7QUFFRSxTQUFLLEVBQUMsUUFGUjtBQUdFLFVBQU0sRUFBQyxJQUhUO0FBSUUsV0FBTyxFQUFDO0FBSlYsS0FLTUEsS0FMTjtBQUFBLDJCQU9FO0FBQ0UsbUJBQVUsNkJBRFo7QUFFRSxPQUFDLEVBQUMsbU5BRko7QUFHRSxlQUFTLEVBQUMsMkJBSFo7QUFJRSxVQUFJLEVBQUM7QUFKUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBUEY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBZ0JELENBakJNO0tBQU1ELFMiLCJmaWxlIjoiLi9zcmMvYXNzZXRzL2ljb25zL0Nsb3NlSWNvbi50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IENsb3NlSWNvbiA9IChwcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcbiAgICAgIHdpZHRoPScxMC4wMDMnXG4gICAgICBoZWlnaHQ9JzEwJ1xuICAgICAgdmlld0JveD0nMCAwIDEwLjAwMyAxMCdcbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkYXRhLW5hbWU9J19pb25pY29uc19zdmdfaW9zLWNsb3NlICg1KSdcbiAgICAgICAgZD0nTTE2Ni42ODYsMTY1LjU1bDMuNTczLTMuNTczYS44MzcuODM3LDAsMCwwLTEuMTg0LTEuMTg0bC0zLjU3MywzLjU3My0zLjU3My0zLjU3M2EuODM3LjgzNywwLDEsMC0xLjE4NCwxLjE4NGwzLjU3MywzLjU3My0zLjU3MywzLjU3M2EuODM3LjgzNywwLDAsMCwxLjE4NCwxLjE4NGwzLjU3My0zLjU3MywzLjU3MywzLjU3M2EuODM3LjgzNywwLDAsMCwxLjE4NC0xLjE4NFonXG4gICAgICAgIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC0xNjAuNSAtMTYwLjU1KSdcbiAgICAgICAgZmlsbD0nY3VycmVudENvbG9yJ1xuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/assets/icons/CloseIcon.tsx\n");

/***/ }),

/***/ "./src/assets/icons/NoCartBag.tsx":
/*!****************************************!*\
  !*** ./src/assets/icons/NoCartBag.tsx ***!
  \****************************************/
/*! exports provided: NoCartBag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoCartBag\", function() { return NoCartBag; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/assets/icons/NoCartBag.tsx\",\n    _this = undefined;\n\n\nvar NoCartBag = function NoCartBag() {\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"231.91\",\n    height: \"292\",\n    viewBox: \"0 0 231.91 292\",\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"defs\", {\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"linearGradient\", {\n        id: \"linear-gradient\",\n        x1: \"1\",\n        y1: \"0.439\",\n        x2: \"0.369\",\n        y2: \"1\",\n        gradientUnits: \"objectBoundingBox\",\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"stop\", {\n          offset: \"0\",\n          stopColor: \"#029477\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 19,\n          columnNumber: 11\n        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"stop\", {\n          offset: \"1\",\n          stopColor: \"#009e7f\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 20,\n          columnNumber: 11\n        }, _this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 11,\n        columnNumber: 9\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n      id: \"no_cart_in_bag_2\",\n      \"data-name\": \"no cart in bag 2\",\n      transform: \"translate(-1388 -351)\",\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"ellipse\", {\n        id: \"Ellipse_2873\",\n        \"data-name\": \"Ellipse 2873\",\n        cx: \"115.955\",\n        cy: \"27.366\",\n        rx: \"115.955\",\n        ry: \"27.366\",\n        transform: \"translate(1388 588.268)\",\n        fill: \"#ddd\",\n        opacity: \"0.25\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 28,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18691\",\n        \"data-name\": \"Path 18691\",\n        d: \"M29.632,0H170.368A29.828,29.828,0,0,1,200,30.021V209.979A29.828,29.828,0,0,1,170.368,240H29.632A29.828,29.828,0,0,1,0,209.979V30.021A29.828,29.828,0,0,1,29.632,0Z\",\n        transform: \"translate(1403 381)\",\n        fill: \"#009e7f\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 39,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Rectangle_1852\",\n        \"data-name\": \"Rectangle 1852\",\n        d: \"M30,0H170a30,30,0,0,1,30,30v0a30,30,0,0,1-30,30H12.857A12.857,12.857,0,0,1,0,47.143V30A30,30,0,0,1,30,0Z\",\n        transform: \"translate(1403 381)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 46,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Rectangle_1853\",\n        \"data-name\": \"Rectangle 1853\",\n        d: \"M42,0H158a42,42,0,0,1,42,42v0a18,18,0,0,1-18,18H18A18,18,0,0,1,0,42v0A42,42,0,0,1,42,0Z\",\n        transform: \"translate(1403 381)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 53,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18685\",\n        \"data-name\": \"Path 18685\",\n        d: \"M446.31,246.056a30,30,0,1,1,30-30A30.034,30.034,0,0,1,446.31,246.056Zm0-53.294A23.3,23.3,0,1,0,469.9,216.056,23.471,23.471,0,0,0,446.31,192.762Z\",\n        transform: \"translate(1056.69 164.944)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 60,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18686\",\n        \"data-name\": \"Path 18686\",\n        d: \"M446.31,375.181a30,30,0,1,1,30-30A30.034,30.034,0,0,1,446.31,375.181Zm0-53.294A23.3,23.3,0,1,0,469.9,345.181,23.471,23.471,0,0,0,446.31,321.887Z\",\n        transform: \"translate(1057.793 95.684)\",\n        fill: \"#009e7f\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"circle\", {\n        id: \"Ellipse_2874\",\n        \"data-name\": \"Ellipse 2874\",\n        cx: \"28.689\",\n        cy: \"28.689\",\n        r: \"28.689\",\n        transform: \"translate(1473.823 511.046)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 74,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"circle\", {\n        id: \"Ellipse_2875\",\n        \"data-name\": \"Ellipse 2875\",\n        cx: \"15.046\",\n        cy: \"15.046\",\n        r: \"15.046\",\n        transform: \"translate(1481.401 547.854) rotate(-45)\",\n        fill: \"#009e7f\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18687\",\n        \"data-name\": \"Path 18687\",\n        d: \"M399.71,531.27a71.755,71.755,0,0,1,12.65-13.6c3.4-2.863-1.5-7.726-4.882-4.882a78.392,78.392,0,0,0-13.73,15c-2.56,3.644,3.424,7.1,5.962,3.485Z\",\n        transform: \"translate(1060.579 -35.703)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 92,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18688\",\n        \"data-name\": \"Path 18688\",\n        d: \"M412.913,527.786a78.419,78.419,0,0,0-13.73-15c-3.38-2.843-8.289,2.017-4.882,4.882a71.785,71.785,0,0,1,12.65,13.6c2.535,3.609,8.525.162,5.962-3.485Z\",\n        transform: \"translate(1060.566 -35.704)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 99,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18689\",\n        \"data-name\": \"Path 18689\",\n        d: \"M583.278,527.786a78.417,78.417,0,0,0-13.73-15c-3.38-2.843-8.289,2.017-4.882,4.882a71.768,71.768,0,0,1,12.65,13.6c2.535,3.609,8.525.162,5.962-3.485Z\",\n        transform: \"translate(970.304 -35.704)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 106,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18690\",\n        \"data-name\": \"Path 18690\",\n        d: \"M570.075,531.27a71.77,71.77,0,0,1,12.65-13.6c3.4-2.863-1.5-7.726-4.882-4.882a78.407,78.407,0,0,0-13.73,15c-2.56,3.644,3.424,7.1,5.962,3.485Z\",\n        transform: \"translate(970.318 -35.703)\",\n        fill: \"#006854\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 113,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18692\",\n        \"data-name\": \"Path 18692\",\n        d: \"M301.243,287.464a19.115,19.115,0,0,1,8.071,9.077,19.637,19.637,0,0,1,1.6,7.88v26.085a19.349,19.349,0,0,1-9.672,16.957c-10.048-6.858-16.544-17.742-16.544-30S291.2,294.322,301.243,287.464Z\",\n        transform: \"translate(1292.301 101.536)\",\n        fill: \"url(#linear-gradient)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n        id: \"Path_18693\",\n        \"data-name\": \"Path 18693\",\n        d: \"M294.371,287.464a19.115,19.115,0,0,0-8.071,9.077,19.637,19.637,0,0,0-1.6,7.88v26.085a19.349,19.349,0,0,0,9.672,16.957c10.048-6.858,16.544-17.742,16.544-30S304.419,294.322,294.371,287.464Z\",\n        transform: \"translate(1118.301 101.536)\",\n        fill: \"url(#linear-gradient)\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 127,\n        columnNumber: 9\n      }, _this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 23,\n      columnNumber: 7\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 4,\n    columnNumber: 5\n  }, _this);\n};\n_c = NoCartBag;\n\nvar _c;\n\n$RefreshReg$(_c, \"NoCartBag\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9Ob0NhcnRCYWcudHN4PzMxNzUiXSwibmFtZXMiOlsiTm9DYXJ0QmFnIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ08sSUFBTUEsU0FBUyxHQUFHLFNBQVpBLFNBQVksR0FBTTtBQUM3QixzQkFDRTtBQUNFLFNBQUssRUFBQyw0QkFEUjtBQUVFLFNBQUssRUFBQyxRQUZSO0FBR0UsVUFBTSxFQUFDLEtBSFQ7QUFJRSxXQUFPLEVBQUMsZ0JBSlY7QUFBQSw0QkFNRTtBQUFBLDZCQUNFO0FBQ0UsVUFBRSxFQUFDLGlCQURMO0FBRUUsVUFBRSxFQUFDLEdBRkw7QUFHRSxVQUFFLEVBQUMsT0FITDtBQUlFLFVBQUUsRUFBQyxPQUpMO0FBS0UsVUFBRSxFQUFDLEdBTEw7QUFNRSxxQkFBYSxFQUFDLG1CQU5oQjtBQUFBLGdDQVFFO0FBQU0sZ0JBQU0sRUFBQyxHQUFiO0FBQWlCLG1CQUFTLEVBQUM7QUFBM0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFSRixlQVNFO0FBQU0sZ0JBQU0sRUFBQyxHQUFiO0FBQWlCLG1CQUFTLEVBQUM7QUFBM0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFURjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBTkYsZUFtQkU7QUFDRSxRQUFFLEVBQUMsa0JBREw7QUFFRSxtQkFBVSxrQkFGWjtBQUdFLGVBQVMsRUFBQyx1QkFIWjtBQUFBLDhCQUtFO0FBQ0UsVUFBRSxFQUFDLGNBREw7QUFFRSxxQkFBVSxjQUZaO0FBR0UsVUFBRSxFQUFDLFNBSEw7QUFJRSxVQUFFLEVBQUMsUUFKTDtBQUtFLFVBQUUsRUFBQyxTQUxMO0FBTUUsVUFBRSxFQUFDLFFBTkw7QUFPRSxpQkFBUyxFQUFDLHlCQVBaO0FBUUUsWUFBSSxFQUFDLE1BUlA7QUFTRSxlQUFPLEVBQUM7QUFUVjtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBTEYsZUFn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QTtBQUFBLGFBbkJGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBc0lELENBdklNO0tBQU1BLFMiLCJmaWxlIjoiLi9zcmMvYXNzZXRzL2ljb25zL05vQ2FydEJhZy50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IE5vQ2FydEJhZyA9ICgpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHdpZHRoPVwiMjMxLjkxXCJcbiAgICAgIGhlaWdodD1cIjI5MlwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDIzMS45MSAyOTJcIlxuICAgID5cbiAgICAgIDxkZWZzPlxuICAgICAgICA8bGluZWFyR3JhZGllbnRcbiAgICAgICAgICBpZD1cImxpbmVhci1ncmFkaWVudFwiXG4gICAgICAgICAgeDE9XCIxXCJcbiAgICAgICAgICB5MT1cIjAuNDM5XCJcbiAgICAgICAgICB4Mj1cIjAuMzY5XCJcbiAgICAgICAgICB5Mj1cIjFcIlxuICAgICAgICAgIGdyYWRpZW50VW5pdHM9XCJvYmplY3RCb3VuZGluZ0JveFwiXG4gICAgICAgID5cbiAgICAgICAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3RvcENvbG9yPVwiIzAyOTQ3N1wiIC8+XG4gICAgICAgICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0b3BDb2xvcj1cIiMwMDllN2ZcIiAvPlxuICAgICAgICA8L2xpbmVhckdyYWRpZW50PlxuICAgICAgPC9kZWZzPlxuICAgICAgPGdcbiAgICAgICAgaWQ9XCJub19jYXJ0X2luX2JhZ18yXCJcbiAgICAgICAgZGF0YS1uYW1lPVwibm8gY2FydCBpbiBiYWcgMlwiXG4gICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgtMTM4OCAtMzUxKVwiXG4gICAgICA+XG4gICAgICAgIDxlbGxpcHNlXG4gICAgICAgICAgaWQ9XCJFbGxpcHNlXzI4NzNcIlxuICAgICAgICAgIGRhdGEtbmFtZT1cIkVsbGlwc2UgMjg3M1wiXG4gICAgICAgICAgY3g9XCIxMTUuOTU1XCJcbiAgICAgICAgICBjeT1cIjI3LjM2NlwiXG4gICAgICAgICAgcng9XCIxMTUuOTU1XCJcbiAgICAgICAgICByeT1cIjI3LjM2NlwiXG4gICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEzODggNTg4LjI2OClcIlxuICAgICAgICAgIGZpbGw9XCIjZGRkXCJcbiAgICAgICAgICBvcGFjaXR5PVwiMC4yNVwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9XCJQYXRoXzE4NjkxXCJcbiAgICAgICAgICBkYXRhLW5hbWU9XCJQYXRoIDE4NjkxXCJcbiAgICAgICAgICBkPVwiTTI5LjYzMiwwSDE3MC4zNjhBMjkuODI4LDI5LjgyOCwwLDAsMSwyMDAsMzAuMDIxVjIwOS45NzlBMjkuODI4LDI5LjgyOCwwLDAsMSwxNzAuMzY4LDI0MEgyOS42MzJBMjkuODI4LDI5LjgyOCwwLDAsMSwwLDIwOS45NzlWMzAuMDIxQTI5LjgyOCwyOS44MjgsMCwwLDEsMjkuNjMyLDBaXCJcbiAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTQwMyAzODEpXCJcbiAgICAgICAgICBmaWxsPVwiIzAwOWU3ZlwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9XCJSZWN0YW5nbGVfMTg1MlwiXG4gICAgICAgICAgZGF0YS1uYW1lPVwiUmVjdGFuZ2xlIDE4NTJcIlxuICAgICAgICAgIGQ9XCJNMzAsMEgxNzBhMzAsMzAsMCwwLDEsMzAsMzB2MGEzMCwzMCwwLDAsMS0zMCwzMEgxMi44NTdBMTIuODU3LDEyLjg1NywwLDAsMSwwLDQ3LjE0M1YzMEEzMCwzMCwwLDAsMSwzMCwwWlwiXG4gICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDE0MDMgMzgxKVwiXG4gICAgICAgICAgZmlsbD1cIiMwMDY4NTRcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPVwiUmVjdGFuZ2xlXzE4NTNcIlxuICAgICAgICAgIGRhdGEtbmFtZT1cIlJlY3RhbmdsZSAxODUzXCJcbiAgICAgICAgICBkPVwiTTQyLDBIMTU4YTQyLDQyLDAsMCwxLDQyLDQydjBhMTgsMTgsMCwwLDEtMTgsMThIMThBMTgsMTgsMCwwLDEsMCw0MnYwQTQyLDQyLDAsMCwxLDQyLDBaXCJcbiAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTQwMyAzODEpXCJcbiAgICAgICAgICBmaWxsPVwiIzAwNjg1NFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9XCJQYXRoXzE4Njg1XCJcbiAgICAgICAgICBkYXRhLW5hbWU9XCJQYXRoIDE4Njg1XCJcbiAgICAgICAgICBkPVwiTTQ0Ni4zMSwyNDYuMDU2YTMwLDMwLDAsMSwxLDMwLTMwQTMwLjAzNCwzMC4wMzQsMCwwLDEsNDQ2LjMxLDI0Ni4wNTZabTAtNTMuMjk0QTIzLjMsMjMuMywwLDEsMCw0NjkuOSwyMTYuMDU2LDIzLjQ3MSwyMy40NzEsMCwwLDAsNDQ2LjMxLDE5Mi43NjJaXCJcbiAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTA1Ni42OSAxNjQuOTQ0KVwiXG4gICAgICAgICAgZmlsbD1cIiMwMDY4NTRcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPVwiUGF0aF8xODY4NlwiXG4gICAgICAgICAgZGF0YS1uYW1lPVwiUGF0aCAxODY4NlwiXG4gICAgICAgICAgZD1cIk00NDYuMzEsMzc1LjE4MWEzMCwzMCwwLDEsMSwzMC0zMEEzMC4wMzQsMzAuMDM0LDAsMCwxLDQ0Ni4zMSwzNzUuMTgxWm0wLTUzLjI5NEEyMy4zLDIzLjMsMCwxLDAsNDY5LjksMzQ1LjE4MSwyMy40NzEsMjMuNDcxLDAsMCwwLDQ0Ni4zMSwzMjEuODg3WlwiXG4gICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEwNTcuNzkzIDk1LjY4NClcIlxuICAgICAgICAgIGZpbGw9XCIjMDA5ZTdmXCJcbiAgICAgICAgLz5cbiAgICAgICAgPGNpcmNsZVxuICAgICAgICAgIGlkPVwiRWxsaXBzZV8yODc0XCJcbiAgICAgICAgICBkYXRhLW5hbWU9XCJFbGxpcHNlIDI4NzRcIlxuICAgICAgICAgIGN4PVwiMjguNjg5XCJcbiAgICAgICAgICBjeT1cIjI4LjY4OVwiXG4gICAgICAgICAgcj1cIjI4LjY4OVwiXG4gICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDE0NzMuODIzIDUxMS4wNDYpXCJcbiAgICAgICAgICBmaWxsPVwiIzAwNjg1NFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxjaXJjbGVcbiAgICAgICAgICBpZD1cIkVsbGlwc2VfMjg3NVwiXG4gICAgICAgICAgZGF0YS1uYW1lPVwiRWxsaXBzZSAyODc1XCJcbiAgICAgICAgICBjeD1cIjE1LjA0NlwiXG4gICAgICAgICAgY3k9XCIxNS4wNDZcIlxuICAgICAgICAgIHI9XCIxNS4wNDZcIlxuICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxNDgxLjQwMSA1NDcuODU0KSByb3RhdGUoLTQ1KVwiXG4gICAgICAgICAgZmlsbD1cIiMwMDllN2ZcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPVwiUGF0aF8xODY4N1wiXG4gICAgICAgICAgZGF0YS1uYW1lPVwiUGF0aCAxODY4N1wiXG4gICAgICAgICAgZD1cIk0zOTkuNzEsNTMxLjI3YTcxLjc1NSw3MS43NTUsMCwwLDEsMTIuNjUtMTMuNmMzLjQtMi44NjMtMS41LTcuNzI2LTQuODgyLTQuODgyYTc4LjM5Miw3OC4zOTIsMCwwLDAtMTMuNzMsMTVjLTIuNTYsMy42NDQsMy40MjQsNy4xLDUuOTYyLDMuNDg1WlwiXG4gICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEwNjAuNTc5IC0zNS43MDMpXCJcbiAgICAgICAgICBmaWxsPVwiIzAwNjg1NFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9XCJQYXRoXzE4Njg4XCJcbiAgICAgICAgICBkYXRhLW5hbWU9XCJQYXRoIDE4Njg4XCJcbiAgICAgICAgICBkPVwiTTQxMi45MTMsNTI3Ljc4NmE3OC40MTksNzguNDE5LDAsMCwwLTEzLjczLTE1Yy0zLjM4LTIuODQzLTguMjg5LDIuMDE3LTQuODgyLDQuODgyYTcxLjc4NSw3MS43ODUsMCwwLDEsMTIuNjUsMTMuNmMyLjUzNSwzLjYwOSw4LjUyNS4xNjIsNS45NjItMy40ODVaXCJcbiAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTA2MC41NjYgLTM1LjcwNClcIlxuICAgICAgICAgIGZpbGw9XCIjMDA2ODU0XCJcbiAgICAgICAgLz5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBpZD1cIlBhdGhfMTg2ODlcIlxuICAgICAgICAgIGRhdGEtbmFtZT1cIlBhdGggMTg2ODlcIlxuICAgICAgICAgIGQ9XCJNNTgzLjI3OCw1MjcuNzg2YTc4LjQxNyw3OC40MTcsMCwwLDAtMTMuNzMtMTVjLTMuMzgtMi44NDMtOC4yODksMi4wMTctNC44ODIsNC44ODJhNzEuNzY4LDcxLjc2OCwwLDAsMSwxMi42NSwxMy42YzIuNTM1LDMuNjA5LDguNTI1LjE2Miw1Ljk2Mi0zLjQ4NVpcIlxuICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg5NzAuMzA0IC0zNS43MDQpXCJcbiAgICAgICAgICBmaWxsPVwiIzAwNjg1NFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9XCJQYXRoXzE4NjkwXCJcbiAgICAgICAgICBkYXRhLW5hbWU9XCJQYXRoIDE4NjkwXCJcbiAgICAgICAgICBkPVwiTTU3MC4wNzUsNTMxLjI3YTcxLjc3LDcxLjc3LDAsMCwxLDEyLjY1LTEzLjZjMy40LTIuODYzLTEuNS03LjcyNi00Ljg4Mi00Ljg4MmE3OC40MDcsNzguNDA3LDAsMCwwLTEzLjczLDE1Yy0yLjU2LDMuNjQ0LDMuNDI0LDcuMSw1Ljk2MiwzLjQ4NVpcIlxuICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg5NzAuMzE4IC0zNS43MDMpXCJcbiAgICAgICAgICBmaWxsPVwiIzAwNjg1NFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgaWQ9XCJQYXRoXzE4NjkyXCJcbiAgICAgICAgICBkYXRhLW5hbWU9XCJQYXRoIDE4NjkyXCJcbiAgICAgICAgICBkPVwiTTMwMS4yNDMsMjg3LjQ2NGExOS4xMTUsMTkuMTE1LDAsMCwxLDguMDcxLDkuMDc3LDE5LjYzNywxOS42MzcsMCwwLDEsMS42LDcuODh2MjYuMDg1YTE5LjM0OSwxOS4zNDksMCwwLDEtOS42NzIsMTYuOTU3Yy0xMC4wNDgtNi44NTgtMTYuNTQ0LTE3Ljc0Mi0xNi41NDQtMzBTMjkxLjIsMjk0LjMyMiwzMDEuMjQzLDI4Ny40NjRaXCJcbiAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTI5Mi4zMDEgMTAxLjUzNilcIlxuICAgICAgICAgIGZpbGw9XCJ1cmwoI2xpbmVhci1ncmFkaWVudClcIlxuICAgICAgICAvPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIGlkPVwiUGF0aF8xODY5M1wiXG4gICAgICAgICAgZGF0YS1uYW1lPVwiUGF0aCAxODY5M1wiXG4gICAgICAgICAgZD1cIk0yOTQuMzcxLDI4Ny40NjRhMTkuMTE1LDE5LjExNSwwLDAsMC04LjA3MSw5LjA3NywxOS42MzcsMTkuNjM3LDAsMCwwLTEuNiw3Ljg4djI2LjA4NWExOS4zNDksMTkuMzQ5LDAsMCwwLDkuNjcyLDE2Ljk1N2MxMC4wNDgtNi44NTgsMTYuNTQ0LTE3Ljc0MiwxNi41NDQtMzBTMzA0LjQxOSwyOTQuMzIyLDI5NC4zNzEsMjg3LjQ2NFpcIlxuICAgICAgICAgIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgxMTE4LjMwMSAxMDEuNTM2KVwiXG4gICAgICAgICAgZmlsbD1cInVybCgjbGluZWFyLWdyYWRpZW50KVwiXG4gICAgICAgIC8+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/assets/icons/NoCartBag.tsx\n");

/***/ }),

/***/ "./src/assets/icons/PlusMinus.tsx":
/*!****************************************!*\
  !*** ./src/assets/icons/PlusMinus.tsx ***!
  \****************************************/
/*! exports provided: Plus, Minus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Plus\", function() { return Plus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Minus\", function() { return Minus; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/assets/icons/PlusMinus.tsx\",\n    _this = undefined;\n\n // SVG plus icon\n\nvar Plus = function Plus(_ref) {\n  var _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'currentColor' : _ref$color,\n      _ref$width = _ref.width,\n      width = _ref$width === void 0 ? '12px' : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === void 0 ? '12px' : _ref$height;\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: width,\n    height: height,\n    viewBox: \"0 0 12 12\",\n    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n      id: \"Group_3351\",\n      \"data-name\": \"Group 3351\",\n      transform: \"translate(-1367 -190)\",\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"rect\", {\n        \"data-name\": \"Rectangle 520\",\n        width: \"12\",\n        height: \"2\",\n        rx: \"1\",\n        transform: \"translate(1367 195)\",\n        fill: color\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 20,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"rect\", {\n        \"data-name\": \"Rectangle 521\",\n        width: \"12\",\n        height: \"2\",\n        rx: \"1\",\n        transform: \"translate(1374 190) rotate(90)\",\n        fill: color\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 28,\n        columnNumber: 9\n      }, _this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 7\n    }, _this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 9,\n    columnNumber: 5\n  }, _this);\n}; // SVG minus icon\n\n_c = Plus;\nvar Minus = function Minus(_ref2) {\n  var _ref2$color = _ref2.color,\n      color = _ref2$color === void 0 ? 'currentColor' : _ref2$color,\n      _ref2$width = _ref2.width,\n      width = _ref2$width === void 0 ? '12px' : _ref2$width,\n      _ref2$height = _ref2.height,\n      height = _ref2$height === void 0 ? '2px' : _ref2$height;\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: width,\n    height: height,\n    viewBox: \"0 0 12 2\",\n    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"rect\", {\n      \"data-name\": \"Rectangle 522\",\n      width: \"12\",\n      height: \"2\",\n      rx: \"1\",\n      fill: color\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 7\n    }, _this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 48,\n    columnNumber: 5\n  }, _this);\n};\n_c2 = Minus;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Plus\");\n$RefreshReg$(_c2, \"Minus\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9QbHVzTWludXMudHN4PzM5ZTMiXSwibmFtZXMiOlsiUGx1cyIsImNvbG9yIiwid2lkdGgiLCJoZWlnaHQiLCJNaW51cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0NBQ0E7O0FBQ08sSUFBTUEsSUFBSSxHQUFHLFNBQVBBLElBQU8sT0FJZDtBQUFBLHdCQUhKQyxLQUdJO0FBQUEsTUFISkEsS0FHSSwyQkFISSxjQUdKO0FBQUEsd0JBRkpDLEtBRUk7QUFBQSxNQUZKQSxLQUVJLDJCQUZJLE1BRUo7QUFBQSx5QkFESkMsTUFDSTtBQUFBLE1BREpBLE1BQ0ksNEJBREssTUFDTDtBQUNKLHNCQUNFO0FBQ0UsU0FBSyxFQUFDLDRCQURSO0FBRUUsU0FBSyxFQUFFRCxLQUZUO0FBR0UsVUFBTSxFQUFFQyxNQUhWO0FBSUUsV0FBTyxFQUFDLFdBSlY7QUFBQSwyQkFNRTtBQUNFLFFBQUUsRUFBQyxZQURMO0FBRUUsbUJBQVUsWUFGWjtBQUdFLGVBQVMsRUFBQyx1QkFIWjtBQUFBLDhCQUtFO0FBQ0UscUJBQVUsZUFEWjtBQUVFLGFBQUssRUFBQyxJQUZSO0FBR0UsY0FBTSxFQUFDLEdBSFQ7QUFJRSxVQUFFLEVBQUMsR0FKTDtBQUtFLGlCQUFTLEVBQUMscUJBTFo7QUFNRSxZQUFJLEVBQUVGO0FBTlI7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUxGLGVBYUU7QUFDRSxxQkFBVSxlQURaO0FBRUUsYUFBSyxFQUFDLElBRlI7QUFHRSxjQUFNLEVBQUMsR0FIVDtBQUlFLFVBQUUsRUFBQyxHQUpMO0FBS0UsaUJBQVMsRUFBQyxnQ0FMWjtBQU1FLFlBQUksRUFBRUE7QUFOUjtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBYkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBK0JELENBcENNLEMsQ0FzQ1A7O0tBdENhRCxJO0FBdUNOLElBQU1JLEtBQUssR0FBRyxTQUFSQSxLQUFRLFFBSWY7QUFBQSwwQkFISkgsS0FHSTtBQUFBLE1BSEpBLEtBR0ksNEJBSEksY0FHSjtBQUFBLDBCQUZKQyxLQUVJO0FBQUEsTUFGSkEsS0FFSSw0QkFGSSxNQUVKO0FBQUEsMkJBREpDLE1BQ0k7QUFBQSxNQURKQSxNQUNJLDZCQURLLEtBQ0w7QUFDSixzQkFDRTtBQUNFLFNBQUssRUFBQyw0QkFEUjtBQUVFLFNBQUssRUFBRUQsS0FGVDtBQUdFLFVBQU0sRUFBRUMsTUFIVjtBQUlFLFdBQU8sRUFBQyxVQUpWO0FBQUEsMkJBTUU7QUFDRSxtQkFBVSxlQURaO0FBRUUsV0FBSyxFQUFDLElBRlI7QUFHRSxZQUFNLEVBQUMsR0FIVDtBQUlFLFFBQUUsRUFBQyxHQUpMO0FBS0UsVUFBSSxFQUFFRjtBQUxSO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFORjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBREY7QUFnQkQsQ0FyQk07TUFBTUcsSyIsImZpbGUiOiIuL3NyYy9hc3NldHMvaWNvbnMvUGx1c01pbnVzLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG4vLyBTVkcgcGx1cyBpY29uXG5leHBvcnQgY29uc3QgUGx1cyA9ICh7XG4gIGNvbG9yID0gJ2N1cnJlbnRDb2xvcicsXG4gIHdpZHRoID0gJzEycHgnLFxuICBoZWlnaHQgPSAnMTJweCcsXG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB3aWR0aD17d2lkdGh9XG4gICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgIHZpZXdCb3g9XCIwIDAgMTIgMTJcIlxuICAgID5cbiAgICAgIDxnXG4gICAgICAgIGlkPVwiR3JvdXBfMzM1MVwiXG4gICAgICAgIGRhdGEtbmFtZT1cIkdyb3VwIDMzNTFcIlxuICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoLTEzNjcgLTE5MClcIlxuICAgICAgPlxuICAgICAgICA8cmVjdFxuICAgICAgICAgIGRhdGEtbmFtZT1cIlJlY3RhbmdsZSA1MjBcIlxuICAgICAgICAgIHdpZHRoPVwiMTJcIlxuICAgICAgICAgIGhlaWdodD1cIjJcIlxuICAgICAgICAgIHJ4PVwiMVwiXG4gICAgICAgICAgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDEzNjcgMTk1KVwiXG4gICAgICAgICAgZmlsbD17Y29sb3J9XG4gICAgICAgIC8+XG4gICAgICAgIDxyZWN0XG4gICAgICAgICAgZGF0YS1uYW1lPVwiUmVjdGFuZ2xlIDUyMVwiXG4gICAgICAgICAgd2lkdGg9XCIxMlwiXG4gICAgICAgICAgaGVpZ2h0PVwiMlwiXG4gICAgICAgICAgcng9XCIxXCJcbiAgICAgICAgICB0cmFuc2Zvcm09XCJ0cmFuc2xhdGUoMTM3NCAxOTApIHJvdGF0ZSg5MClcIlxuICAgICAgICAgIGZpbGw9e2NvbG9yfVxuICAgICAgICAvPlxuICAgICAgPC9nPlxuICAgIDwvc3ZnPlxuICApO1xufTtcblxuLy8gU1ZHIG1pbnVzIGljb25cbmV4cG9ydCBjb25zdCBNaW51cyA9ICh7XG4gIGNvbG9yID0gJ2N1cnJlbnRDb2xvcicsXG4gIHdpZHRoID0gJzEycHgnLFxuICBoZWlnaHQgPSAnMnB4Jyxcbn0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgdmlld0JveD1cIjAgMCAxMiAyXCJcbiAgICA+XG4gICAgICA8cmVjdFxuICAgICAgICBkYXRhLW5hbWU9XCJSZWN0YW5nbGUgNTIyXCJcbiAgICAgICAgd2lkdGg9XCIxMlwiXG4gICAgICAgIGhlaWdodD1cIjJcIlxuICAgICAgICByeD1cIjFcIlxuICAgICAgICBmaWxsPXtjb2xvcn1cbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/assets/icons/PlusMinus.tsx\n");

/***/ }),

/***/ "./src/assets/icons/ShoppingBag.tsx":
/*!******************************************!*\
  !*** ./src/assets/icons/ShoppingBag.tsx ***!
  \******************************************/
/*! exports provided: ShoppingBag */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShoppingBag\", function() { return ShoppingBag; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/assets/icons/ShoppingBag.tsx\",\n    _this = undefined;\n\n\nvar ShoppingBag = function ShoppingBag() {\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"span\", {\n    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"12.686\",\n      height: \"16\",\n      viewBox: \"0 0 12.686 16\",\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n        \"data-name\": \"Group 2704\",\n        transform: \"translate(-27.023 -2)\",\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n          \"data-name\": \"Group 17\",\n          transform: \"translate(27.023 5.156)\",\n          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n            \"data-name\": \"Group 16\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n              \"data-name\": \"Path 3\",\n              d: \"M65.7,111.043l-.714-9A1.125,1.125,0,0,0,63.871,101H62.459V103.1a.469.469,0,1,1-.937,0V101H57.211V103.1a.469.469,0,1,1-.937,0V101H54.862a1.125,1.125,0,0,0-1.117,1.033l-.715,9.006a2.605,2.605,0,0,0,2.6,2.8H63.1a2.605,2.605,0,0,0,2.6-2.806Zm-4.224-4.585-2.424,2.424a.468.468,0,0,1-.663,0l-1.136-1.136a.469.469,0,0,1,.663-.663l.8.8,2.092-2.092a.469.469,0,1,1,.663.663Z\",\n              transform: \"translate(-53.023 -101.005)\",\n              fill: \"currentColor\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 14,\n              columnNumber: 15\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 13,\n            columnNumber: 13\n          }, _this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 12,\n          columnNumber: 11\n        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n          \"data-name\": \"Group 19\",\n          transform: \"translate(30.274 2)\",\n          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n            \"data-name\": \"Group 18\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n              \"data-name\": \"Path 4\",\n              d: \"M160.132,0a3.1,3.1,0,0,0-3.093,3.093v.063h.937V3.093a2.155,2.155,0,1,1,4.311,0v.063h.937V3.093A3.1,3.1,0,0,0,160.132,0Z\",\n              transform: \"translate(-157.039)\",\n              fill: \"currentColor\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 24,\n              columnNumber: 15\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 23,\n            columnNumber: 13\n          }, _this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 22,\n          columnNumber: 11\n        }, _this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 11,\n        columnNumber: 9\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 5,\n      columnNumber: 7\n    }, _this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 4,\n    columnNumber: 5\n  }, _this);\n};\n_c = ShoppingBag;\n\nvar _c;\n\n$RefreshReg$(_c, \"ShoppingBag\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9TaG9wcGluZ0JhZy50c3g/MzI0OCJdLCJuYW1lcyI6WyJTaG9wcGluZ0JhZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNPLElBQU1BLFdBQVcsR0FBRyxTQUFkQSxXQUFjLEdBQU07QUFDL0Isc0JBQ0U7QUFBQSwyQkFDRTtBQUNFLFdBQUssRUFBQyw0QkFEUjtBQUVFLFdBQUssRUFBQyxRQUZSO0FBR0UsWUFBTSxFQUFDLElBSFQ7QUFJRSxhQUFPLEVBQUMsZUFKVjtBQUFBLDZCQU1FO0FBQUcscUJBQVUsWUFBYjtBQUEwQixpQkFBUyxFQUFDLHVCQUFwQztBQUFBLGdDQUNFO0FBQUcsdUJBQVUsVUFBYjtBQUF3QixtQkFBUyxFQUFDLHlCQUFsQztBQUFBLGlDQUNFO0FBQUcseUJBQVUsVUFBYjtBQUFBLG1DQUNFO0FBQ0UsMkJBQVUsUUFEWjtBQUVFLGVBQUMsRUFBQyw4V0FGSjtBQUdFLHVCQUFTLEVBQUMsNkJBSFo7QUFJRSxrQkFBSSxFQUFDO0FBSlA7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQURGLGVBV0U7QUFBRyx1QkFBVSxVQUFiO0FBQXdCLG1CQUFTLEVBQUMscUJBQWxDO0FBQUEsaUNBQ0U7QUFBRyx5QkFBVSxVQUFiO0FBQUEsbUNBQ0U7QUFDRSwyQkFBVSxRQURaO0FBRUUsZUFBQyxFQUFDLHlIQUZKO0FBR0UsdUJBQVMsRUFBQyxxQkFIWjtBQUlFLGtCQUFJLEVBQUM7QUFKUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBWEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERjtBQWlDRCxDQWxDTTtLQUFNQSxXIiwiZmlsZSI6Ii4vc3JjL2Fzc2V0cy9pY29ucy9TaG9wcGluZ0JhZy50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IFNob3BwaW5nQmFnID0gKCkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzcGFuPlxuICAgICAgPHN2Z1xuICAgICAgICB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnXG4gICAgICAgIHdpZHRoPScxMi42ODYnXG4gICAgICAgIGhlaWdodD0nMTYnXG4gICAgICAgIHZpZXdCb3g9JzAgMCAxMi42ODYgMTYnXG4gICAgICA+XG4gICAgICAgIDxnIGRhdGEtbmFtZT0nR3JvdXAgMjcwNCcgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTI3LjAyMyAtMiknPlxuICAgICAgICAgIDxnIGRhdGEtbmFtZT0nR3JvdXAgMTcnIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDI3LjAyMyA1LjE1NiknPlxuICAgICAgICAgICAgPGcgZGF0YS1uYW1lPSdHcm91cCAxNic+XG4gICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgZGF0YS1uYW1lPSdQYXRoIDMnXG4gICAgICAgICAgICAgICAgZD0nTTY1LjcsMTExLjA0M2wtLjcxNC05QTEuMTI1LDEuMTI1LDAsMCwwLDYzLjg3MSwxMDFINjIuNDU5VjEwMy4xYS40NjkuNDY5LDAsMSwxLS45MzcsMFYxMDFINTcuMjExVjEwMy4xYS40NjkuNDY5LDAsMSwxLS45MzcsMFYxMDFINTQuODYyYTEuMTI1LDEuMTI1LDAsMCwwLTEuMTE3LDEuMDMzbC0uNzE1LDkuMDA2YTIuNjA1LDIuNjA1LDAsMCwwLDIuNiwyLjhINjMuMWEyLjYwNSwyLjYwNSwwLDAsMCwyLjYtMi44MDZabS00LjIyNC00LjU4NS0yLjQyNCwyLjQyNGEuNDY4LjQ2OCwwLDAsMS0uNjYzLDBsLTEuMTM2LTEuMTM2YS40NjkuNDY5LDAsMCwxLC42NjMtLjY2M2wuOC44LDIuMDkyLTIuMDkyYS40NjkuNDY5LDAsMSwxLC42NjMuNjYzWidcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNTMuMDIzIC0xMDEuMDA1KSdcbiAgICAgICAgICAgICAgICBmaWxsPSdjdXJyZW50Q29sb3InXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgPC9nPlxuICAgICAgICAgIDxnIGRhdGEtbmFtZT0nR3JvdXAgMTknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDMwLjI3NCAyKSc+XG4gICAgICAgICAgICA8ZyBkYXRhLW5hbWU9J0dyb3VwIDE4Jz5cbiAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICBkYXRhLW5hbWU9J1BhdGggNCdcbiAgICAgICAgICAgICAgICBkPSdNMTYwLjEzMiwwYTMuMSwzLjEsMCwwLDAtMy4wOTMsMy4wOTN2LjA2M2guOTM3VjMuMDkzYTIuMTU1LDIuMTU1LDAsMSwxLDQuMzExLDB2LjA2M2guOTM3VjMuMDkzQTMuMSwzLjEsMCwwLDAsMTYwLjEzMiwwWidcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTU3LjAzOSknXG4gICAgICAgICAgICAgICAgZmlsbD0nY3VycmVudENvbG9yJ1xuICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgPC9nPlxuICAgICAgICAgIDwvZz5cbiAgICAgICAgPC9nPlxuICAgICAgPC9zdmc+XG4gICAgPC9zcGFuPlxuICApO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/assets/icons/ShoppingBag.tsx\n");

/***/ }),

/***/ "./src/assets/icons/ShoppingBagLarge.tsx":
/*!***********************************************!*\
  !*** ./src/assets/icons/ShoppingBagLarge.tsx ***!
  \***********************************************/
/*! exports provided: ShoppingBagLarge */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShoppingBagLarge\", function() { return ShoppingBagLarge; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/assets/icons/ShoppingBagLarge.tsx\",\n    _this = undefined;\n\n\nvar ShoppingBagLarge = function ShoppingBagLarge(_ref) {\n  var _ref$color = _ref.color,\n      color = _ref$color === void 0 ? 'currentColor' : _ref$color,\n      _ref$width = _ref.width,\n      width = _ref$width === void 0 ? '18px' : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === void 0 ? '18px' : _ref$height;\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"svg\", {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: width,\n    height: height,\n    viewBox: \"0 0 23.786 30\",\n    children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n      \"data-name\": \"shopping-bag (3)\",\n      transform: \"translate(-53.023)\",\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n        \"data-name\": \"Group 2704\",\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n          \"data-name\": \"Group 17\",\n          transform: \"translate(53.023 5.918)\",\n          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n            \"data-name\": \"Group 16\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n              \"data-name\": \"Path 3\",\n              d: \"M76.8,119.826l-1.34-16.881A2.109,2.109,0,0,0,73.362,101H70.716v3.921a.879.879,0,1,1-1.757,0V101H60.875v3.921a.879.879,0,1,1-1.757,0V101H56.472a2.109,2.109,0,0,0-2.094,1.937l-1.34,16.886a4.885,4.885,0,0,0,4.87,5.259H71.926a4.884,4.884,0,0,0,4.87-5.261Zm-7.92-8.6-4.544,4.544a.878.878,0,0,1-1.243,0l-2.13-2.13A.878.878,0,0,1,62.2,112.4l1.509,1.508,3.923-3.923a.879.879,0,1,1,1.242,1.243Z\",\n              transform: \"translate(-53.023 -101.005)\",\n              fill: color\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 18,\n              columnNumber: 15\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 17,\n            columnNumber: 13\n          }, _this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 16,\n          columnNumber: 11\n        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n          \"data-name\": \"Group 19\",\n          transform: \"translate(59.118)\",\n          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"g\", {\n            \"data-name\": \"Group 18\",\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"path\", {\n              \"data-name\": \"Path 4\",\n              d: \"M162.838,0a5.806,5.806,0,0,0-5.8,5.8v.119H158.8V5.8a4.042,4.042,0,1,1,8.083,0v.119h1.757V5.8A5.806,5.806,0,0,0,162.838,0Z\",\n              transform: \"translate(-157.039)\",\n              fill: color\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 28,\n              columnNumber: 15\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 27,\n            columnNumber: 13\n          }, _this)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 26,\n          columnNumber: 11\n        }, _this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 15,\n        columnNumber: 9\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 14,\n      columnNumber: 7\n    }, _this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 8,\n    columnNumber: 5\n  }, _this);\n};\n_c = ShoppingBagLarge;\n\nvar _c;\n\n$RefreshReg$(_c, \"ShoppingBagLarge\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2Fzc2V0cy9pY29ucy9TaG9wcGluZ0JhZ0xhcmdlLnRzeD8wMmUzIl0sIm5hbWVzIjpbIlNob3BwaW5nQmFnTGFyZ2UiLCJjb2xvciIsIndpZHRoIiwiaGVpZ2h0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ08sSUFBTUEsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixPQUkxQjtBQUFBLHdCQUhKQyxLQUdJO0FBQUEsTUFISkEsS0FHSSwyQkFISSxjQUdKO0FBQUEsd0JBRkpDLEtBRUk7QUFBQSxNQUZKQSxLQUVJLDJCQUZJLE1BRUo7QUFBQSx5QkFESkMsTUFDSTtBQUFBLE1BREpBLE1BQ0ksNEJBREssTUFDTDtBQUNKLHNCQUNFO0FBQ0UsU0FBSyxFQUFDLDRCQURSO0FBRUUsU0FBSyxFQUFFRCxLQUZUO0FBR0UsVUFBTSxFQUFFQyxNQUhWO0FBSUUsV0FBTyxFQUFDLGVBSlY7QUFBQSwyQkFNRTtBQUFHLG1CQUFVLGtCQUFiO0FBQWdDLGVBQVMsRUFBQyxvQkFBMUM7QUFBQSw2QkFDRTtBQUFHLHFCQUFVLFlBQWI7QUFBQSxnQ0FDRTtBQUFHLHVCQUFVLFVBQWI7QUFBd0IsbUJBQVMsRUFBQyx5QkFBbEM7QUFBQSxpQ0FDRTtBQUFHLHlCQUFVLFVBQWI7QUFBQSxtQ0FDRTtBQUNFLDJCQUFVLFFBRFo7QUFFRSxlQUFDLEVBQUMsbVlBRko7QUFHRSx1QkFBUyxFQUFDLDZCQUhaO0FBSUUsa0JBQUksRUFBRUY7QUFKUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBREYsZUFXRTtBQUFHLHVCQUFVLFVBQWI7QUFBd0IsbUJBQVMsRUFBQyxtQkFBbEM7QUFBQSxpQ0FDRTtBQUFHLHlCQUFVLFVBQWI7QUFBQSxtQ0FDRTtBQUNFLDJCQUFVLFFBRFo7QUFFRSxlQUFDLEVBQUMsMkhBRko7QUFHRSx1QkFBUyxFQUFDLHFCQUhaO0FBSUUsa0JBQUksRUFBRUE7QUFKUjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBWEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU5GO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERjtBQWlDRCxDQXRDTTtLQUFNRCxnQiIsImZpbGUiOiIuL3NyYy9hc3NldHMvaWNvbnMvU2hvcHBpbmdCYWdMYXJnZS50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IFNob3BwaW5nQmFnTGFyZ2UgPSAoe1xuICBjb2xvciA9ICdjdXJyZW50Q29sb3InLFxuICB3aWR0aCA9ICcxOHB4JyxcbiAgaGVpZ2h0ID0gJzE4cHgnLFxufSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZydcbiAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgIGhlaWdodD17aGVpZ2h0fVxuICAgICAgdmlld0JveD0nMCAwIDIzLjc4NiAzMCdcbiAgICA+XG4gICAgICA8ZyBkYXRhLW5hbWU9J3Nob3BwaW5nLWJhZyAoMyknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC01My4wMjMpJz5cbiAgICAgICAgPGcgZGF0YS1uYW1lPSdHcm91cCAyNzA0Jz5cbiAgICAgICAgICA8ZyBkYXRhLW5hbWU9J0dyb3VwIDE3JyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSg1My4wMjMgNS45MTgpJz5cbiAgICAgICAgICAgIDxnIGRhdGEtbmFtZT0nR3JvdXAgMTYnPlxuICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgIGRhdGEtbmFtZT0nUGF0aCAzJ1xuICAgICAgICAgICAgICAgIGQ9J003Ni44LDExOS44MjZsLTEuMzQtMTYuODgxQTIuMTA5LDIuMTA5LDAsMCwwLDczLjM2MiwxMDFINzAuNzE2djMuOTIxYS44NzkuODc5LDAsMSwxLTEuNzU3LDBWMTAxSDYwLjg3NXYzLjkyMWEuODc5Ljg3OSwwLDEsMS0xLjc1NywwVjEwMUg1Ni40NzJhMi4xMDksMi4xMDksMCwwLDAtMi4wOTQsMS45MzdsLTEuMzQsMTYuODg2YTQuODg1LDQuODg1LDAsMCwwLDQuODcsNS4yNTlINzEuOTI2YTQuODg0LDQuODg0LDAsMCwwLDQuODctNS4yNjFabS03LjkyLTguNi00LjU0NCw0LjU0NGEuODc4Ljg3OCwwLDAsMS0xLjI0MywwbC0yLjEzLTIuMTNBLjg3OC44NzgsMCwwLDEsNjIuMiwxMTIuNGwxLjUwOSwxLjUwOCwzLjkyMy0zLjkyM2EuODc5Ljg3OSwwLDEsMSwxLjI0MiwxLjI0M1onXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUzLjAyMyAtMTAxLjAwNSknXG4gICAgICAgICAgICAgICAgZmlsbD17Y29sb3J9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgPC9nPlxuICAgICAgICAgIDxnIGRhdGEtbmFtZT0nR3JvdXAgMTknIHRyYW5zZm9ybT0ndHJhbnNsYXRlKDU5LjExOCknPlxuICAgICAgICAgICAgPGcgZGF0YS1uYW1lPSdHcm91cCAxOCc+XG4gICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgZGF0YS1uYW1lPSdQYXRoIDQnXG4gICAgICAgICAgICAgICAgZD0nTTE2Mi44MzgsMGE1LjgwNiw1LjgwNiwwLDAsMC01LjgsNS44di4xMTlIMTU4LjhWNS44YTQuMDQyLDQuMDQyLDAsMSwxLDguMDgzLDB2LjExOWgxLjc1N1Y1LjhBNS44MDYsNS44MDYsMCwwLDAsMTYyLjgzOCwwWidcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtMTU3LjAzOSknXG4gICAgICAgICAgICAgICAgZmlsbD17Y29sb3J9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgICAgPC9nPlxuICAgICAgICA8L2c+XG4gICAgICA8L2c+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/assets/icons/ShoppingBagLarge.tsx\n");

/***/ }),

/***/ "./src/components/button/button.tsx":
/*!******************************************!*\
  !*** ./src/components/button/button.tsx ***!
  \******************************************/
/*! exports provided: StyledButton, Button */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StyledButton\", function() { return StyledButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Button\", function() { return Button; });\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @styled-system/css */ \"../../node_modules/@styled-system/css/dist/index.esm.js\");\n/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! styled-system */ \"../../node_modules/styled-system/dist/index.esm.js\");\n\n\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/components/button/button.tsx\",\n    _this = undefined;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\n\n\nvar StyledButton = styled_components__WEBPACK_IMPORTED_MODULE_4__[\"default\"].button.withConfig({\n  displayName: \"button__StyledButton\",\n  componentId: \"sc-1mky0hn-0\"\n})(_c = function _c(props) {\n  return Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n    px: '15px',\n    py: 0,\n    fontSize: ['base'],\n    fontWeight: 'bold',\n    cursor: props.disabled ? 'not-allowed' : 'pointer',\n    color: props.disabled ? 'text.light' : 'white',\n    bg: props.disabled ? 'gray.500' : 'primary.regular',\n    transition: 'all 0.3s ease',\n    borderRadius: 'base',\n    '&:hover': {\n      color: props.disabled ? 'text.light' : 'white',\n      bg: props.disabled ? 'gray.500' : 'primary.hover'\n    }\n  });\n}, {\n  appearance: 'none',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  flexShrink: 0,\n  textAlign: 'center',\n  height: '38px',\n  textDecoration: 'none',\n  fontFamily: 'inherit',\n  border: 0,\n  '&:focus': {\n    outline: 'none'\n  }\n}, Object(styled_system__WEBPACK_IMPORTED_MODULE_6__[\"variant\"])({\n  variants: {\n    outlined: {\n      color: 'primary.regular',\n      bg: 'white',\n      border: '1px solid',\n      borderColor: 'gray.500',\n      '&:hover': {\n        borderColor: 'primary.regular',\n        color: 'primary.regular',\n        bg: 'white'\n      }\n    },\n    primary: {\n      color: 'white',\n      bg: 'primary.regular',\n      '&:hover': {\n        bg: 'primary.hover'\n      }\n    },\n    secondary: {\n      color: 'primary.regular',\n      bg: 'white',\n      border: '2px solid',\n      borderColor: 'gray.500',\n      '&:hover': {\n        color: 'white',\n        bg: 'primary.regular',\n        borderColor: 'primary.regular'\n      }\n    },\n    text: {\n      color: 'primary.regular',\n      bg: 'transparent',\n      '&:hover': {\n        bg: 'transparent',\n        color: 'primary.hover'\n      }\n    },\n    select: {\n      width: 26,\n      height: 26,\n      lineHeight: 1,\n      flexShrink: 0,\n      border: '1px solid',\n      borderColor: 'text.regular',\n      borderRadius: 13,\n      padding: 0,\n      color: 'text.bold',\n      bg: 'transparent',\n      '&.selected': {\n        bg: 'primary.regular',\n        color: 'white',\n        borderColor: 'primary.regular'\n      },\n      '&:hover:not(.selected)': {\n        bg: 'transparent',\n        color: 'primary.regular',\n        borderColor: 'primary.regular'\n      }\n    }\n  }\n}), Object(styled_system__WEBPACK_IMPORTED_MODULE_6__[\"variant\"])({\n  prop: 'size',\n  variants: {\n    big: {\n      height: '48px',\n      px: 30\n    },\n    small: {\n      height: '30px',\n      fontSize: 14\n    }\n  }\n}), Object(styled_system__WEBPACK_IMPORTED_MODULE_6__[\"compose\"])(styled_system__WEBPACK_IMPORTED_MODULE_6__[\"border\"], styled_system__WEBPACK_IMPORTED_MODULE_6__[\"space\"], styled_system__WEBPACK_IMPORTED_MODULE_6__[\"layout\"]));\n_c2 = StyledButton;\nvar rotate = Object(styled_components__WEBPACK_IMPORTED_MODULE_4__[\"keyframes\"])([\"from{transform:rotate(0deg);}to{transform:rotate(360deg);}\"]);\nvar Spinner = styled_components__WEBPACK_IMPORTED_MODULE_4__[\"default\"].div.withConfig({\n  displayName: \"button__Spinner\",\n  componentId: \"sc-1mky0hn-1\"\n})(_c3 = function _c3(props) {\n  return Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n    width: 18,\n    height: 18,\n    marginLeft: 10,\n    border: '3px solid white',\n    borderTop: \"3px solid \".concat(props.color ? props.color : 'primary.regular'),\n    borderRadius: '50%',\n    transitionProperty: 'transform'\n  });\n}, Object(styled_components__WEBPACK_IMPORTED_MODULE_4__[\"css\"])([\"animation:\", \" 1.2s infinite linear;\"], rotate));\n_c4 = Spinner;\nvar Button = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default.a.forwardRef(_c5 = function _c5(_ref, ref) {\n  var children = _ref.children,\n      disabled = _ref.disabled,\n      _ref$loading = _ref.loading,\n      loading = _ref$loading === void 0 ? false : _ref$loading,\n      props = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_ref, [\"children\", \"disabled\", \"loading\"]);\n\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__[\"jsxDEV\"])(StyledButton, _objectSpread(_objectSpread({\n    ref: ref\n  }, props), {}, {\n    disabled: disabled,\n    children: [children, loading && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_1__[\"jsxDEV\"])(Spinner, {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 151,\n      columnNumber: 19\n    }, _this)]\n  }), void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 149,\n    columnNumber: 5\n  }, _this);\n});\n_c6 = Button;\n\nvar _c, _c2, _c3, _c4, _c5, _c6;\n\n$RefreshReg$(_c, \"StyledButton$styled.button\");\n$RefreshReg$(_c2, \"StyledButton\");\n$RefreshReg$(_c3, \"Spinner$styled.div\");\n$RefreshReg$(_c4, \"Spinner\");\n$RefreshReg$(_c5, \"Button$React.forwardRef\");\n$RefreshReg$(_c6, \"Button\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvYnV0dG9uL2J1dHRvbi50c3g/MDdhZiJdLCJuYW1lcyI6WyJTdHlsZWRCdXR0b24iLCJzdHlsZWQiLCJidXR0b24iLCJwcm9wcyIsInN5c3RlbUNzcyIsInB4IiwicHkiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJjdXJzb3IiLCJkaXNhYmxlZCIsImNvbG9yIiwiYmciLCJ0cmFuc2l0aW9uIiwiYm9yZGVyUmFkaXVzIiwiYXBwZWFyYW5jZSIsImRpc3BsYXkiLCJhbGlnbkl0ZW1zIiwianVzdGlmeUNvbnRlbnQiLCJmbGV4U2hyaW5rIiwidGV4dEFsaWduIiwiaGVpZ2h0IiwidGV4dERlY29yYXRpb24iLCJmb250RmFtaWx5IiwiYm9yZGVyIiwib3V0bGluZSIsInZhcmlhbnQiLCJ2YXJpYW50cyIsIm91dGxpbmVkIiwiYm9yZGVyQ29sb3IiLCJwcmltYXJ5Iiwic2Vjb25kYXJ5IiwidGV4dCIsInNlbGVjdCIsIndpZHRoIiwibGluZUhlaWdodCIsInBhZGRpbmciLCJwcm9wIiwiYmlnIiwic21hbGwiLCJjb21wb3NlIiwic3BhY2UiLCJsYXlvdXQiLCJyb3RhdGUiLCJrZXlmcmFtZXMiLCJTcGlubmVyIiwiZGl2IiwibWFyZ2luTGVmdCIsImJvcmRlclRvcCIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsImNzcyIsIkJ1dHRvbiIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInJlZiIsImNoaWxkcmVuIiwibG9hZGluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVPLElBQU1BLFlBQVksR0FBR0MseURBQU0sQ0FBQ0MsTUFBVjtBQUFBO0FBQUE7QUFBQSxRQUN2QixZQUFDQyxLQUFEO0FBQUEsU0FDRUMsa0VBQVMsQ0FBQztBQUNSQyxNQUFFLEVBQUUsTUFESTtBQUVSQyxNQUFFLEVBQUUsQ0FGSTtBQUdSQyxZQUFRLEVBQUUsQ0FBQyxNQUFE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LEVBRUdDLE9BQU8saUJBQUkscUVBQUMsT0FBRDtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBRmQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBREY7QUFBQSxDQURvQixDQUFmO01BQU1MLE0iLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9idXR0b24vYnV0dG9uLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgc3R5bGVkLCB7IGtleWZyYW1lcywgY3NzIH0gZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IHN5c3RlbUNzcyBmcm9tICdAc3R5bGVkLXN5c3RlbS9jc3MnO1xuaW1wb3J0IHsgY29tcG9zZSwgdmFyaWFudCwgYm9yZGVyLCBzcGFjZSwgbGF5b3V0IH0gZnJvbSAnc3R5bGVkLXN5c3RlbSc7XG5cbmV4cG9ydCBjb25zdCBTdHlsZWRCdXR0b24gPSBzdHlsZWQuYnV0dG9uKFxuICAocHJvcHMpID0+XG4gICAgc3lzdGVtQ3NzKHtcbiAgICAgIHB4OiAnMTVweCcsXG4gICAgICBweTogMCxcbiAgICAgIGZvbnRTaXplOiBbJ2Jhc2UnXSxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIGN1cnNvcjogcHJvcHMuZGlzYWJsZWQgPyAnbm90LWFsbG93ZWQnIDogJ3BvaW50ZXInLFxuICAgICAgY29sb3I6IHByb3BzLmRpc2FibGVkID8gJ3RleHQubGlnaHQnIDogJ3doaXRlJyxcbiAgICAgIGJnOiBwcm9wcy5kaXNhYmxlZCA/ICdncmF5LjUwMCcgOiAncHJpbWFyeS5yZWd1bGFyJyxcbiAgICAgIHRyYW5zaXRpb246ICdhbGwgMC4zcyBlYXNlJyxcbiAgICAgIGJvcmRlclJhZGl1czogJ2Jhc2UnLFxuXG4gICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgY29sb3I6IHByb3BzLmRpc2FibGVkID8gJ3RleHQubGlnaHQnIDogJ3doaXRlJyxcbiAgICAgICAgYmc6IHByb3BzLmRpc2FibGVkID8gJ2dyYXkuNTAwJyA6ICdwcmltYXJ5LmhvdmVyJyxcbiAgICAgIH0sXG4gICAgfSksXG4gIHtcbiAgICBhcHBlYXJhbmNlOiAnbm9uZScsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICBmbGV4U2hyaW5rOiAwLFxuICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgaGVpZ2h0OiAnMzhweCcsXG4gICAgdGV4dERlY29yYXRpb246ICdub25lJyxcbiAgICBmb250RmFtaWx5OiAnaW5oZXJpdCcsXG4gICAgYm9yZGVyOiAwLFxuXG4gICAgJyY6Zm9jdXMnOiB7XG4gICAgICBvdXRsaW5lOiAnbm9uZScsXG4gICAgfSxcbiAgfSxcbiAgdmFyaWFudCh7XG4gICAgdmFyaWFudHM6IHtcbiAgICAgIG91dGxpbmVkOiB7XG4gICAgICAgIGNvbG9yOiAncHJpbWFyeS5yZWd1bGFyJyxcbiAgICAgICAgYmc6ICd3aGl0ZScsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCcsXG4gICAgICAgIGJvcmRlckNvbG9yOiAnZ3JheS41MDAnLFxuICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogJ3ByaW1hcnkucmVndWxhcicsXG4gICAgICAgICAgY29sb3I6ICdwcmltYXJ5LnJlZ3VsYXInLFxuICAgICAgICAgIGJnOiAnd2hpdGUnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgIGJnOiAncHJpbWFyeS5yZWd1bGFyJyxcbiAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgYmc6ICdwcmltYXJ5LmhvdmVyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBzZWNvbmRhcnk6IHtcbiAgICAgICAgY29sb3I6ICdwcmltYXJ5LnJlZ3VsYXInLFxuICAgICAgICBiZzogJ3doaXRlJyxcbiAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICdncmF5LjUwMCcsXG4gICAgICAgICcmOmhvdmVyJzoge1xuICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgIGJnOiAncHJpbWFyeS5yZWd1bGFyJyxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJ3ByaW1hcnkucmVndWxhcicsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdGV4dDoge1xuICAgICAgICBjb2xvcjogJ3ByaW1hcnkucmVndWxhcicsXG4gICAgICAgIGJnOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICBiZzogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgICBjb2xvcjogJ3ByaW1hcnkuaG92ZXInLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHNlbGVjdDoge1xuICAgICAgICB3aWR0aDogMjYsXG4gICAgICAgIGhlaWdodDogMjYsXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEsXG4gICAgICAgIGZsZXhTaHJpbms6IDAsXG4gICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCcsXG4gICAgICAgIGJvcmRlckNvbG9yOiAndGV4dC5yZWd1bGFyJyxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAxMyxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgY29sb3I6ICd0ZXh0LmJvbGQnLFxuICAgICAgICBiZzogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgJyYuc2VsZWN0ZWQnOiB7XG4gICAgICAgICAgYmc6ICdwcmltYXJ5LnJlZ3VsYXInLFxuICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAncHJpbWFyeS5yZWd1bGFyJyxcbiAgICAgICAgfSxcbiAgICAgICAgJyY6aG92ZXI6bm90KC5zZWxlY3RlZCknOiB7XG4gICAgICAgICAgYmc6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgY29sb3I6ICdwcmltYXJ5LnJlZ3VsYXInLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAncHJpbWFyeS5yZWd1bGFyJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSksXG4gIHZhcmlhbnQoe1xuICAgIHByb3A6ICdzaXplJyxcbiAgICB2YXJpYW50czoge1xuICAgICAgYmlnOiB7XG4gICAgICAgIGhlaWdodDogJzQ4cHgnLFxuICAgICAgICBweDogMzAsXG4gICAgICB9LFxuICAgICAgc21hbGw6IHtcbiAgICAgICAgaGVpZ2h0OiAnMzBweCcsXG4gICAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSksXG4gIGNvbXBvc2UoYm9yZGVyLCBzcGFjZSwgbGF5b3V0KVxuKTtcbmNvbnN0IHJvdGF0ZSA9IGtleWZyYW1lc2BcbiAgZnJvbSB7dHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7fVxuICB0byB7dHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTt9XG5gO1xuXG5jb25zdCBTcGlubmVyID0gc3R5bGVkLmRpdihcbiAgKHByb3BzKSA9PlxuICAgIHN5c3RlbUNzcyh7XG4gICAgICB3aWR0aDogMTgsXG4gICAgICBoZWlnaHQ6IDE4LFxuICAgICAgbWFyZ2luTGVmdDogMTAsXG4gICAgICBib3JkZXI6ICczcHggc29saWQgd2hpdGUnLFxuICAgICAgYm9yZGVyVG9wOiBgM3B4IHNvbGlkICR7cHJvcHMuY29sb3IgPyBwcm9wcy5jb2xvciA6ICdwcmltYXJ5LnJlZ3VsYXInfWAsXG4gICAgICBib3JkZXJSYWRpdXM6ICc1MCUnLFxuICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiAndHJhbnNmb3JtJyxcbiAgICB9KSxcbiAgY3NzYFxuICAgIGFuaW1hdGlvbjogJHtyb3RhdGV9IDEuMnMgaW5maW5pdGUgbGluZWFyO1xuICBgXG4pO1xuXG50eXBlIFByb3BzID0ge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xuICBsb2FkaW5nPzogYm9vbGVhbjtcbiAgZGlzYWJsZWQ/OiBib29sZWFuO1xuICB0eXBlOiAnc3VibWl0JyB8ICdidXR0b24nO1xuICBba2V5OiBzdHJpbmddOiB1bmtub3duO1xufTtcbmV4cG9ydCB0eXBlIFJlZiA9IEhUTUxCdXR0b25FbGVtZW50O1xuZXhwb3J0IGNvbnN0IEJ1dHRvbiA9IFJlYWN0LmZvcndhcmRSZWY8UmVmLCBQcm9wcz4oXG4gICh7IGNoaWxkcmVuLCBkaXNhYmxlZCwgbG9hZGluZyA9IGZhbHNlLCAuLi5wcm9wcyB9LCByZWYpID0+IChcbiAgICA8U3R5bGVkQnV0dG9uIHJlZj17cmVmfSB7Li4ucHJvcHN9IGRpc2FibGVkPXtkaXNhYmxlZH0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgICB7bG9hZGluZyAmJiA8U3Bpbm5lciAvPn1cbiAgICA8L1N0eWxlZEJ1dHRvbj5cbiAgKVxuKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/button/button.tsx\n");

/***/ }),

/***/ "./src/components/cart-item/cart-item.style.tsx":
/*!******************************************************!*\
  !*** ./src/components/cart-item/cart-item.style.tsx ***!
  \******************************************************/
/*! exports provided: ItemBox, Information, Image, Name, Price, Weight, Total, RemoveButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemBox\", function() { return ItemBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Information\", function() { return Information; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Image\", function() { return Image; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Name\", function() { return Name; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Price\", function() { return Price; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Weight\", function() { return Weight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Total\", function() { return Total; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RemoveButton\", function() { return RemoveButton; });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @styled-system/css */ \"../../node_modules/@styled-system/css/dist/index.esm.js\");\n\n\nvar ItemBox = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cart-itemstyle__ItemBox\",\n  componentId: \"sc-1mtcak2-0\"\n})(Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  fontSize: 'base',\n  fontWeight: 'bold',\n  py: 15,\n  px: 25,\n  borderBottom: \"1px solid\",\n  borderBottomColor: 'gray.200'\n}), {\n  display: 'flex',\n  alignItems: 'center'\n});\nvar Information = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cart-itemstyle__Information\",\n  componentId: \"sc-1mtcak2-1\"\n})({\n  display: 'flex',\n  flexDirection: 'column',\n  marginLeft: '15px'\n});\nvar Image = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].img.withConfig({\n  displayName: \"cart-itemstyle__Image\",\n  componentId: \"sc-1mtcak2-2\"\n})({\n  width: 60,\n  height: 60,\n  objectFit: 'cover',\n  margin: '0 15px'\n});\nvar Name = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cart-itemstyle__Name\",\n  componentId: \"sc-1mtcak2-3\"\n})(Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  fontWeight: 'md',\n  color: 'text.bold',\n  mb: '0px',\n  lineHeight: 1.5\n}));\nvar Price = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cart-itemstyle__Price\",\n  componentId: \"sc-1mtcak2-4\"\n})(Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  color: 'primary.regular',\n  mt: '10px',\n  mb: '10px'\n}));\nvar Weight = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cart-itemstyle__Weight\",\n  componentId: \"sc-1mtcak2-5\"\n})(Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  fontSize: 'sm',\n  fontWeight: 'regular',\n  color: 'text.regular',\n  mb: '5px'\n}));\nvar Total = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cart-itemstyle__Total\",\n  componentId: \"sc-1mtcak2-6\"\n})(Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  color: 'text.bold',\n  ml: 'auto'\n}));\nvar RemoveButton = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].button.withConfig({\n  displayName: \"cart-itemstyle__RemoveButton\",\n  componentId: \"sc-1mtcak2-7\"\n})({\n  padding: '5px',\n  border: 0,\n  outline: 0,\n  marginLeft: '15px',\n  cursor: 'pointer',\n  color: 'rgba(0, 0, 0, 0.25)',\n  transition: 'all 0.4s ease',\n  backgroundColor: 'transparent',\n  '&:hover': {\n    color: 'red'\n  }\n});\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY2FydC1pdGVtL2NhcnQtaXRlbS5zdHlsZS50c3g/MjI3YSJdLCJuYW1lcyI6WyJJdGVtQm94Iiwic3R5bGVkIiwiZGl2IiwiY3NzIiwiZm9udFNpemUiLCJmb250V2VpZ2h0IiwicHkiLCJweCIsImJvcmRlckJvdHRvbSIsImJvcmRlckJvdHRvbUNvbG9yIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJJbmZvcm1hdGlvbiIsImZsZXhEaXJlY3Rpb24iLCJtYXJnaW5MZWZ0IiwiSW1hZ2UiLCJpbWciLCJ3aWR0aCIsImhlaWdodCIsIm9iamVjdEZpdCIsIm1hcmdpbiIsIk5hbWUiLCJzcGFuIiwiY29sb3IiLCJtYiIsImxpbmVIZWlnaHQiLCJQcmljZSIsIm10IiwiV2VpZ2h0IiwiVG90YWwiLCJtbCIsIlJlbW92ZUJ1dHRvbiIsImJ1dHRvbiIsInBhZGRpbmciLCJib3JkZXIiLCJvdXRsaW5lIiwiY3Vyc29yIiwidHJhbnNpdGlvbiIsImJhY2tncm91bmRDb2xvciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDTyxJQUFNQSxPQUFPLEdBQUdDLHlEQUFNLENBQUNDLEdBQVY7QUFBQTtBQUFBO0FBQUEsR0FDbEJDLGtFQUFHLENBQUM7QUFDRkMsVUFBUSxFQUFFLE1BRFI7QUFFRkMsWUFBVSxFQUFFLE1BRlY7QUFHRkMsSUFBRSxFQUFFLEVBSEY7QUFJRkMsSUFBRSxFQUFFLEVBSkY7QUFLRkMsY0FBWSxhQUxWO0FBTUZDLG1CQUFpQixFQUFFO0FBTmpCLENBQUQsQ0FEZSxFQVNsQjtBQUNFQyxTQUFPLEVBQUUsTUFEWDtBQUVFQyxZQUFVLEVBQUU7QUFGZCxDQVRrQixDQUFiO0FBY0EsSUFBTUMsV0FBVyxHQUFHWCx5REFBTSxDQUFDQyxHQUFWO0FBQUE7QUFBQTtBQUFBLEdBQWM7QUFDcENRLFNBQU8sRUFBRSxNQUQyQjtBQUVwQ0csZUFBYSxFQUFFLFFBRnFCO0FBR3BDQyxZQUFVLEVBQUU7QUFId0IsQ0FBZCxDQUFqQjtBQUtBLElBQU1DLEtBQUssR0FBR2QseURBQU0sQ0FBQ2UsR0FBVjtBQUFBO0FBQUE7QUFBQSxHQUFjO0FBQzlCQyxPQUFLLEVBQUUsRUFEdUI7QUFFOUJDLFFBQU0sRUFBRSxFQUZzQjtBQUc5QkMsV0FBUyxFQUFFLE9BSG1CO0FBSTlCQyxRQUFNLEVBQUU7QUFKc0IsQ0FBZCxDQUFYO0FBTUEsSUFBTUMsSUFBSSxHQUFHcEIseURBQU0sQ0FBQ3FCLElBQVY7QUFBQTtBQUFBO0FBQUEsR0FDZm5CLGtFQUFHLENBQUM7QUFDRkUsWUFBVSxFQUFFLElBRFY7QUFFRmtCLE9BQUssRUFBRSxXQUZMO0FBR0ZDLElBQUUsRUFBRSxLQUhGO0FBSUZDLFlBQVUsRUFBRTtBQUpWLENBQUQsQ0FEWSxDQUFWO0FBUUEsSUFBTUMsS0FBSyxHQUFHekIseURBQU0sQ0FBQ3FCLElBQVY7QUFBQTtBQUFBO0FBQUEsR0FDaEJuQixrRUFBRyxDQUFDO0FBQ0ZvQixPQUFLLEVBQUUsaUJBREw7QUFFRkksSUFBRSxFQUFFLE1BRkY7QUFHRkgsSUFBRSxFQUFFO0FBSEYsQ0FBRCxDQURhLENBQVg7QUFPQSxJQUFNSSxNQUFNLEdBQUczQix5REFBTSxDQUFDcUIsSUFBVjtBQUFBO0FBQUE7QUFBQSxHQUNqQm5CLGtFQUFHLENBQUM7QUFDRkMsVUFBUSxFQUFFLElBRFI7QUFFRkMsWUFBVSxFQUFFLFNBRlY7QUFHRmtCLE9BQUssRUFBRSxjQUhMO0FBSUZDLElBQUUsRUFBRTtBQUpGLENBQUQsQ0FEYyxDQUFaO0FBUUEsSUFBTUssS0FBSyxHQUFHNUIseURBQU0sQ0FBQ3FCLElBQVY7QUFBQTtBQUFBO0FBQUEsR0FDaEJuQixrRUFBRyxDQUFDO0FBQ0ZvQixPQUFLLEVBQUUsV0FETDtBQUVGTyxJQUFFLEVBQUU7QUFGRixDQUFELENBRGEsQ0FBWDtBQU9BLElBQU1DLFlBQVksR0FBRzlCLHlEQUFNLENBQUMrQixNQUFWO0FBQUE7QUFBQTtBQUFBLEdBQWlCO0FBQ3hDQyxTQUFPLEVBQUUsS0FEK0I7QUFFeENDLFFBQU0sRUFBRSxDQUZnQztBQUd4Q0MsU0FBTyxFQUFFLENBSCtCO0FBSXhDckIsWUFBVSxFQUFFLE1BSjRCO0FBS3hDc0IsUUFBTSxFQUFFLFNBTGdDO0FBTXhDYixPQUFLLEVBQUUscUJBTmlDO0FBT3hDYyxZQUFVLEVBQUUsZUFQNEI7QUFReENDLGlCQUFlLEVBQUUsYUFSdUI7QUFVeEMsYUFBVztBQUNUZixTQUFLLEVBQUU7QUFERTtBQVY2QixDQUFqQixDQUFsQiIsImZpbGUiOiIuL3NyYy9jb21wb25lbnRzL2NhcnQtaXRlbS9jYXJ0LWl0ZW0uc3R5bGUudHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlZCBmcm9tICdzdHlsZWQtY29tcG9uZW50cyc7XG5pbXBvcnQgY3NzIGZyb20gJ0BzdHlsZWQtc3lzdGVtL2Nzcyc7XG5leHBvcnQgY29uc3QgSXRlbUJveCA9IHN0eWxlZC5kaXYoXG4gIGNzcyh7XG4gICAgZm9udFNpemU6ICdiYXNlJyxcbiAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgcHk6IDE1LFxuICAgIHB4OiAyNSxcbiAgICBib3JkZXJCb3R0b206IGAxcHggc29saWRgLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiAnZ3JheS4yMDAnLFxuICB9KSxcbiAge1xuICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgfVxuKTtcbmV4cG9ydCBjb25zdCBJbmZvcm1hdGlvbiA9IHN0eWxlZC5kaXYoe1xuICBkaXNwbGF5OiAnZmxleCcsXG4gIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICBtYXJnaW5MZWZ0OiAnMTVweCcsXG59KTtcbmV4cG9ydCBjb25zdCBJbWFnZSA9IHN0eWxlZC5pbWcoe1xuICB3aWR0aDogNjAsXG4gIGhlaWdodDogNjAsXG4gIG9iamVjdEZpdDogJ2NvdmVyJyxcbiAgbWFyZ2luOiAnMCAxNXB4Jyxcbn0pO1xuZXhwb3J0IGNvbnN0IE5hbWUgPSBzdHlsZWQuc3BhbihcbiAgY3NzKHtcbiAgICBmb250V2VpZ2h0OiAnbWQnLFxuICAgIGNvbG9yOiAndGV4dC5ib2xkJyxcbiAgICBtYjogJzBweCcsXG4gICAgbGluZUhlaWdodDogMS41LFxuICB9KVxuKTtcbmV4cG9ydCBjb25zdCBQcmljZSA9IHN0eWxlZC5zcGFuKFxuICBjc3Moe1xuICAgIGNvbG9yOiAncHJpbWFyeS5yZWd1bGFyJyxcbiAgICBtdDogJzEwcHgnLFxuICAgIG1iOiAnMTBweCcsXG4gIH0pXG4pO1xuZXhwb3J0IGNvbnN0IFdlaWdodCA9IHN0eWxlZC5zcGFuKFxuICBjc3Moe1xuICAgIGZvbnRTaXplOiAnc20nLFxuICAgIGZvbnRXZWlnaHQ6ICdyZWd1bGFyJyxcbiAgICBjb2xvcjogJ3RleHQucmVndWxhcicsXG4gICAgbWI6ICc1cHgnLFxuICB9KVxuKTtcbmV4cG9ydCBjb25zdCBUb3RhbCA9IHN0eWxlZC5zcGFuKFxuICBjc3Moe1xuICAgIGNvbG9yOiAndGV4dC5ib2xkJyxcbiAgICBtbDogJ2F1dG8nLFxuICB9KVxuKTtcblxuZXhwb3J0IGNvbnN0IFJlbW92ZUJ1dHRvbiA9IHN0eWxlZC5idXR0b24oe1xuICBwYWRkaW5nOiAnNXB4JyxcbiAgYm9yZGVyOiAwLFxuICBvdXRsaW5lOiAwLFxuICBtYXJnaW5MZWZ0OiAnMTVweCcsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxuICB0cmFuc2l0aW9uOiAnYWxsIDAuNHMgZWFzZScsXG4gIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcblxuICAnJjpob3Zlcic6IHtcbiAgICBjb2xvcjogJ3JlZCcsXG4gIH0sXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/cart-item/cart-item.style.tsx\n");

/***/ }),

/***/ "./src/components/cart-item/cart-item.tsx":
/*!************************************************!*\
  !*** ./src/components/cart-item/cart-item.tsx ***!
  \************************************************/
/*! exports provided: CartItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartItem\", function() { return CartItem; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var components_counter_counter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! components/counter/counter */ \"./src/components/counter/counter.tsx\");\n/* harmony import */ var assets_icons_CloseIcon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! assets/icons/CloseIcon */ \"./src/assets/icons/CloseIcon.tsx\");\n/* harmony import */ var utils_constant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! utils/constant */ \"./src/utils/constant.ts\");\n/* harmony import */ var _cart_item_style__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cart-item.style */ \"./src/components/cart-item/cart-item.style.tsx\");\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/components/cart-item/cart-item.tsx\",\n    _this = undefined;\n\n\n\n\n\n\nvar CartItem = function CartItem(_ref) {\n  var data = _ref.data,\n      onDecrement = _ref.onDecrement,\n      onIncrement = _ref.onIncrement,\n      onRemove = _ref.onRemove;\n  var nombre = data.nombre,\n      imageURL = data.imageURL,\n      precio = data.precio,\n      precio_venta = data.precio_venta,\n      unit = data.unit,\n      quantity = data.quantity;\n  var displayPrice = precio_venta ? precio_venta : precio;\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"ItemBox\"], {\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(components_counter_counter__WEBPACK_IMPORTED_MODULE_2__[\"Counter\"], {\n      value: quantity,\n      onDecrement: onDecrement,\n      onIncrement: onIncrement,\n      variant: \"lightVertical\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"Image\"], {\n      src: imageURL\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"Information\"], {\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"Name\"], {\n        children: nombre\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 41,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"Price\"], {\n        children: [utils_constant__WEBPACK_IMPORTED_MODULE_4__[\"CURRENCY\"], displayPrice]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 42,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"Weight\"], {\n        children: [quantity, \" X \", unit]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 46,\n        columnNumber: 9\n      }, _this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"Total\"], {\n      children: [utils_constant__WEBPACK_IMPORTED_MODULE_4__[\"CURRENCY\"], (quantity * displayPrice).toFixed(0)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 50,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_item_style__WEBPACK_IMPORTED_MODULE_5__[\"RemoveButton\"], {\n      onClick: onRemove,\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_CloseIcon__WEBPACK_IMPORTED_MODULE_3__[\"CloseIcon\"], {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 55,\n        columnNumber: 9\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 7\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 32,\n    columnNumber: 5\n  }, _this);\n};\n_c = CartItem;\n\nvar _c;\n\n$RefreshReg$(_c, \"CartItem\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY2FydC1pdGVtL2NhcnQtaXRlbS50c3g/NzMyMCJdLCJuYW1lcyI6WyJDYXJ0SXRlbSIsImRhdGEiLCJvbkRlY3JlbWVudCIsIm9uSW5jcmVtZW50Iiwib25SZW1vdmUiLCJub21icmUiLCJpbWFnZVVSTCIsInByZWNpbyIsInByZWNpb192ZW50YSIsInVuaXQiLCJxdWFudGl0eSIsImRpc3BsYXlQcmljZSIsIkNVUlJFTkNZIiwidG9GaXhlZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWtCTyxJQUFNQSxRQUF5QixHQUFHLFNBQTVCQSxRQUE0QixPQUtuQztBQUFBLE1BSkpDLElBSUksUUFKSkEsSUFJSTtBQUFBLE1BSEpDLFdBR0ksUUFISkEsV0FHSTtBQUFBLE1BRkpDLFdBRUksUUFGSkEsV0FFSTtBQUFBLE1BREpDLFFBQ0ksUUFESkEsUUFDSTtBQUFBLE1BQ0lDLE1BREosR0FDK0RKLElBRC9ELENBQ0lJLE1BREo7QUFBQSxNQUNZQyxRQURaLEdBQytETCxJQUQvRCxDQUNZSyxRQURaO0FBQUEsTUFDc0JDLE1BRHRCLEdBQytETixJQUQvRCxDQUNzQk0sTUFEdEI7QUFBQSxNQUM4QkMsWUFEOUIsR0FDK0RQLElBRC9ELENBQzhCTyxZQUQ5QjtBQUFBLE1BQzRDQyxJQUQ1QyxHQUMrRFIsSUFEL0QsQ0FDNENRLElBRDVDO0FBQUEsTUFDa0RDLFFBRGxELEdBQytEVCxJQUQvRCxDQUNrRFMsUUFEbEQ7QUFFSixNQUFNQyxZQUFZLEdBQUdILFlBQVksR0FBR0EsWUFBSCxHQUFrQkQsTUFBbkQ7QUFDQSxzQkFDRSxxRUFBQyx3REFBRDtBQUFBLDRCQUNFLHFFQUFDLGtFQUFEO0FBQ0UsV0FBSyxFQUFFRyxRQURUO0FBRUUsaUJBQVcsRUFBRVIsV0FGZjtBQUdFLGlCQUFXLEVBQUVDLFdBSGY7QUFJRSxhQUFPLEVBQUM7QUFKVjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBREYsZUFPRSxxRUFBQyxzREFBRDtBQUFPLFNBQUcsRUFBRUc7QUFBWjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBUEYsZUFRRSxxRUFBQyw0REFBRDtBQUFBLDhCQUNFLHFFQUFDLHFEQUFEO0FBQUEsa0JBQU9EO0FBQVA7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQURGLGVBRUUscUVBQUMsc0RBQUQ7QUFBQSxtQkFDR08sdURBREgsRUFFR0QsWUFGSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFGRixlQU1FLHFFQUFDLHVEQUFEO0FBQUEsbUJBQ0dELFFBREgsU0FDZ0JELElBRGhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQU5GO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQVJGLGVBa0JFLHFFQUFDLHNEQUFEO0FBQUEsaUJBQ0dHLHVEQURILEVBRUcsQ0FBQ0YsUUFBUSxHQUFHQyxZQUFaLEVBQTBCRSxPQUExQixDQUFrQyxDQUFsQyxDQUZIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQWxCRixlQXNCRSxxRUFBQyw2REFBRDtBQUFjLGFBQU8sRUFBRVQsUUFBdkI7QUFBQSw2QkFDRSxxRUFBQyxnRUFBRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQXRCRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERjtBQTRCRCxDQXBDTTtLQUFNSixRIiwiZmlsZSI6Ii4vc3JjL2NvbXBvbmVudHMvY2FydC1pdGVtL2NhcnQtaXRlbS50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ291bnRlciB9IGZyb20gJ2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyJztcbmltcG9ydCB7IENsb3NlSWNvbiB9IGZyb20gJ2Fzc2V0cy9pY29ucy9DbG9zZUljb24nO1xuaW1wb3J0IHsgQ1VSUkVOQ1kgfSBmcm9tICd1dGlscy9jb25zdGFudCc7XG5pbXBvcnQge1xuICBJdGVtQm94LFxuICBJbWFnZSxcbiAgSW5mb3JtYXRpb24sXG4gIE5hbWUsXG4gIFByaWNlLFxuICBXZWlnaHQsXG4gIFRvdGFsLFxuICBSZW1vdmVCdXR0b24sXG59IGZyb20gJy4vY2FydC1pdGVtLnN0eWxlJztcblxuaW50ZXJmYWNlIFByb3BzIHtcbiAgZGF0YTogYW55O1xuICBvbkRlY3JlbWVudDogKCkgPT4gdm9pZDtcbiAgb25JbmNyZW1lbnQ6ICgpID0+IHZvaWQ7XG4gIG9uUmVtb3ZlOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgY29uc3QgQ2FydEl0ZW06IFJlYWN0LkZDPFByb3BzPiA9ICh7XG4gIGRhdGEsXG4gIG9uRGVjcmVtZW50LFxuICBvbkluY3JlbWVudCxcbiAgb25SZW1vdmUsXG59KSA9PiB7XG4gIGNvbnN0IHsgbm9tYnJlLCBpbWFnZVVSTCwgcHJlY2lvLCBwcmVjaW9fdmVudGEsIHVuaXQsIHF1YW50aXR5IH0gPSBkYXRhO1xuICBjb25zdCBkaXNwbGF5UHJpY2UgPSBwcmVjaW9fdmVudGEgPyBwcmVjaW9fdmVudGEgOiBwcmVjaW87XG4gIHJldHVybiAoXG4gICAgPEl0ZW1Cb3g+XG4gICAgICA8Q291bnRlclxuICAgICAgICB2YWx1ZT17cXVhbnRpdHl9XG4gICAgICAgIG9uRGVjcmVtZW50PXtvbkRlY3JlbWVudH1cbiAgICAgICAgb25JbmNyZW1lbnQ9e29uSW5jcmVtZW50fVxuICAgICAgICB2YXJpYW50PVwibGlnaHRWZXJ0aWNhbFwiXG4gICAgICAvPlxuICAgICAgPEltYWdlIHNyYz17aW1hZ2VVUkx9IC8+XG4gICAgICA8SW5mb3JtYXRpb24+XG4gICAgICAgIDxOYW1lPntub21icmV9PC9OYW1lPlxuICAgICAgICA8UHJpY2U+XG4gICAgICAgICAge0NVUlJFTkNZfVxuICAgICAgICAgIHtkaXNwbGF5UHJpY2V9XG4gICAgICAgIDwvUHJpY2U+XG4gICAgICAgIDxXZWlnaHQ+XG4gICAgICAgICAge3F1YW50aXR5fSBYIHt1bml0fVxuICAgICAgICA8L1dlaWdodD5cbiAgICAgIDwvSW5mb3JtYXRpb24+XG4gICAgICA8VG90YWw+XG4gICAgICAgIHtDVVJSRU5DWX1cbiAgICAgICAgeyhxdWFudGl0eSAqIGRpc3BsYXlQcmljZSkudG9GaXhlZCgwKX1cbiAgICAgIDwvVG90YWw+XG4gICAgICA8UmVtb3ZlQnV0dG9uIG9uQ2xpY2s9e29uUmVtb3ZlfT5cbiAgICAgICAgPENsb3NlSWNvbiAvPlxuICAgICAgPC9SZW1vdmVCdXR0b24+XG4gICAgPC9JdGVtQm94PlxuICApO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/cart-item/cart-item.tsx\n");

/***/ }),

/***/ "./src/components/cart-popup/cart-popup-button.tsx":
/*!*********************************************************!*\
  !*** ./src/components/cart-popup/cart-popup-button.tsx ***!
  \*********************************************************/
/*! exports provided: BoxedCartButton, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoxedCartButton\", function() { return BoxedCartButton; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _cart_popup_style__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cart-popup.style */ \"./src/components/cart-popup/cart-popup.style.tsx\");\n/* harmony import */ var assets_icons_ShoppingBag__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! assets/icons/ShoppingBag */ \"./src/assets/icons/ShoppingBag.tsx\");\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/components/cart-popup/cart-popup-button.tsx\",\n    _this = undefined;\n\n\n\n\n\nvar CartPopupButton = function CartPopupButton(_ref) {\n  var itemCount = _ref.itemCount,\n      _ref$itemPostfix = _ref.itemPostfix,\n      itemPostfix = _ref$itemPostfix === void 0 ? 'items' : _ref$itemPostfix,\n      price = _ref.price,\n      _ref$pricePrefix = _ref.pricePrefix,\n      pricePrefix = _ref$pricePrefix === void 0 ? '$' : _ref$pricePrefix,\n      style = _ref.style,\n      onClick = _ref.onClick,\n      className = _ref.className;\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_popup_style__WEBPACK_IMPORTED_MODULE_2__[\"CartPopupButtonStyled\"], {\n    style: style,\n    onClick: onClick,\n    className: className,\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_popup_style__WEBPACK_IMPORTED_MODULE_2__[\"ButtonImgBox\"], {\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_ShoppingBag__WEBPACK_IMPORTED_MODULE_3__[\"ShoppingBag\"], {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 7\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 33,\n      columnNumber: 5\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_popup_style__WEBPACK_IMPORTED_MODULE_2__[\"ItemCount\"], {\n      children: [itemCount, \" \", itemPostfix]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 36,\n      columnNumber: 5\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_popup_style__WEBPACK_IMPORTED_MODULE_2__[\"PriceBox\"], {\n      children: [pricePrefix, parseFloat(\"\".concat(price)).toFixed(0)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 5\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 32,\n    columnNumber: 3\n  }, _this);\n};\n\n_c = CartPopupButton;\nvar BoxedCartButton = function BoxedCartButton(_ref2) {\n  var itemCount = _ref2.itemCount,\n      _ref2$itemPostfix = _ref2.itemPostfix,\n      itemPostfix = _ref2$itemPostfix === void 0 ? 'items' : _ref2$itemPostfix,\n      price = _ref2.price,\n      _ref2$pricePrefix = _ref2.pricePrefix,\n      pricePrefix = _ref2$pricePrefix === void 0 ? '$' : _ref2$pricePrefix,\n      style = _ref2.style,\n      onClick = _ref2.onClick,\n      className = _ref2.className;\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_popup_style__WEBPACK_IMPORTED_MODULE_2__[\"CartPopupBoxButton\"], {\n    style: style,\n    onClick: onClick,\n    className: className,\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_popup_style__WEBPACK_IMPORTED_MODULE_2__[\"TotalItems\"], {\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_ShoppingBag__WEBPACK_IMPORTED_MODULE_3__[\"ShoppingBag\"], {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 58,\n        columnNumber: 7\n      }, _this), itemCount, \" \", itemPostfix]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 5\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_popup_style__WEBPACK_IMPORTED_MODULE_2__[\"PriceBoxAlt\"], {\n      children: [pricePrefix, parseFloat(\"\".concat(price)).toFixed(0)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 5\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 56,\n    columnNumber: 3\n  }, _this);\n};\n_c2 = BoxedCartButton;\n/* harmony default export */ __webpack_exports__[\"default\"] = (CartPopupButton);\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"CartPopupButton\");\n$RefreshReg$(_c2, \"BoxedCartButton\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY2FydC1wb3B1cC9jYXJ0LXBvcHVwLWJ1dHRvbi50c3g/MWZmZiJdLCJuYW1lcyI6WyJDYXJ0UG9wdXBCdXR0b24iLCJpdGVtQ291bnQiLCJpdGVtUG9zdGZpeCIsInByaWNlIiwicHJpY2VQcmVmaXgiLCJzdHlsZSIsIm9uQ2xpY2siLCJjbGFzc05hbWUiLCJwYXJzZUZsb2F0IiwidG9GaXhlZCIsIkJveGVkQ2FydEJ1dHRvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFTQTs7QUFZQSxJQUFNQSxlQUEwQyxHQUFHLFNBQTdDQSxlQUE2QztBQUFBLE1BQ2pEQyxTQURpRCxRQUNqREEsU0FEaUQ7QUFBQSw4QkFFakRDLFdBRmlEO0FBQUEsTUFFakRBLFdBRmlELGlDQUVuQyxPQUZtQztBQUFBLE1BR2pEQyxLQUhpRCxRQUdqREEsS0FIaUQ7QUFBQSw4QkFJakRDLFdBSmlEO0FBQUEsTUFJakRBLFdBSmlELGlDQUluQyxHQUptQztBQUFBLE1BS2pEQyxLQUxpRCxRQUtqREEsS0FMaUQ7QUFBQSxNQU1qREMsT0FOaUQsUUFNakRBLE9BTmlEO0FBQUEsTUFPakRDLFNBUGlELFFBT2pEQSxTQVBpRDtBQUFBLHNCQVNqRCxxRUFBQyx1RUFBRDtBQUF1QixTQUFLLEVBQUVGLEtBQTlCO0FBQXFDLFdBQU8sRUFBRUMsT0FBOUM7QUFBdUQsYUFBUyxFQUFFQyxTQUFsRTtBQUFBLDRCQUNFLHFFQUFDLDhEQUFEO0FBQUEsNkJBQ0UscUVBQUMsb0VBQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFERixlQUlFLHFFQUFDLDJEQUFEO0FBQUEsaUJBQ0dOLFNBREgsT0FDZUMsV0FEZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFKRixlQU9FLHFFQUFDLDBEQUFEO0FBQUEsaUJBQ0dFLFdBREgsRUFHR0ksVUFBVSxXQUFJTCxLQUFKLEVBQVYsQ0FBdUJNLE9BQXZCLENBQStCLENBQS9CLENBSEg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBUEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBVGlEO0FBQUEsQ0FBbkQ7O0tBQU1ULGU7QUF3QkMsSUFBTVUsZUFBMEMsR0FBRyxTQUE3Q0EsZUFBNkM7QUFBQSxNQUN4RFQsU0FEd0QsU0FDeERBLFNBRHdEO0FBQUEsZ0NBRXhEQyxXQUZ3RDtBQUFBLE1BRXhEQSxXQUZ3RCxrQ0FFMUMsT0FGMEM7QUFBQSxNQUd4REMsS0FId0QsU0FHeERBLEtBSHdEO0FBQUEsZ0NBSXhEQyxXQUp3RDtBQUFBLE1BSXhEQSxXQUp3RCxrQ0FJMUMsR0FKMEM7QUFBQSxNQUt4REMsS0FMd0QsU0FLeERBLEtBTHdEO0FBQUEsTUFNeERDLE9BTndELFNBTXhEQSxPQU53RDtBQUFBLE1BT3hEQyxTQVB3RCxTQU94REEsU0FQd0Q7QUFBQSxzQkFTeEQscUVBQUMsb0VBQUQ7QUFBb0IsU0FBSyxFQUFFRixLQUEzQjtBQUFrQyxXQUFPLEVBQUVDLE9BQTNDO0FBQW9ELGFBQVMsRUFBRUMsU0FBL0Q7QUFBQSw0QkFDRSxxRUFBQyw0REFBRDtBQUFBLDhCQUNFLHFFQUFDLG9FQUFEO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFERixFQUVHTixTQUZILE9BRWVDLFdBRmY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBREYsZUFLRSxxRUFBQyw2REFBRDtBQUFBLGlCQUNHRSxXQURILEVBRUdJLFVBQVUsV0FBSUwsS0FBSixFQUFWLENBQXVCTSxPQUF2QixDQUErQixDQUEvQixDQUZIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUxGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQVR3RDtBQUFBLENBQW5EO01BQU1DLGU7QUFxQkVWLDhFQUFmIiwiZmlsZSI6Ii4vc3JjL2NvbXBvbmVudHMvY2FydC1wb3B1cC9jYXJ0LXBvcHVwLWJ1dHRvbi50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgQ2FydFBvcHVwQnV0dG9uU3R5bGVkLFxuICBCdXR0b25JbWdCb3gsXG4gIEl0ZW1Db3VudCxcbiAgUHJpY2VCb3gsXG4gIENhcnRQb3B1cEJveEJ1dHRvbixcbiAgUHJpY2VCb3hBbHQsXG4gIFRvdGFsSXRlbXMsXG59IGZyb20gJy4vY2FydC1wb3B1cC5zdHlsZSc7XG5pbXBvcnQgeyBTaG9wcGluZ0JhZyB9IGZyb20gJ2Fzc2V0cy9pY29ucy9TaG9wcGluZ0JhZyc7XG5cbnR5cGUgQ2FydEJ1dHRvblByb3BzID0ge1xuICBzdHlsZT86IFJlYWN0LkNTU1Byb3BlcnRpZXM7XG4gIGl0ZW1Db3VudD86IG51bWJlcjtcbiAgaXRlbVBvc3RmaXg/OiBhbnk7XG4gIHByaWNlPzogbnVtYmVyO1xuICBwcmljZVByZWZpeD86IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBvbkNsaWNrPzogKGU6IGFueSkgPT4gdm9pZDtcbn07XG5cbmNvbnN0IENhcnRQb3B1cEJ1dHRvbjogUmVhY3QuRkM8Q2FydEJ1dHRvblByb3BzPiA9ICh7XG4gIGl0ZW1Db3VudCxcbiAgaXRlbVBvc3RmaXggPSAnaXRlbXMnLFxuICBwcmljZSxcbiAgcHJpY2VQcmVmaXggPSAnJCcsXG4gIHN0eWxlLFxuICBvbkNsaWNrLFxuICBjbGFzc05hbWUsXG59KSA9PiAoXG4gIDxDYXJ0UG9wdXBCdXR0b25TdHlsZWQgc3R5bGU9e3N0eWxlfSBvbkNsaWNrPXtvbkNsaWNrfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgPEJ1dHRvbkltZ0JveD5cbiAgICAgIDxTaG9wcGluZ0JhZyAvPlxuICAgIDwvQnV0dG9uSW1nQm94PlxuICAgIDxJdGVtQ291bnQ+XG4gICAgICB7aXRlbUNvdW50fSB7aXRlbVBvc3RmaXh9XG4gICAgPC9JdGVtQ291bnQ+XG4gICAgPFByaWNlQm94PlxuICAgICAge3ByaWNlUHJlZml4fVxuICAgICAgey8qIHtwcmljZX0gKi99XG4gICAgICB7cGFyc2VGbG9hdChgJHtwcmljZX1gKS50b0ZpeGVkKDApfVxuICAgIDwvUHJpY2VCb3g+XG4gIDwvQ2FydFBvcHVwQnV0dG9uU3R5bGVkPlxuKTtcblxuZXhwb3J0IGNvbnN0IEJveGVkQ2FydEJ1dHRvbjogUmVhY3QuRkM8Q2FydEJ1dHRvblByb3BzPiA9ICh7XG4gIGl0ZW1Db3VudCxcbiAgaXRlbVBvc3RmaXggPSAnaXRlbXMnLFxuICBwcmljZSxcbiAgcHJpY2VQcmVmaXggPSAnJCcsXG4gIHN0eWxlLFxuICBvbkNsaWNrLFxuICBjbGFzc05hbWUsXG59KSA9PiAoXG4gIDxDYXJ0UG9wdXBCb3hCdXR0b24gc3R5bGU9e3N0eWxlfSBvbkNsaWNrPXtvbkNsaWNrfSBjbGFzc05hbWU9e2NsYXNzTmFtZX0+XG4gICAgPFRvdGFsSXRlbXM+XG4gICAgICA8U2hvcHBpbmdCYWcgLz5cbiAgICAgIHtpdGVtQ291bnR9IHtpdGVtUG9zdGZpeH1cbiAgICA8L1RvdGFsSXRlbXM+XG4gICAgPFByaWNlQm94QWx0PlxuICAgICAge3ByaWNlUHJlZml4fVxuICAgICAge3BhcnNlRmxvYXQoYCR7cHJpY2V9YCkudG9GaXhlZCgwKX1cbiAgICA8L1ByaWNlQm94QWx0PlxuICA8L0NhcnRQb3B1cEJveEJ1dHRvbj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IENhcnRQb3B1cEJ1dHRvbjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/cart-popup/cart-popup-button.tsx\n");

/***/ }),

/***/ "./src/components/cart-popup/cart-popup.style.tsx":
/*!********************************************************!*\
  !*** ./src/components/cart-popup/cart-popup.style.tsx ***!
  \********************************************************/
/*! exports provided: ButtonImgBox, CartPopupButtonStyled, ItemCount, PriceBox, CartPopupBoxButton, PriceBoxAlt, TotalItems */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ButtonImgBox\", function() { return ButtonImgBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartPopupButtonStyled\", function() { return CartPopupButtonStyled; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemCount\", function() { return ItemCount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PriceBox\", function() { return PriceBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartPopupBoxButton\", function() { return CartPopupBoxButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PriceBoxAlt\", function() { return PriceBoxAlt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TotalItems\", function() { return TotalItems; });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @styled-system/theme-get */ \"../../node_modules/@styled-system/theme-get/dist/index.esm.js\");\n\n\nvar CartPopupButtonStyled = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('button').withConfig({\n  displayName: \"cart-popupstyle__CartPopupButtonStyled\",\n  componentId: \"sc-7s6zz5-0\"\n})([\"height:60px;width:auto;display:flex;align-items:center;background-color:\", \";padding:0;padding-left:30px;border-radius:60px;box-shadow:\", \";border:0;outline:0;cursor:pointer;position:fixed;bottom:50px;right:50px;z-index:999;@media (max-width:767px){width:calc(100% - 60px);height:45px;padding:2px 2px 2px 30px;bottom:30px;right:30px;}@media (min-width:581px){&:not(.fixedCartPopup){display:none;}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009E7F'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('shadows.big', '0 21px 36px rgba(0, 0, 0, 0.16)'));\nvar ButtonImgBox = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('span').withConfig({\n  displayName: \"cart-popupstyle__ButtonImgBox\",\n  componentId: \"sc-7s6zz5-1\"\n})([\"color:\", \";\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'));\nvar ItemCount = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('span').withConfig({\n  displayName: \"cart-popupstyle__ItemCount\",\n  componentId: \"sc-7s6zz5-2\"\n})([\"font-family:\", \";font-size:12px;font-weight:\", \";color:\", \";padding-left:5px;padding-right:10px;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'sans-serif'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'));\nvar PriceBox = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('span').withConfig({\n  displayName: \"cart-popupstyle__PriceBox\",\n  componentId: \"sc-7s6zz5-3\"\n})([\"width:56px;height:56px;overflow:hidden;border-radius:28px;display:inline-flex;align-items:center;justify-content:center;background-color:\", \";font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";margin-right:2px;@media (max-width:767px){width:90px;height:100%;height:41px;margin-left:auto;margin-right:0;}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'sans-serif'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.xs', '12'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009E7F'));\nvar CartPopupBoxButton = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('button').withConfig({\n  displayName: \"cart-popupstyle__CartPopupBoxButton\",\n  componentId: \"sc-7s6zz5-4\"\n})([\"height:auto;width:auto;display:flex;flex-direction:column;align-items:center;justify-content:center;background-color:\", \";padding:0;border-radius:\", \" 0 0 \", \";box-shadow:\", \";border:0;outline:0;cursor:pointer;position:fixed;right:0;top:50%;margin-top:-46px;z-index:99;@media (max-width:580px){display:none;}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009E7F'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('radii.base', '6px'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('radii.base', '6px'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('shadows.big', '0 21px 36px rgba(0, 0, 0, 0.16)'));\nvar TotalItems = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('span').withConfig({\n  displayName: \"cart-popupstyle__TotalItems\",\n  componentId: \"sc-7s6zz5-5\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";padding-left:5px;padding-right:10px;display:flex;align-items:center;justify-content:center;padding:15px 10px;svg{margin-right:10px;}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'sans-serif'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.sm', '13'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'));\nvar PriceBoxAlt = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('span').withConfig({\n  displayName: \"cart-popupstyle__PriceBoxAlt\",\n  componentId: \"sc-7s6zz5-6\"\n})([\"width:auto;height:35px;min-width:80px;overflow:hidden;border-radius:\", \";display:inline-flex;align-items:center;justify-content:center;background-color:\", \";font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";margin:0 10px 10px;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('radii.base', '6px'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'sans-serif'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.sm', '13'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009E7F'));\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY2FydC1wb3B1cC9jYXJ0LXBvcHVwLnN0eWxlLnRzeD81YzkwIl0sIm5hbWVzIjpbIkNhcnRQb3B1cEJ1dHRvblN0eWxlZCIsInN0eWxlZCIsInRoZW1lR2V0IiwiQnV0dG9uSW1nQm94IiwiSXRlbUNvdW50IiwiUHJpY2VCb3giLCJDYXJ0UG9wdXBCb3hCdXR0b24iLCJUb3RhbEl0ZW1zIiwiUHJpY2VCb3hBbHQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBLElBQU1BLHFCQUFxQixHQUFHQyxpRUFBTSxDQUFDLFFBQUQsQ0FBVDtBQUFBO0FBQUE7QUFBQSxzWkFLTEMseUVBQVEsQ0FBQyx3QkFBRCxFQUEyQixTQUEzQixDQUxILEVBU1hBLHlFQUFRLENBQUMsYUFBRCxFQUFnQixpQ0FBaEIsQ0FURyxDQUEzQjtBQWlDQSxJQUFNQyxZQUFZLEdBQUdGLGlFQUFNLENBQUMsTUFBRCxDQUFUO0FBQUE7QUFBQTtBQUFBLG9CQUNQQyx5RUFBUSxDQUFDLGNBQUQsRUFBaUIsU0FBakIsQ0FERCxDQUFsQjtBQUlBLElBQU1FLFNBQVMsR0FBR0gsaUVBQU0sQ0FBQyxNQUFELENBQVQ7QUFBQTtBQUFBO0FBQUEseUdBQ0VDLHlFQUFRLENBQUMsWUFBRCxFQUFlLFlBQWYsQ0FEVixFQUdFQSx5RUFBUSxDQUFDLGtCQUFELEVBQXFCLEtBQXJCLENBSFYsRUFJSkEseUVBQVEsQ0FBQyxjQUFELEVBQWlCLFNBQWpCLENBSkosQ0FBZjtBQVNBLElBQU1HLFFBQVEsR0FBR0osaUVBQU0sQ0FBQyxNQUFELENBQVQ7QUFBQTtBQUFBO0FBQUEsbVVBUVFDLHlFQUFRLENBQUMsY0FBRCxFQUFpQixTQUFqQixDQVJoQixFQVNHQSx5RUFBUSxDQUFDLFlBQUQsRUFBZSxZQUFmLENBVFgsRUFVQ0EseUVBQVEsQ0FBQyxjQUFELEVBQWlCLElBQWpCLENBVlQsRUFXR0EseUVBQVEsQ0FBQyxrQkFBRCxFQUFxQixLQUFyQixDQVhYLEVBWUhBLHlFQUFRLENBQUMsd0JBQUQsRUFBMkIsU0FBM0IsQ0FaTCxDQUFkO0FBd0JBLElBQU1JLGtCQUFrQixHQUFHTCxpRUFBTSxDQUFDLFFBQUQsQ0FBVDtBQUFBO0FBQUE7QUFBQSw2VEFPRkMseUVBQVEsQ0FBQyx3QkFBRCxFQUEyQixTQUEzQixDQVBOLEVBU0xBLHlFQUFRLENBQUMsWUFBRCxFQUFlLEtBQWYsQ0FUSCxFQVVsQkEseUVBQVEsQ0FBQyxZQUFELEVBQWUsS0FBZixDQVZVLEVBV1JBLHlFQUFRLENBQUMsYUFBRCxFQUFnQixpQ0FBaEIsQ0FYQSxDQUF4QjtBQTBCQSxJQUFNSyxVQUFVLEdBQUdOLGlFQUFNLENBQUMsTUFBRCxDQUFUO0FBQUE7QUFBQTtBQUFBLDJNQUNDQyx5RUFBUSxDQUFDLFlBQUQsRUFBZSxZQUFmLENBRFQsRUFFREEseUVBQVEsQ0FBQyxjQUFELEVBQWlCLElBQWpCLENBRlAsRUFHQ0EseUVBQVEsQ0FBQyxrQkFBRCxFQUFxQixLQUFyQixDQUhULEVBSUxBLHlFQUFRLENBQUMsY0FBRCxFQUFpQixTQUFqQixDQUpILENBQWhCO0FBaUJBLElBQU1NLFdBQVcsR0FBR1AsaUVBQU0sQ0FBQyxNQUFELENBQVQ7QUFBQTtBQUFBO0FBQUEsdVBBS0VDLHlFQUFRLENBQUMsWUFBRCxFQUFlLEtBQWYsQ0FMVixFQVNLQSx5RUFBUSxDQUFDLGNBQUQsRUFBaUIsU0FBakIsQ0FUYixFQVVBQSx5RUFBUSxDQUFDLFlBQUQsRUFBZSxZQUFmLENBVlIsRUFXRkEseUVBQVEsQ0FBQyxjQUFELEVBQWlCLElBQWpCLENBWE4sRUFZQUEseUVBQVEsQ0FBQyxrQkFBRCxFQUFxQixLQUFyQixDQVpSLEVBYU5BLHlFQUFRLENBQUMsd0JBQUQsRUFBMkIsU0FBM0IsQ0FiRixDQUFqQjtBQWlCQSIsImZpbGUiOiIuL3NyYy9jb21wb25lbnRzL2NhcnQtcG9wdXAvY2FydC1wb3B1cC5zdHlsZS50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCB7IHRoZW1lR2V0IH0gZnJvbSAnQHN0eWxlZC1zeXN0ZW0vdGhlbWUtZ2V0JztcblxuY29uc3QgQ2FydFBvcHVwQnV0dG9uU3R5bGVkID0gc3R5bGVkKCdidXR0b24nKWBcbiAgaGVpZ2h0OiA2MHB4O1xuICB3aWR0aDogYXV0bztcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnByaW1hcnkucmVndWxhcicsICcjMDA5RTdGJyl9O1xuICBwYWRkaW5nOiAwO1xuICBwYWRkaW5nLWxlZnQ6IDMwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDYwcHg7XG4gIGJveC1zaGFkb3c6ICR7dGhlbWVHZXQoJ3NoYWRvd3MuYmlnJywgJzAgMjFweCAzNnB4IHJnYmEoMCwgMCwgMCwgMC4xNiknKX07XG4gIGJvcmRlcjogMDtcbiAgb3V0bGluZTogMDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGJvdHRvbTogNTBweDtcbiAgcmlnaHQ6IDUwcHg7XG4gIHotaW5kZXg6IDk5OTtcblxuICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICB3aWR0aDogY2FsYygxMDAlIC0gNjBweCk7XG4gICAgaGVpZ2h0OiA0NXB4O1xuICAgIHBhZGRpbmc6IDJweCAycHggMnB4IDMwcHg7XG4gICAgYm90dG9tOiAzMHB4O1xuICAgIHJpZ2h0OiAzMHB4O1xuICB9XG5cbiAgQG1lZGlhIChtaW4td2lkdGg6IDU4MXB4KSB7XG4gICAgJjpub3QoLmZpeGVkQ2FydFBvcHVwKSB7XG4gICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cbiAgfVxuYDtcblxuY29uc3QgQnV0dG9uSW1nQm94ID0gc3R5bGVkKCdzcGFuJylgXG4gIGNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbmA7XG5cbmNvbnN0IEl0ZW1Db3VudCA9IHN0eWxlZCgnc3BhbicpYFxuICBmb250LWZhbWlseTogJHt0aGVtZUdldCgnZm9udHMuYm9keScsICdzYW5zLXNlcmlmJyl9O1xuICBmb250LXNpemU6IDEycHg7XG4gIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy53aGl0ZScsICcjZmZmZmZmJyl9O1xuICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgcGFkZGluZy1yaWdodDogMTBweDtcbmA7XG5cbmNvbnN0IFByaWNlQm94ID0gc3R5bGVkKCdzcGFuJylgXG4gIHdpZHRoOiA1NnB4O1xuICBoZWlnaHQ6IDU2cHg7XG4gIG92ZXJmbG93OiBoaWRkZW47XG4gIGJvcmRlci1yYWRpdXM6IDI4cHg7XG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLndoaXRlJywgJyNmZmZmZmYnKX07XG4gIGZvbnQtZmFtaWx5OiAke3RoZW1lR2V0KCdmb250cy5ib2R5JywgJ3NhbnMtc2VyaWYnKX07XG4gIGZvbnQtc2l6ZTogJHt0aGVtZUdldCgnZm9udFNpemVzLnhzJywgJzEyJyl9cHg7XG4gIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy5wcmltYXJ5LnJlZ3VsYXInLCAnIzAwOUU3RicpfTtcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgd2lkdGg6IDkwcHg7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGhlaWdodDogNDFweDtcbiAgICBtYXJnaW4tbGVmdDogYXV0bztcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG4gIH1cbmA7XG5cbmNvbnN0IENhcnRQb3B1cEJveEJ1dHRvbiA9IHN0eWxlZCgnYnV0dG9uJylgXG4gIGhlaWdodDogYXV0bztcbiAgd2lkdGg6IGF1dG87XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMucHJpbWFyeS5yZWd1bGFyJywgJyMwMDlFN0YnKX07XG4gIHBhZGRpbmc6IDA7XG4gIGJvcmRlci1yYWRpdXM6ICR7dGhlbWVHZXQoJ3JhZGlpLmJhc2UnLCAnNnB4Jyl9IDAgMFxuICAgICR7dGhlbWVHZXQoJ3JhZGlpLmJhc2UnLCAnNnB4Jyl9O1xuICBib3gtc2hhZG93OiAke3RoZW1lR2V0KCdzaGFkb3dzLmJpZycsICcwIDIxcHggMzZweCByZ2JhKDAsIDAsIDAsIDAuMTYpJyl9O1xuICBib3JkZXI6IDA7XG4gIG91dGxpbmU6IDA7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgcG9zaXRpb246IGZpeGVkO1xuICByaWdodDogMDtcbiAgdG9wOiA1MCU7XG4gIG1hcmdpbi10b3A6IC00NnB4O1xuICB6LWluZGV4OiA5OTtcblxuICBAbWVkaWEgKG1heC13aWR0aDogNTgwcHgpIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5gO1xuXG5jb25zdCBUb3RhbEl0ZW1zID0gc3R5bGVkKCdzcGFuJylgXG4gIGZvbnQtZmFtaWx5OiAke3RoZW1lR2V0KCdmb250cy5ib2R5JywgJ3NhbnMtc2VyaWYnKX07XG4gIGZvbnQtc2l6ZTogJHt0aGVtZUdldCgnZm9udFNpemVzLnNtJywgJzEzJyl9cHg7XG4gIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy53aGl0ZScsICcjZmZmZmZmJyl9O1xuICBwYWRkaW5nLWxlZnQ6IDVweDtcbiAgcGFkZGluZy1yaWdodDogMTBweDtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBhZGRpbmc6IDE1cHggMTBweDtcblxuICBzdmcge1xuICAgIG1hcmdpbi1yaWdodDogMTBweDtcbiAgfVxuYDtcblxuY29uc3QgUHJpY2VCb3hBbHQgPSBzdHlsZWQoJ3NwYW4nKWBcbiAgd2lkdGg6IGF1dG87XG4gIGhlaWdodDogMzVweDtcbiAgbWluLXdpZHRoOiA4MHB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBib3JkZXItcmFkaXVzOiAke3RoZW1lR2V0KCdyYWRpaS5iYXNlJywgJzZweCcpfTtcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbiAgZm9udC1mYW1pbHk6ICR7dGhlbWVHZXQoJ2ZvbnRzLmJvZHknLCAnc2Fucy1zZXJpZicpfTtcbiAgZm9udC1zaXplOiAke3RoZW1lR2V0KCdmb250U2l6ZXMuc20nLCAnMTMnKX1weDtcbiAgZm9udC13ZWlnaHQ6ICR7dGhlbWVHZXQoJ2ZvbnRXZWlnaHRzLmJvbGQnLCAnNzAwJyl9O1xuICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnByaW1hcnkucmVndWxhcicsICcjMDA5RTdGJyl9O1xuICBtYXJnaW46IDAgMTBweCAxMHB4O1xuYDtcblxuZXhwb3J0IHtcbiAgQnV0dG9uSW1nQm94LFxuICBDYXJ0UG9wdXBCdXR0b25TdHlsZWQsXG4gIEl0ZW1Db3VudCxcbiAgUHJpY2VCb3gsXG4gIENhcnRQb3B1cEJveEJ1dHRvbixcbiAgUHJpY2VCb3hBbHQsXG4gIFRvdGFsSXRlbXMsXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/cart-popup/cart-popup.style.tsx\n");

/***/ }),

/***/ "./src/components/counter/counter.style.tsx":
/*!**************************************************!*\
  !*** ./src/components/counter/counter.style.tsx ***!
  \**************************************************/
/*! exports provided: CounterBox, CounterButton, CounterValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CounterBox\", function() { return CounterBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CounterButton\", function() { return CounterButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CounterValue\", function() { return CounterValue; });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @styled-system/css */ \"../../node_modules/@styled-system/css/dist/index.esm.js\");\n/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-system */ \"../../node_modules/styled-system/dist/index.esm.js\");\n\n\n\nvar CounterBox = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"counterstyle__CounterBox\",\n  componentId: \"sc-8iu0h2-0\"\n})(Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  display: 'flex',\n  backgroundColor: 'primary.regular',\n  color: 'white',\n  fontSize: 'base',\n  fontWeight: 'bold'\n}), {\n  borderRadius: 200,\n  justifyContent: 'space-between',\n  alignItems: 'center',\n  overflow: 'hidden',\n  flexShrink: 0,\n  '&:focus': {\n    outline: 'none'\n  }\n}, Object(styled_system__WEBPACK_IMPORTED_MODULE_2__[\"variant\"])({\n  variants: {\n    horizontal: {\n      width: 104,\n      height: 36\n    },\n    vertical: {\n      width: 30,\n      height: 90,\n      flexDirection: 'column-reverse'\n    },\n    lightHorizontal: {\n      width: 104,\n      height: 36,\n      backgroundColor: 'gray.200',\n      color: 'text.bold'\n    },\n    lightVertical: {\n      width: 30,\n      height: 90,\n      flexDirection: 'column-reverse',\n      backgroundColor: 'gray.200',\n      color: 'text.bold'\n    },\n    altHorizontal: {\n      width: 104,\n      height: 36,\n      borderRadius: '6px'\n    },\n    altVertical: {\n      width: 30,\n      height: 90,\n      borderRadius: '6px'\n    },\n    full: {\n      width: '100%',\n      height: 36,\n      borderRadius: '6px'\n    }\n  }\n}));\nvar CounterButton = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].button.withConfig({\n  displayName: \"counterstyle__CounterButton\",\n  componentId: \"sc-8iu0h2-1\"\n})({\n  border: 'none',\n  backgroundColor: 'transparent',\n  color: 'white',\n  display: 'flex',\n  alignItems: 'center',\n  justifyContent: 'center',\n  height: '100%',\n  padding: 10,\n  cursor: 'pointer',\n  '&:hover, &:focus': {\n    outline: 'none'\n  }\n}, Object(styled_system__WEBPACK_IMPORTED_MODULE_2__[\"variant\"])({\n  variants: {\n    lightHorizontal: {\n      color: 'text.regular'\n    },\n    lightVertical: {\n      color: 'text.regular'\n    }\n  }\n}));\nvar CounterValue = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"counterstyle__CounterValue\",\n  componentId: \"sc-8iu0h2-2\"\n})({\n  pointerEvents: 'none'\n});\nCounterValue.displayName = 'CounterValue';\nCounterButton.displayName = 'CounterButton';\nCounterBox.displayName = 'CounterBox';\nCounterBox.defaultProps = {\n  variant: 'horizontal'\n};\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyLnN0eWxlLnRzeD83NjgwIl0sIm5hbWVzIjpbIkNvdW50ZXJCb3giLCJzdHlsZWQiLCJkaXYiLCJjc3MiLCJkaXNwbGF5IiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJib3JkZXJSYWRpdXMiLCJqdXN0aWZ5Q29udGVudCIsImFsaWduSXRlbXMiLCJvdmVyZmxvdyIsImZsZXhTaHJpbmsiLCJvdXRsaW5lIiwidmFyaWFudCIsInZhcmlhbnRzIiwiaG9yaXpvbnRhbCIsIndpZHRoIiwiaGVpZ2h0IiwidmVydGljYWwiLCJmbGV4RGlyZWN0aW9uIiwibGlnaHRIb3Jpem9udGFsIiwibGlnaHRWZXJ0aWNhbCIsImFsdEhvcml6b250YWwiLCJhbHRWZXJ0aWNhbCIsImZ1bGwiLCJDb3VudGVyQnV0dG9uIiwiYnV0dG9uIiwiYm9yZGVyIiwicGFkZGluZyIsImN1cnNvciIsIkNvdW50ZXJWYWx1ZSIsInNwYW4iLCJwb2ludGVyRXZlbnRzIiwiZGlzcGxheU5hbWUiLCJkZWZhdWx0UHJvcHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ08sSUFBTUEsVUFBVSxHQUFHQyx5REFBTSxDQUFDQyxHQUFWO0FBQUE7QUFBQTtBQUFBLEdBQ3JCQyxrRUFBRyxDQUFDO0FBQ0ZDLFNBQU8sRUFBRSxNQURQO0FBRUZDLGlCQUFlLEVBQUUsaUJBRmY7QUFHRkMsT0FBSyxFQUFFLE9BSEw7QUFJRkMsVUFBUSxFQUFFLE1BSlI7QUFLRkMsWUFBVSxFQUFFO0FBTFYsQ0FBRCxDQURrQixFQVFyQjtBQUNFQyxjQUFZLEVBQUUsR0FEaEI7QUFFRUMsZ0JBQWMsRUFBRSxlQUZsQjtBQUdFQyxZQUFVLEVBQUUsUUFIZDtBQUlFQyxVQUFRLEVBQUUsUUFKWjtBQUtFQyxZQUFVLEVBQUUsQ0FMZDtBQU1FLGFBQVc7QUFDVEMsV0FBTyxFQUFFO0FBREE7QUFOYixDQVJxQixFQWtCckJDLDZEQUFPLENBQUM7QUFDTkMsVUFBUSxFQUFFO0FBQ1JDLGNBQVUsRUFBRTtBQUNWQyxXQUFLLEVBQUUsR0FERztBQUVWQyxZQUFNLEVBQUU7QUFGRSxLQURKO0FBS1JDLFlBQVEsRUFBRTtBQUNSRixXQUFLLEVBQUUsRUFEQztBQUVSQyxZQUFNLEVBQUUsRUFGQTtBQUdSRSxtQkFBYSxFQUFFO0FBSFAsS0FMRjtBQVVSQyxtQkFBZSxFQUFFO0FBQ2ZKLFdBQUssRUFBRSxHQURRO0FBRWZDLFlBQU0sRUFBRSxFQUZPO0FBR2ZkLHFCQUFlLEVBQUUsVUFIRjtBQUlmQyxXQUFLLEVBQUU7QUFKUSxLQVZUO0FBZ0JSaUIsaUJBQWEsRUFBRTtBQUNiTCxXQUFLLEVBQUUsRUFETTtBQUViQyxZQUFNLEVBQUUsRUFGSztBQUdiRSxtQkFBYSxFQUFFLGdCQUhGO0FBSWJoQixxQkFBZSxFQUFFLFVBSko7QUFLYkMsV0FBSyxFQUFFO0FBTE0sS0FoQlA7QUF1QlJrQixpQkFBYSxFQUFFO0FBQ2JOLFdBQUssRUFBRSxHQURNO0FBRWJDLFlBQU0sRUFBRSxFQUZLO0FBR2JWLGtCQUFZLEVBQUU7QUFIRCxLQXZCUDtBQTRCUmdCLGVBQVcsRUFBRTtBQUNYUCxXQUFLLEVBQUUsRUFESTtBQUVYQyxZQUFNLEVBQUUsRUFGRztBQUdYVixrQkFBWSxFQUFFO0FBSEgsS0E1Qkw7QUFpQ1JpQixRQUFJLEVBQUU7QUFDSlIsV0FBSyxFQUFFLE1BREg7QUFFSkMsWUFBTSxFQUFFLEVBRko7QUFHSlYsa0JBQVksRUFBRTtBQUhWO0FBakNFO0FBREosQ0FBRCxDQWxCYyxDQUFoQjtBQTZEQSxJQUFNa0IsYUFBYSxHQUFHMUIseURBQU0sQ0FBQzJCLE1BQVY7QUFBQTtBQUFBO0FBQUEsR0FDeEI7QUFDRUMsUUFBTSxFQUFFLE1BRFY7QUFFRXhCLGlCQUFlLEVBQUUsYUFGbkI7QUFHRUMsT0FBSyxFQUFFLE9BSFQ7QUFJRUYsU0FBTyxFQUFFLE1BSlg7QUFLRU8sWUFBVSxFQUFFLFFBTGQ7QUFNRUQsZ0JBQWMsRUFBRSxRQU5sQjtBQU9FUyxRQUFNLEVBQUUsTUFQVjtBQVFFVyxTQUFPLEVBQUUsRUFSWDtBQVNFQyxRQUFNLEVBQUUsU0FUVjtBQVVFLHNCQUFvQjtBQUNsQmpCLFdBQU8sRUFBRTtBQURTO0FBVnRCLENBRHdCLEVBZXhCQyw2REFBTyxDQUFDO0FBQ05DLFVBQVEsRUFBRTtBQUNSTSxtQkFBZSxFQUFFO0FBQ2ZoQixXQUFLLEVBQUU7QUFEUSxLQURUO0FBSVJpQixpQkFBYSxFQUFFO0FBQ2JqQixXQUFLLEVBQUU7QUFETTtBQUpQO0FBREosQ0FBRCxDQWZpQixDQUFuQjtBQTJCQSxJQUFNMEIsWUFBWSxHQUFHL0IseURBQU0sQ0FBQ2dDLElBQVY7QUFBQTtBQUFBO0FBQUEsR0FBZTtBQUN0Q0MsZUFBYSxFQUFFO0FBRHVCLENBQWYsQ0FBbEI7QUFHUEYsWUFBWSxDQUFDRyxXQUFiLEdBQTJCLGNBQTNCO0FBQ0FSLGFBQWEsQ0FBQ1EsV0FBZCxHQUE0QixlQUE1QjtBQUNBbkMsVUFBVSxDQUFDbUMsV0FBWCxHQUF5QixZQUF6QjtBQUNBbkMsVUFBVSxDQUFDb0MsWUFBWCxHQUEwQjtBQUN4QnJCLFNBQU8sRUFBRTtBQURlLENBQTFCIiwiZmlsZSI6Ii4vc3JjL2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyLnN0eWxlLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IGNzcyBmcm9tICdAc3R5bGVkLXN5c3RlbS9jc3MnO1xuaW1wb3J0IHsgdmFyaWFudCB9IGZyb20gJ3N0eWxlZC1zeXN0ZW0nO1xuZXhwb3J0IGNvbnN0IENvdW50ZXJCb3ggPSBzdHlsZWQuZGl2PGFueT4oXG4gIGNzcyh7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3ByaW1hcnkucmVndWxhcicsXG4gICAgY29sb3I6ICd3aGl0ZScsXG4gICAgZm9udFNpemU6ICdiYXNlJyxcbiAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gIH0pLFxuICB7XG4gICAgYm9yZGVyUmFkaXVzOiAyMDAsXG4gICAganVzdGlmeUNvbnRlbnQ6ICdzcGFjZS1iZXR3ZWVuJyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgZmxleFNocmluazogMCxcbiAgICAnJjpmb2N1cyc6IHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICB9LFxuICB9LFxuICB2YXJpYW50KHtcbiAgICB2YXJpYW50czoge1xuICAgICAgaG9yaXpvbnRhbDoge1xuICAgICAgICB3aWR0aDogMTA0LFxuICAgICAgICBoZWlnaHQ6IDM2LFxuICAgICAgfSxcbiAgICAgIHZlcnRpY2FsOiB7XG4gICAgICAgIHdpZHRoOiAzMCxcbiAgICAgICAgaGVpZ2h0OiA5MCxcbiAgICAgICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbi1yZXZlcnNlJyxcbiAgICAgIH0sXG4gICAgICBsaWdodEhvcml6b250YWw6IHtcbiAgICAgICAgd2lkdGg6IDEwNCxcbiAgICAgICAgaGVpZ2h0OiAzNixcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnZ3JheS4yMDAnLFxuICAgICAgICBjb2xvcjogJ3RleHQuYm9sZCcsXG4gICAgICB9LFxuICAgICAgbGlnaHRWZXJ0aWNhbDoge1xuICAgICAgICB3aWR0aDogMzAsXG4gICAgICAgIGhlaWdodDogOTAsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4tcmV2ZXJzZScsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2dyYXkuMjAwJyxcbiAgICAgICAgY29sb3I6ICd0ZXh0LmJvbGQnLFxuICAgICAgfSxcbiAgICAgIGFsdEhvcml6b250YWw6IHtcbiAgICAgICAgd2lkdGg6IDEwNCxcbiAgICAgICAgaGVpZ2h0OiAzNixcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAnNnB4JyxcbiAgICAgIH0sXG4gICAgICBhbHRWZXJ0aWNhbDoge1xuICAgICAgICB3aWR0aDogMzAsXG4gICAgICAgIGhlaWdodDogOTAsXG4gICAgICAgIGJvcmRlclJhZGl1czogJzZweCcsXG4gICAgICB9LFxuICAgICAgZnVsbDoge1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6IDM2LFxuICAgICAgICBib3JkZXJSYWRpdXM6ICc2cHgnLFxuICAgICAgfSxcbiAgICB9LFxuICB9KVxuKTtcblxuZXhwb3J0IGNvbnN0IENvdW50ZXJCdXR0b24gPSBzdHlsZWQuYnV0dG9uPGFueT4oXG4gIHtcbiAgICBib3JkZXI6ICdub25lJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgY29sb3I6ICd3aGl0ZScsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAnJjpob3ZlciwgJjpmb2N1cyc6IHtcbiAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICB9LFxuICB9LFxuICB2YXJpYW50KHtcbiAgICB2YXJpYW50czoge1xuICAgICAgbGlnaHRIb3Jpem9udGFsOiB7XG4gICAgICAgIGNvbG9yOiAndGV4dC5yZWd1bGFyJyxcbiAgICAgIH0sXG4gICAgICBsaWdodFZlcnRpY2FsOiB7XG4gICAgICAgIGNvbG9yOiAndGV4dC5yZWd1bGFyJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSlcbik7XG5cbmV4cG9ydCBjb25zdCBDb3VudGVyVmFsdWUgPSBzdHlsZWQuc3Bhbih7XG4gIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbn0pO1xuQ291bnRlclZhbHVlLmRpc3BsYXlOYW1lID0gJ0NvdW50ZXJWYWx1ZSc7XG5Db3VudGVyQnV0dG9uLmRpc3BsYXlOYW1lID0gJ0NvdW50ZXJCdXR0b24nO1xuQ291bnRlckJveC5kaXNwbGF5TmFtZSA9ICdDb3VudGVyQm94JztcbkNvdW50ZXJCb3guZGVmYXVsdFByb3BzID0ge1xuICB2YXJpYW50OiAnaG9yaXpvbnRhbCcsXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/counter/counter.style.tsx\n");

/***/ }),

/***/ "./src/components/counter/counter.tsx":
/*!********************************************!*\
  !*** ./src/components/counter/counter.tsx ***!
  \********************************************/
/*! exports provided: Counter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Counter\", function() { return Counter; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var assets_icons_PlusMinus__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! assets/icons/PlusMinus */ \"./src/assets/icons/PlusMinus.tsx\");\n/* harmony import */ var _counter_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./counter.style */ \"./src/components/counter/counter.style.tsx\");\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/components/counter/counter.tsx\",\n    _this = undefined;\n\n\n\n\nvar Counter = function Counter(_ref) {\n  var onDecrement = _ref.onDecrement,\n      onIncrement = _ref.onIncrement,\n      value = _ref.value,\n      variant = _ref.variant,\n      className = _ref.className;\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_counter_style__WEBPACK_IMPORTED_MODULE_3__[\"CounterBox\"], {\n    variant: variant,\n    className: className,\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_counter_style__WEBPACK_IMPORTED_MODULE_3__[\"CounterButton\"], {\n      onClick: onDecrement,\n      variant: variant,\n      className: \"control-button\",\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_PlusMinus__WEBPACK_IMPORTED_MODULE_2__[\"Minus\"], {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 26,\n        columnNumber: 9\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_counter_style__WEBPACK_IMPORTED_MODULE_3__[\"CounterValue\"], {\n      children: value\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 28,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_counter_style__WEBPACK_IMPORTED_MODULE_3__[\"CounterButton\"], {\n      onClick: onIncrement,\n      variant: variant,\n      className: \"control-button\",\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_PlusMinus__WEBPACK_IMPORTED_MODULE_2__[\"Plus\"], {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 34,\n        columnNumber: 9\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 29,\n      columnNumber: 7\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 20,\n    columnNumber: 5\n  }, _this);\n};\n_c = Counter;\n\nvar _c;\n\n$RefreshReg$(_c, \"Counter\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvY291bnRlci9jb3VudGVyLnRzeD9kMTMxIl0sIm5hbWVzIjpbIkNvdW50ZXIiLCJvbkRlY3JlbWVudCIsIm9uSW5jcmVtZW50IiwidmFsdWUiLCJ2YXJpYW50IiwiY2xhc3NOYW1lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBU08sSUFBTUEsT0FBd0IsR0FBRyxTQUEzQkEsT0FBMkIsT0FNbEM7QUFBQSxNQUxKQyxXQUtJLFFBTEpBLFdBS0k7QUFBQSxNQUpKQyxXQUlJLFFBSkpBLFdBSUk7QUFBQSxNQUhKQyxLQUdJLFFBSEpBLEtBR0k7QUFBQSxNQUZKQyxPQUVJLFFBRkpBLE9BRUk7QUFBQSxNQURKQyxTQUNJLFFBREpBLFNBQ0k7QUFDSixzQkFDRSxxRUFBQyx5REFBRDtBQUFZLFdBQU8sRUFBRUQsT0FBckI7QUFBOEIsYUFBUyxFQUFFQyxTQUF6QztBQUFBLDRCQUNFLHFFQUFDLDREQUFEO0FBQ0UsYUFBTyxFQUFFSixXQURYO0FBRUUsYUFBTyxFQUFFRyxPQUZYO0FBR0UsZUFBUyxFQUFDLGdCQUhaO0FBQUEsNkJBS0UscUVBQUMsNERBQUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUxGO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFERixlQVFFLHFFQUFDLDJEQUFEO0FBQUEsZ0JBQWVEO0FBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQVJGLGVBU0UscUVBQUMsNERBQUQ7QUFDRSxhQUFPLEVBQUVELFdBRFg7QUFFRSxhQUFPLEVBQUVFLE9BRlg7QUFHRSxlQUFTLEVBQUMsZ0JBSFo7QUFBQSw2QkFLRSxxRUFBQywyREFBRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTEY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQVRGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBbUJELENBMUJNO0tBQU1KLE8iLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9jb3VudGVyL2NvdW50ZXIudHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFBsdXMsIE1pbnVzIH0gZnJvbSAnYXNzZXRzL2ljb25zL1BsdXNNaW51cyc7XG5pbXBvcnQgeyBDb3VudGVyQm94LCBDb3VudGVyQnV0dG9uLCBDb3VudGVyVmFsdWUgfSBmcm9tICcuL2NvdW50ZXIuc3R5bGUnO1xuaW50ZXJmYWNlIFByb3BzIHtcbiAgb25EZWNyZW1lbnQ6IChlOiBFdmVudCkgPT4gdm9pZDtcbiAgb25JbmNyZW1lbnQ6IChlOiBFdmVudCkgPT4gdm9pZDtcbiAgdmFsdWU6IG51bWJlcjtcbiAgdmFyaWFudD86IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgQ291bnRlcjogUmVhY3QuRkM8UHJvcHM+ID0gKHtcbiAgb25EZWNyZW1lbnQsXG4gIG9uSW5jcmVtZW50LFxuICB2YWx1ZSxcbiAgdmFyaWFudCxcbiAgY2xhc3NOYW1lLFxufSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxDb3VudGVyQm94IHZhcmlhbnQ9e3ZhcmlhbnR9IGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgIDxDb3VudGVyQnV0dG9uXG4gICAgICAgIG9uQ2xpY2s9e29uRGVjcmVtZW50fVxuICAgICAgICB2YXJpYW50PXt2YXJpYW50fVxuICAgICAgICBjbGFzc05hbWU9J2NvbnRyb2wtYnV0dG9uJ1xuICAgICAgPlxuICAgICAgICA8TWludXMgLz5cbiAgICAgIDwvQ291bnRlckJ1dHRvbj5cbiAgICAgIDxDb3VudGVyVmFsdWU+e3ZhbHVlfTwvQ291bnRlclZhbHVlPlxuICAgICAgPENvdW50ZXJCdXR0b25cbiAgICAgICAgb25DbGljaz17b25JbmNyZW1lbnR9XG4gICAgICAgIHZhcmlhbnQ9e3ZhcmlhbnR9XG4gICAgICAgIGNsYXNzTmFtZT0nY29udHJvbC1idXR0b24nXG4gICAgICA+XG4gICAgICAgIDxQbHVzIC8+XG4gICAgICA8L0NvdW50ZXJCdXR0b24+XG4gICAgPC9Db3VudGVyQm94PlxuICApO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/counter/counter.tsx\n");

/***/ }),

/***/ "./src/components/forms/input.tsx":
/*!****************************************!*\
  !*** ./src/components/forms/input.tsx ***!
  \****************************************/
/*! exports provided: Input */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Input\", function() { return Input; });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @styled-system/css */ \"../../node_modules/@styled-system/css/dist/index.esm.js\");\n/* harmony import */ var styled_system__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-system */ \"../../node_modules/styled-system/dist/index.esm.js\");\n\n\n\nvar Input = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].input.withConfig({\n  displayName: \"input__Input\",\n  componentId: \"sc-9r8pxt-0\"\n})(Object(_styled_system_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n  display: 'block',\n  width: '100%',\n  p: '0 18px',\n  appearance: 'none',\n  fontFamily: 'body',\n  fontSize: 'base',\n  lineHeight: 'inherit',\n  border: '1px solid',\n  borderColor: 'gray.500',\n  borderRadius: 'base',\n  backgroundColor: 'white',\n  color: 'text.bold',\n  height: '48px',\n  transition: 'all 0.25s ease',\n  // mb: 3,\n  '&:focus': {\n    borderColor: 'primary.regular'\n  }\n}), {\n  '&:hover,&:focus': {\n    outline: 0\n  },\n  '&::placeholder': {\n    color: ''\n  },\n  '&::-webkit-inner-spin-button,&::-webkit-outer-spin-button': {\n    '-webkit-appearance': 'none',\n    margin: 0\n  },\n  '&.disabled': {\n    cursor: 'not-allowed',\n    opacity: 0.6\n  }\n}, Object(styled_system__WEBPACK_IMPORTED_MODULE_2__[\"compose\"])(styled_system__WEBPACK_IMPORTED_MODULE_2__[\"layout\"], styled_system__WEBPACK_IMPORTED_MODULE_2__[\"space\"], styled_system__WEBPACK_IMPORTED_MODULE_2__[\"color\"], styled_system__WEBPACK_IMPORTED_MODULE_2__[\"border\"]));\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvZm9ybXMvaW5wdXQudHN4PzU2NzUiXSwibmFtZXMiOlsiSW5wdXQiLCJzdHlsZWQiLCJpbnB1dCIsImNzcyIsImRpc3BsYXkiLCJ3aWR0aCIsInAiLCJhcHBlYXJhbmNlIiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwibGluZUhlaWdodCIsImJvcmRlciIsImJvcmRlckNvbG9yIiwiYm9yZGVyUmFkaXVzIiwiYmFja2dyb3VuZENvbG9yIiwiY29sb3IiLCJoZWlnaHQiLCJ0cmFuc2l0aW9uIiwib3V0bGluZSIsIm1hcmdpbiIsImN1cnNvciIsIm9wYWNpdHkiLCJjb21wb3NlIiwibGF5b3V0Iiwic3BhY2UiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDTyxJQUFNQSxLQUFLLEdBQUdDLHlEQUFNLENBQUNDLEtBQVY7QUFBQTtBQUFBO0FBQUEsR0FDaEJDLGtFQUFHLENBQUM7QUFDRkMsU0FBTyxFQUFFLE9BRFA7QUFFRkMsT0FBSyxFQUFFLE1BRkw7QUFHRkMsR0FBQyxFQUFFLFFBSEQ7QUFJRkMsWUFBVSxFQUFFLE1BSlY7QUFLRkMsWUFBVSxFQUFFLE1BTFY7QUFNRkMsVUFBUSxFQUFFLE1BTlI7QUFPRkMsWUFBVSxFQUFFLFNBUFY7QUFRRkMsUUFBTSxFQUFFLFdBUk47QUFTRkMsYUFBVyxFQUFFLFVBVFg7QUFVRkMsY0FBWSxFQUFFLE1BVlo7QUFXRkMsaUJBQWUsRUFBRSxPQVhmO0FBWUZDLE9BQUssRUFBRSxXQVpMO0FBYUZDLFFBQU0sRUFBRSxNQWJOO0FBY0ZDLFlBQVUsRUFBRSxnQkFkVjtBQWVGO0FBQ0EsYUFBVztBQUNUTCxlQUFXLEVBQUU7QUFESjtBQWhCVCxDQUFELENBRGEsRUFxQmhCO0FBQ0UscUJBQW1CO0FBQ2pCTSxXQUFPLEVBQUU7QUFEUSxHQURyQjtBQUtFLG9CQUFrQjtBQUNoQkgsU0FBSyxFQUFFO0FBRFMsR0FMcEI7QUFRRSwrREFBNkQ7QUFDM0QsMEJBQXNCLE1BRHFDO0FBRTNESSxVQUFNLEVBQUU7QUFGbUQsR0FSL0Q7QUFZRSxnQkFBYztBQUNaQyxVQUFNLEVBQUUsYUFESTtBQUVaQyxXQUFPLEVBQUU7QUFGRztBQVpoQixDQXJCZ0IsRUFzQ2hCQyw2REFBTyxDQUFDQyxvREFBRCxFQUFTQyxtREFBVCxFQUFnQlQsbURBQWhCLEVBQXVCSixvREFBdkIsQ0F0Q1MsQ0FBWCIsImZpbGUiOiIuL3NyYy9jb21wb25lbnRzL2Zvcm1zL2lucHV0LnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IGNzcyBmcm9tICdAc3R5bGVkLXN5c3RlbS9jc3MnO1xuaW1wb3J0IHsgY29tcG9zZSwgbGF5b3V0LCBzcGFjZSwgY29sb3IsIGJvcmRlciB9IGZyb20gJ3N0eWxlZC1zeXN0ZW0nO1xuZXhwb3J0IGNvbnN0IElucHV0ID0gc3R5bGVkLmlucHV0PGFueT4oXG4gIGNzcyh7XG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIHA6ICcwIDE4cHgnLFxuICAgIGFwcGVhcmFuY2U6ICdub25lJyxcbiAgICBmb250RmFtaWx5OiAnYm9keScsXG4gICAgZm9udFNpemU6ICdiYXNlJyxcbiAgICBsaW5lSGVpZ2h0OiAnaW5oZXJpdCcsXG4gICAgYm9yZGVyOiAnMXB4IHNvbGlkJyxcbiAgICBib3JkZXJDb2xvcjogJ2dyYXkuNTAwJyxcbiAgICBib3JkZXJSYWRpdXM6ICdiYXNlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgY29sb3I6ICd0ZXh0LmJvbGQnLFxuICAgIGhlaWdodDogJzQ4cHgnLFxuICAgIHRyYW5zaXRpb246ICdhbGwgMC4yNXMgZWFzZScsXG4gICAgLy8gbWI6IDMsXG4gICAgJyY6Zm9jdXMnOiB7XG4gICAgICBib3JkZXJDb2xvcjogJ3ByaW1hcnkucmVndWxhcicsXG4gICAgfSxcbiAgfSksXG4gIHtcbiAgICAnJjpob3ZlciwmOmZvY3VzJzoge1xuICAgICAgb3V0bGluZTogMCxcbiAgICB9LFxuXG4gICAgJyY6OnBsYWNlaG9sZGVyJzoge1xuICAgICAgY29sb3I6ICcnLFxuICAgIH0sXG4gICAgJyY6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sJjo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbic6IHtcbiAgICAgICctd2Via2l0LWFwcGVhcmFuY2UnOiAnbm9uZScsXG4gICAgICBtYXJnaW46IDAsXG4gICAgfSxcbiAgICAnJi5kaXNhYmxlZCc6IHtcbiAgICAgIGN1cnNvcjogJ25vdC1hbGxvd2VkJyxcbiAgICAgIG9wYWNpdHk6IDAuNixcbiAgICB9LFxuICB9LFxuICBjb21wb3NlKGxheW91dCwgc3BhY2UsIGNvbG9yLCBib3JkZXIpXG4pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/forms/input.tsx\n");

/***/ }),

/***/ "./src/components/scrollbar/scrollbar.tsx":
/*!************************************************!*\
  !*** ./src/components/scrollbar/scrollbar.tsx ***!
  \************************************************/
/*! exports provided: Scrollbar */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scrollbar\", function() { return Scrollbar; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var overlayscrollbars_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! overlayscrollbars-react */ \"../../node_modules/overlayscrollbars-react/dist/overlayscrollbars-react.esm.js\");\n\n\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/components/scrollbar/scrollbar.tsx\",\n    _this = undefined;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\nvar Scrollbar = function Scrollbar(_ref) {\n  var children = _ref.children,\n      className = _ref.className,\n      options = _ref.options,\n      style = _ref.style,\n      props = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(_ref, [\"children\", \"className\", \"options\", \"style\"]);\n\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(overlayscrollbars_react__WEBPACK_IMPORTED_MODULE_3__[\"OverlayScrollbarsComponent\"], _objectSpread(_objectSpread({\n    options: _objectSpread({\n      className: \"\".concat(className, \" os-theme-thin\"),\n      scrollbars: {\n        autoHide: 'leave'\n      }\n    }, options),\n    style: style\n  }, props), {}, {\n    children: children\n  }), void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 18,\n    columnNumber: 5\n  }, _this);\n};\n_c = Scrollbar;\n\nvar _c;\n\n$RefreshReg$(_c, \"Scrollbar\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvc2Nyb2xsYmFyL3Njcm9sbGJhci50c3g/N2IwYyJdLCJuYW1lcyI6WyJTY3JvbGxiYXIiLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsIm9wdGlvbnMiLCJzdHlsZSIsInByb3BzIiwic2Nyb2xsYmFycyIsImF1dG9IaWRlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQVNPLElBQU1BLFNBQW1DLEdBQUcsU0FBdENBLFNBQXNDLE9BTTdDO0FBQUEsTUFMSkMsUUFLSSxRQUxKQSxRQUtJO0FBQUEsTUFKSkMsU0FJSSxRQUpKQSxTQUlJO0FBQUEsTUFISkMsT0FHSSxRQUhKQSxPQUdJO0FBQUEsTUFGSkMsS0FFSSxRQUZKQSxLQUVJO0FBQUEsTUFEREMsS0FDQzs7QUFDSixzQkFDRSxxRUFBQyxrRkFBRDtBQUNFLFdBQU87QUFDTEgsZUFBUyxZQUFLQSxTQUFMLG1CQURKO0FBRUxJLGdCQUFVLEVBQUU7QUFDVkMsZ0JBQVEsRUFBRTtBQURBO0FBRlAsT0FLRkosT0FMRSxDQURUO0FBUUUsU0FBSyxFQUFFQztBQVJULEtBU01DLEtBVE47QUFBQSxjQVdHSjtBQVhIO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FERjtBQWVELENBdEJNO0tBQU1ELFMiLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9zY3JvbGxiYXIvc2Nyb2xsYmFyLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50IH0gZnJvbSAnb3ZlcmxheXNjcm9sbGJhcnMtcmVhY3QnO1xuXG50eXBlIFNjcm9sbGJhclByb3BzID0ge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIG9wdGlvbnM/OiBhbnk7XG4gIHN0eWxlPzogYW55O1xufTtcblxuZXhwb3J0IGNvbnN0IFNjcm9sbGJhcjogUmVhY3QuRkM8U2Nyb2xsYmFyUHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZSxcbiAgb3B0aW9ucyxcbiAgc3R5bGUsXG4gIC4uLnByb3BzXG59KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPE92ZXJsYXlTY3JvbGxiYXJzQ29tcG9uZW50XG4gICAgICBvcHRpb25zPXt7XG4gICAgICAgIGNsYXNzTmFtZTogYCR7Y2xhc3NOYW1lfSBvcy10aGVtZS10aGluYCxcbiAgICAgICAgc2Nyb2xsYmFyczoge1xuICAgICAgICAgIGF1dG9IaWRlOiAnbGVhdmUnLFxuICAgICAgICB9LFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgfX1cbiAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgIHsuLi5wcm9wc31cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9PdmVybGF5U2Nyb2xsYmFyc0NvbXBvbmVudD5cbiAgKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/scrollbar/scrollbar.tsx\n");

/***/ }),

/***/ "./src/contexts/cart/cart.reducer.tsx":
/*!********************************************!*\
  !*** ./src/contexts/cart/cart.reducer.tsx ***!
  \********************************************/
/*! exports provided: cartItemsTotalPrice, reducer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cartItemsTotalPrice\", function() { return cartItemsTotalPrice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"reducer\", function() { return reducer; });\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// export const cartItemsTotalPrice = (items, { discountInPercent = 0 } = {}) => {\nvar cartItemsTotalPrice = function cartItemsTotalPrice(items) {\n  var coupon = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (items === null || items.length === 0) return 0;\n  var itemCost = items.reduce(function (total, item) {\n    if (item.precio_venta) {\n      return total + item.precio_venta * item.quantity;\n    }\n\n    return total + item.price * item.quantity;\n  }, 0); // const discountRate = 1 - discountInPercent;\n\n  var discount = coupon ? itemCost * Number(coupon.discountInPercent) / 100 : 0; // itemCost * discountRate * TAX_RATE + shipping;\n  // return itemCost * discountRate;\n\n  return itemCost - discount;\n}; // cartItems, cartItemToAdd\n\nvar addItemToCart = function addItemToCart(state, action) {\n  var existingCartItemIndex = state.items.findIndex(function (item) {\n    return item.id === action.payload.id;\n  });\n\n  if (existingCartItemIndex > -1) {\n    var newState = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state.items);\n\n    newState[existingCartItemIndex].quantity += action.payload.quantity;\n    return newState;\n  }\n\n  return [].concat(Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state.items), [action.payload]);\n}; // cartItems, cartItemToRemove\n\n\nvar removeItemFromCart = function removeItemFromCart(state, action) {\n  return state.items.reduce(function (acc, item) {\n    if (item.id === action.payload.id) {\n      var newQuantity = item.quantity - action.payload.quantity;\n      return newQuantity > 0 ? [].concat(Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(acc), [_objectSpread(_objectSpread({}, item), {}, {\n        quantity: newQuantity\n      })]) : Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(acc);\n    }\n\n    return [].concat(Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(acc), [item]);\n  }, []);\n};\n\nvar clearItemFromCart = function clearItemFromCart(state, action) {\n  return state.items.filter(function (item) {\n    return item.id !== action.payload.id;\n  });\n};\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'REHYDRATE':\n      return _objectSpread(_objectSpread({}, state), action.payload);\n\n    case 'TOGGLE_CART':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isOpen: !state.isOpen\n      });\n\n    case 'ADD_ITEM':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        items: addItemToCart(state, action)\n      });\n\n    case 'REMOVE_ITEM':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        items: removeItemFromCart(state, action)\n      });\n\n    case 'CLEAR_ITEM_FROM_CART':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        items: clearItemFromCart(state, action)\n      });\n\n    case 'CLEAR_CART':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        items: []\n      });\n\n    case 'APPLY_COUPON':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        coupon: action.payload\n      });\n\n    case 'REMOVE_COUPON':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        coupon: null\n      });\n\n    case 'TOGGLE_RESTAURANT':\n      return _objectSpread(_objectSpread({}, state), {}, {\n        isRestaurant: !state.isRestaurant\n      });\n\n    default:\n      throw new Error(\"Unknown action: \".concat(action.type));\n  }\n};\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL2NhcnQvY2FydC5yZWR1Y2VyLnRzeD9mNWNhIl0sIm5hbWVzIjpbImNhcnRJdGVtc1RvdGFsUHJpY2UiLCJpdGVtcyIsImNvdXBvbiIsImxlbmd0aCIsIml0ZW1Db3N0IiwicmVkdWNlIiwidG90YWwiLCJpdGVtIiwicHJlY2lvX3ZlbnRhIiwicXVhbnRpdHkiLCJwcmljZSIsImRpc2NvdW50IiwiTnVtYmVyIiwiZGlzY291bnRJblBlcmNlbnQiLCJhZGRJdGVtVG9DYXJ0Iiwic3RhdGUiLCJhY3Rpb24iLCJleGlzdGluZ0NhcnRJdGVtSW5kZXgiLCJmaW5kSW5kZXgiLCJpZCIsInBheWxvYWQiLCJuZXdTdGF0ZSIsInJlbW92ZUl0ZW1Gcm9tQ2FydCIsImFjYyIsIm5ld1F1YW50aXR5IiwiY2xlYXJJdGVtRnJvbUNhcnQiLCJmaWx0ZXIiLCJyZWR1Y2VyIiwidHlwZSIsImlzT3BlbiIsImlzUmVzdGF1cmFudCIsIkVycm9yIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNPLElBQU1BLG1CQUFtQixHQUFHLFNBQXRCQSxtQkFBc0IsQ0FBQ0MsS0FBRCxFQUEwQjtBQUFBLE1BQWxCQyxNQUFrQix1RUFBVCxJQUFTO0FBQzNELE1BQUlELEtBQUssS0FBSyxJQUFWLElBQWtCQSxLQUFLLENBQUNFLE1BQU4sS0FBaUIsQ0FBdkMsRUFBMEMsT0FBTyxDQUFQO0FBQzFDLE1BQU1DLFFBQVEsR0FBR0gsS0FBSyxDQUFDSSxNQUFOLENBQWEsVUFBQ0MsS0FBRCxFQUFRQyxJQUFSLEVBQWlCO0FBQzdDLFFBQUlBLElBQUksQ0FBQ0MsWUFBVCxFQUF1QjtBQUNyQixhQUFPRixLQUFLLEdBQUdDLElBQUksQ0FBQ0MsWUFBTCxHQUFvQkQsSUFBSSxDQUFDRSxRQUF4QztBQUNEOztBQUNELFdBQU9ILEtBQUssR0FBR0MsSUFBSSxDQUFDRyxLQUFMLEdBQWFILElBQUksQ0FBQ0UsUUFBakM7QUFDRCxHQUxn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O0FBQTNDOztBQUNGLFNBQUssWUFBTDtBQUNFLDZDQUFZRCxLQUFaO0FBQW1CZCxhQUFLLEVBQUU7QUFBMUI7O0FBQ0YsU0FBSyxjQUFMO0FBQ0UsNkNBQVljLEtBQVo7QUFBbUJiLGNBQU0sRUFBRWMsTUFBTSxDQUFDSTtBQUFsQzs7QUFDRixTQUFLLGVBQUw7QUFDRSw2Q0FBWUwsS0FBWjtBQUFtQmIsY0FBTSxFQUFFO0FBQTNCOztBQUNGLFNBQUssbUJBQUw7QUFDRSw2Q0FBWWEsS0FBWjtBQUFtQmUsb0JBQVksRUFBRSxDQUFDZixLQUFLLENBQUNlO0FBQXhDOztBQUNGO0FBQ0UsWUFBTSxJQUFJQyxLQUFKLDJCQUE2QmYsTUFBTSxDQUFDWSxJQUFwQyxFQUFOO0FBcEJKO0FBc0JELENBdkJNIiwiZmlsZSI6Ii4vc3JjL2NvbnRleHRzL2NhcnQvY2FydC5yZWR1Y2VyLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4cG9ydCBjb25zdCBjYXJ0SXRlbXNUb3RhbFByaWNlID0gKGl0ZW1zLCB7IGRpc2NvdW50SW5QZXJjZW50ID0gMCB9ID0ge30pID0+IHtcbmV4cG9ydCBjb25zdCBjYXJ0SXRlbXNUb3RhbFByaWNlID0gKGl0ZW1zLCBjb3Vwb24gPSBudWxsKSA9PiB7XG4gIGlmIChpdGVtcyA9PT0gbnVsbCB8fCBpdGVtcy5sZW5ndGggPT09IDApIHJldHVybiAwO1xuICBjb25zdCBpdGVtQ29zdCA9IGl0ZW1zLnJlZHVjZSgodG90YWwsIGl0ZW0pID0+IHtcbiAgICBpZiAoaXRlbS5wcmVjaW9fdmVudGEpIHtcbiAgICAgIHJldHVybiB0b3RhbCArIGl0ZW0ucHJlY2lvX3ZlbnRhICogaXRlbS5xdWFudGl0eTtcbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsICsgaXRlbS5wcmljZSAqIGl0ZW0ucXVhbnRpdHk7XG4gIH0sIDApO1xuICAvLyBjb25zdCBkaXNjb3VudFJhdGUgPSAxIC0gZGlzY291bnRJblBlcmNlbnQ7XG4gIGNvbnN0IGRpc2NvdW50ID0gY291cG9uXG4gICAgPyAoaXRlbUNvc3QgKiBOdW1iZXIoY291cG9uLmRpc2NvdW50SW5QZXJjZW50KSkgLyAxMDBcbiAgICA6IDA7XG4gIC8vIGl0ZW1Db3N0ICogZGlzY291bnRSYXRlICogVEFYX1JBVEUgKyBzaGlwcGluZztcbiAgLy8gcmV0dXJuIGl0ZW1Db3N0ICogZGlzY291bnRSYXRlO1xuICByZXR1cm4gaXRlbUNvc3QgLSBkaXNjb3VudDtcbn07XG4vLyBjYXJ0SXRlbXMsIGNhcnRJdGVtVG9BZGRcbmNvbnN0IGFkZEl0ZW1Ub0NhcnQgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICBjb25zdCBleGlzdGluZ0NhcnRJdGVtSW5kZXggPSBzdGF0ZS5pdGVtcy5maW5kSW5kZXgoXG4gICAgKGl0ZW0pID0+IGl0ZW0uaWQgPT09IGFjdGlvbi5wYXlsb2FkLmlkXG4gICk7XG5cbiAgaWYgKGV4aXN0aW5nQ2FydEl0ZW1JbmRleCA+IC0xKSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPSBbLi4uc3RhdGUuaXRlbXNdO1xuICAgIG5ld1N0YXRlW2V4aXN0aW5nQ2FydEl0ZW1JbmRleF0ucXVhbnRpdHkgKz0gYWN0aW9uLnBheWxvYWQucXVhbnRpdHk7XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xuICB9XG4gIHJldHVybiBbLi4uc3RhdGUuaXRlbXMsIGFjdGlvbi5wYXlsb2FkXTtcbn07XG5cbi8vIGNhcnRJdGVtcywgY2FydEl0ZW1Ub1JlbW92ZVxuY29uc3QgcmVtb3ZlSXRlbUZyb21DYXJ0ID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgcmV0dXJuIHN0YXRlLml0ZW1zLnJlZHVjZSgoYWNjLCBpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0uaWQgPT09IGFjdGlvbi5wYXlsb2FkLmlkKSB7XG4gICAgICBjb25zdCBuZXdRdWFudGl0eSA9IGl0ZW0ucXVhbnRpdHkgLSBhY3Rpb24ucGF5bG9hZC5xdWFudGl0eTtcblxuICAgICAgcmV0dXJuIG5ld1F1YW50aXR5ID4gMFxuICAgICAgICA/IFsuLi5hY2MsIHsgLi4uaXRlbSwgcXVhbnRpdHk6IG5ld1F1YW50aXR5IH1dXG4gICAgICAgIDogWy4uLmFjY107XG4gICAgfVxuICAgIHJldHVybiBbLi4uYWNjLCBpdGVtXTtcbiAgfSwgW10pO1xufTtcblxuY29uc3QgY2xlYXJJdGVtRnJvbUNhcnQgPSAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICByZXR1cm4gc3RhdGUuaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLmlkICE9PSBhY3Rpb24ucGF5bG9hZC5pZCk7XG59O1xuXG5leHBvcnQgY29uc3QgcmVkdWNlciA9IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlICdSRUhZRFJBVEUnOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIC4uLmFjdGlvbi5wYXlsb2FkIH07XG4gICAgY2FzZSAnVE9HR0xFX0NBUlQnOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGlzT3BlbjogIXN0YXRlLmlzT3BlbiB9O1xuICAgIGNhc2UgJ0FERF9JVEVNJzpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBpdGVtczogYWRkSXRlbVRvQ2FydChzdGF0ZSwgYWN0aW9uKSB9O1xuICAgIGNhc2UgJ1JFTU9WRV9JVEVNJzpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBpdGVtczogcmVtb3ZlSXRlbUZyb21DYXJ0KHN0YXRlLCBhY3Rpb24pIH07XG4gICAgY2FzZSAnQ0xFQVJfSVRFTV9GUk9NX0NBUlQnOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGl0ZW1zOiBjbGVhckl0ZW1Gcm9tQ2FydChzdGF0ZSwgYWN0aW9uKSB9O1xuICAgIGNhc2UgJ0NMRUFSX0NBUlQnOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGl0ZW1zOiBbXSB9O1xuICAgIGNhc2UgJ0FQUExZX0NPVVBPTic6XG4gICAgICByZXR1cm4geyAuLi5zdGF0ZSwgY291cG9uOiBhY3Rpb24ucGF5bG9hZCB9O1xuICAgIGNhc2UgJ1JFTU9WRV9DT1VQT04nOlxuICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIGNvdXBvbjogbnVsbCB9O1xuICAgIGNhc2UgJ1RPR0dMRV9SRVNUQVVSQU5UJzpcbiAgICAgIHJldHVybiB7IC4uLnN0YXRlLCBpc1Jlc3RhdXJhbnQ6ICFzdGF0ZS5pc1Jlc3RhdXJhbnQgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGFjdGlvbjogJHthY3Rpb24udHlwZX1gKTtcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contexts/cart/cart.reducer.tsx\n");

/***/ }),

/***/ "./src/contexts/cart/use-cart.tsx":
/*!****************************************!*\
  !*** ./src/contexts/cart/use-cart.tsx ***!
  \****************************************/
/*! exports provided: CartProvider, useCart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartProvider\", function() { return CartProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useCart\", function() { return useCart; });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _cart_reducer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cart.reducer */ \"./src/contexts/cart/cart.reducer.tsx\");\n/* harmony import */ var utils_use_storage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! utils/use-storage */ \"./src/utils/use-storage.ts\");\n\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/contexts/cart/use-cart.tsx\",\n    _s = $RefreshSig$(),\n    _this = undefined,\n    _s2 = $RefreshSig$(),\n    _s3 = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\n\nvar CartContext = /*#__PURE__*/Object(react__WEBPACK_IMPORTED_MODULE_2__[\"createContext\"])({});\nvar INITIAL_STATE = {\n  isOpen: false,\n  items: [],\n  isRestaurant: false,\n  coupon: null\n};\n\nvar useCartActions = function useCartActions() {\n  _s();\n\n  var _state$items3;\n\n  var initialCart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;\n\n  var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useReducer\"])(_cart_reducer__WEBPACK_IMPORTED_MODULE_3__[\"reducer\"], initialCart),\n      state = _useReducer[0],\n      dispatch = _useReducer[1];\n\n  var addItemHandler = function addItemHandler(item) {\n    var quantity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    dispatch({\n      type: 'ADD_ITEM',\n      payload: _objectSpread(_objectSpread({}, item), {}, {\n        quantity: quantity\n      })\n    });\n  };\n\n  var removeItemHandler = function removeItemHandler(item) {\n    var quantity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    dispatch({\n      type: 'REMOVE_ITEM',\n      payload: _objectSpread(_objectSpread({}, item), {}, {\n        quantity: quantity\n      })\n    });\n  };\n\n  var clearItemFromCartHandler = function clearItemFromCartHandler(item) {\n    dispatch({\n      type: 'CLEAR_ITEM_FROM_CART',\n      payload: item\n    });\n  };\n\n  var clearCartHandler = function clearCartHandler() {\n    dispatch({\n      type: 'CLEAR_CART'\n    });\n  };\n\n  var toggleCartHandler = function toggleCartHandler() {\n    dispatch({\n      type: 'TOGGLE_CART'\n    });\n  };\n\n  var couponHandler = function couponHandler(coupon) {\n    dispatch({\n      type: 'APPLY_COUPON',\n      payload: coupon\n    });\n  };\n\n  var removeCouponHandler = function removeCouponHandler() {\n    dispatch({\n      type: 'REMOVE_COUPON'\n    });\n  };\n\n  var rehydrateLocalState = function rehydrateLocalState(payload) {\n    dispatch({\n      type: 'REHYDRATE',\n      payload: payload\n    });\n  };\n\n  var toggleRestaurant = function toggleRestaurant() {\n    dispatch({\n      type: 'TOGGLE_RESTAURANT'\n    });\n  };\n\n  var isInCartHandler = function isInCartHandler(id) {\n    var _state$items;\n\n    return (_state$items = state.items) === null || _state$items === void 0 ? void 0 : _state$items.some(function (item) {\n      return item.id === id;\n    });\n  };\n\n  var getItemHandler = function getItemHandler(id) {\n    var _state$items2;\n\n    return (_state$items2 = state.items) === null || _state$items2 === void 0 ? void 0 : _state$items2.find(function (item) {\n      return item.id === id;\n    });\n  };\n\n  var getCartItemsPrice = function getCartItemsPrice() {\n    return Object(_cart_reducer__WEBPACK_IMPORTED_MODULE_3__[\"cartItemsTotalPrice\"])(state.items).toFixed(0);\n  };\n\n  var getCartItemsTotalPrice = function getCartItemsTotalPrice() {\n    return Object(_cart_reducer__WEBPACK_IMPORTED_MODULE_3__[\"cartItemsTotalPrice\"])(state.items, state.coupon).toFixed(0);\n  };\n\n  var getDiscount = function getDiscount() {\n    var _state$coupon;\n\n    var total = Object(_cart_reducer__WEBPACK_IMPORTED_MODULE_3__[\"cartItemsTotalPrice\"])(state.items);\n    var discount = state.coupon //? (total * Number(state.coupon?.discountInPercent)) / 100\n    ? total * Number((_state$coupon = state.coupon) === null || _state$coupon === void 0 ? void 0 : _state$coupon.discountInPercent) / 100 : 0;\n    return discount.toFixed(0);\n  };\n\n  var getItemsCount = (_state$items3 = state.items) === null || _state$items3 === void 0 ? void 0 : _state$items3.reduce(function (acc, item) {\n    return acc + item.quantity;\n  }, 0);\n  return {\n    state: state,\n    getItemsCount: getItemsCount,\n    rehydrateLocalState: rehydrateLocalState,\n    addItemHandler: addItemHandler,\n    removeItemHandler: removeItemHandler,\n    clearItemFromCartHandler: clearItemFromCartHandler,\n    clearCartHandler: clearCartHandler,\n    isInCartHandler: isInCartHandler,\n    getItemHandler: getItemHandler,\n    toggleCartHandler: toggleCartHandler,\n    getCartItemsTotalPrice: getCartItemsTotalPrice,\n    getCartItemsPrice: getCartItemsPrice,\n    couponHandler: couponHandler,\n    removeCouponHandler: removeCouponHandler,\n    getDiscount: getDiscount,\n    toggleRestaurant: toggleRestaurant\n  };\n};\n\n_s(useCartActions, \"eanL7CPucd3H18vMQ/enxq1/NMY=\");\n\nvar CartProvider = function CartProvider(_ref) {\n  _s2();\n\n  var _state$items4;\n\n  var children = _ref.children;\n\n  var _useCartActions = useCartActions(),\n      state = _useCartActions.state,\n      rehydrateLocalState = _useCartActions.rehydrateLocalState,\n      getItemsCount = _useCartActions.getItemsCount,\n      addItemHandler = _useCartActions.addItemHandler,\n      removeItemHandler = _useCartActions.removeItemHandler,\n      clearItemFromCartHandler = _useCartActions.clearItemFromCartHandler,\n      clearCartHandler = _useCartActions.clearCartHandler,\n      isInCartHandler = _useCartActions.isInCartHandler,\n      getItemHandler = _useCartActions.getItemHandler,\n      toggleCartHandler = _useCartActions.toggleCartHandler,\n      getCartItemsTotalPrice = _useCartActions.getCartItemsTotalPrice,\n      couponHandler = _useCartActions.couponHandler,\n      removeCouponHandler = _useCartActions.removeCouponHandler,\n      getCartItemsPrice = _useCartActions.getCartItemsPrice,\n      getDiscount = _useCartActions.getDiscount,\n      toggleRestaurant = _useCartActions.toggleRestaurant;\n\n  var _useStorage = Object(utils_use_storage__WEBPACK_IMPORTED_MODULE_4__[\"useStorage\"])(state, rehydrateLocalState),\n      rehydrated = _useStorage.rehydrated,\n      error = _useStorage.error;\n\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(CartContext.Provider, {\n    value: {\n      isOpen: state.isOpen,\n      items: state.items,\n      coupon: state.coupon,\n      isRestaurant: state.isRestaurant,\n      cartItemsCount: (_state$items4 = state.items) === null || _state$items4 === void 0 ? void 0 : _state$items4.length,\n      itemsCount: getItemsCount,\n      addItem: addItemHandler,\n      removeItem: removeItemHandler,\n      removeItemFromCart: clearItemFromCartHandler,\n      clearCart: clearCartHandler,\n      isInCart: isInCartHandler,\n      getItem: getItemHandler,\n      toggleCart: toggleCartHandler,\n      calculatePrice: getCartItemsTotalPrice,\n      calculateSubTotalPrice: getCartItemsPrice,\n      applyCoupon: couponHandler,\n      removeCoupon: removeCouponHandler,\n      calculateDiscount: getDiscount,\n      toggleRestaurant: toggleRestaurant\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 110,\n    columnNumber: 5\n  }, _this);\n};\n\n_s2(CartProvider, \"TQeztbpmJBJjxP43uRdJFNmga9o=\", false, function () {\n  return [useCartActions, utils_use_storage__WEBPACK_IMPORTED_MODULE_4__[\"useStorage\"]];\n});\n\n_c = CartProvider;\nvar useCart = function useCart() {\n  _s3();\n\n  return Object(react__WEBPACK_IMPORTED_MODULE_2__[\"useContext\"])(CartContext);\n};\n\n_s3(useCart, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n\nvar _c;\n\n$RefreshReg$(_c, \"CartProvider\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL2NhcnQvdXNlLWNhcnQudHN4P2I0NTEiXSwibmFtZXMiOlsiQ2FydENvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwiSU5JVElBTF9TVEFURSIsImlzT3BlbiIsIml0ZW1zIiwiaXNSZXN0YXVyYW50IiwiY291cG9uIiwidXNlQ2FydEFjdGlvbnMiLCJpbml0aWFsQ2FydCIsInVzZVJlZHVjZXIiLCJyZWR1Y2VyIiwic3RhdGUiLCJkaXNwYXRjaCIsImFkZEl0ZW1IYW5kbGVyIiwiaXRlbSIsInF1YW50aXR5IiwidHlwZSIsInBheWxvYWQiLCJyZW1vdmVJdGVtSGFuZGxlciIsImNsZWFySXRlbUZyb21DYXJ0SGFuZGxlciIsImNsZWFyQ2FydEhhbmRsZXIiLCJ0b2dnbGVDYXJ0SGFuZGxlciIsImNvdXBvbkhhbmRsZXIiLCJyZW1vdmVDb3Vwb25IYW5kbGVyIiwicmVoeWRyYXRlTG9jYWxTdGF0ZSIsInRvZ2dsZVJlc3RhdXJhbnQiLCJpc0luQ2FydEhhbmRsZXIiLCJpZCIsInNvbWUiLCJnZXRJdGVtSGFuZGxlciIsImZpbmQiLCJnZXRDYXJ0SXRlbXNQcmljZSIsImNhcnRJdGVtc1RvdGFsUHJpY2UiLCJ0b0ZpeGVkIiwiZ2V0Q2FydEl0ZW1zVG90YWxQcmljZSIsImdldERpc2NvdW50IiwidG90YWwiLCJkaXNjb3VudCIsIk51bWJlciIsImRpc2NvdW50SW5QZXJjZW50IiwiZ2V0SXRlbXNDb3VudCIsInJlZHVjZSIsImFjYyIsIkNhcnRQcm92aWRlciIsImNoaWxkcmVuIiwidXNlU3RvcmFnZSIsInJlaHlkcmF0ZWQiLCJlcnJvciIsImNhcnRJdGVtc0NvdW50IiwibGVuZ3RoIiwiaXRlbXNDb3VudCIsImFkZEl0ZW0iLCJyZW1vdmVJdGVtIiwicmVtb3ZlSXRlbUZyb21DYXJ0IiwiY2xlYXJDYXJ0IiwiaXNJbkNhcnQiLCJnZXRJdGVtIiwidG9nZ2xlQ2FydCIsImNhbGN1bGF0ZVByaWNlIiwiY2FsY3VsYXRlU3ViVG90YWxQcmljZSIsImFwcGx5Q291cG9uIiwicmVtb3ZlQ291cG9uIiwiY2FsY3VsYXRlRGlzY291bnQiLCJ1c2VDYXJ0IiwidXNlQ29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxJQUFNQSxXQUFXLGdCQUFHQywyREFBYSxDQUFDLEVBQUQsQ0FBakM7QUFDQSxJQUFNQyxhQUFhLEdBQUc7QUFDcEJDLFFBQU0sRUFBRSxLQURZO0FBRXBCQyxPQUFLLEVBQUUsRUFGYTtBQUdwQkMsY0FBWSxFQUFFLEtBSE07QUFJcEJDLFFBQU0sRUFBRTtBQUpZLENBQXRCOztBQU9BLElBQU1DLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsR0FBaUM7QUFBQTs7QUFBQTs7QUFBQSxNQUFoQ0MsV0FBZ0MsdUVBQWxCTixhQUFrQjs7QUFBQSxvQkFDNUJPLHdEQUFVLENBQUNDLHFEQUFELEVBQVVGLFdBQVYsQ0FEa0I7QUFBQSxNQUMvQ0csS0FEK0M7QUFBQSxNQUN4Q0MsUUFEd0M7O0FBR3RELE1BQU1DLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQ0MsSUFBRCxFQUF3QjtBQUFBLFFBQWpCQyxRQUFpQix1RUFBTixDQUFNO0FBQzdDSCxZQUFRLENBQUM7QUFBRUksVUFBSSxFQUFFLFVBQVI7QUFBb0JDLGFBQU8sa0NBQU9ILElBQVA7QUFBYUMsZ0JBQVEsRUFBUkE7QUFBYjtBQUEzQixLQUFELENBQVI7QUFDRCxHQUZEOztBQUlBLE1BQU1HLGlCQUFpQixHQUFHLFNBQXBCQSxpQkFBb0IsQ0FBQ0osSUFBRCxFQUF3QjtBQUFBLFFBQWpCQyxRQUFpQix1RUFBTixDQUFNO0FBQ2hESCxZQUFRLENBQUM7QUFBRUksVUFBSSxFQUFFLGFBQVI7QUFBdUJDLGFBQU8sa0NBQU9ILElBQVA7QUFBYUMsZ0JBQVEsRUFBUkE7QUFBYjtBQUE5QixLQUFELENBQVI7QUFDRCxHQUZEOztBQUlBLE1BQU1JLHdCQUF3QixHQUFHLFNBQTNCQSx3QkFBMkIsQ0FBQ0wsSUFBRCxFQUFVO0FBQ3pDRixZQUFRLENBQUM7QUFBRUksVUFBSSxFQUFFLHNCQUFSO0FBQWdDQyxhQUFPLEVBQUVIO0FBQXpDLEtBQUQsQ0FBUjtBQUNELEdBRkQ7O0FBSUEsTUFBTU0sZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixHQUFNO0FBQzdCUixZQUFRLENBQUM7QUFBRUksVUFBSSxFQUFFO0FBQVIsS0FBRCxDQUFSO0FBQ0QsR0FGRDs7QUFHQSxNQUFNSyxpQkFBaUIsR0FBRyxTQUFwQkEsaUJBQW9CLEdBQU07QUFDOUJULFlBQVEsQ0FBQztBQUFFSSxVQUFJLEVBQUU7QUFBUixLQUFELENBQVI7QUFDRCxHQUZEOztBQUdBLE1BQU1NLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsQ0FBQ2hCLE1BQUQsRUFBWTtBQUNoQ00sWUFBUSxDQUFDO0FBQUVJLFVBQUksRUFBRSxjQUFSO0FBQXdCQyxhQUFPLEVBQUVYO0FBQWpDLEtBQUQsQ0FBUjtBQUNELEdBRkQ7O0FBR0EsTUFBTWlCLG1CQUFtQixHQUFHLFNBQXRCQSxtQkFBc0IsR0FBTTtBQUNoQ1gsWUFBUSxDQUFDO0FBQUVJLFVBQUksRUFBRTtBQUFSLEtBQUQsQ0FBUjtBQUNELEdBRkQ7O0FBR0EsTUFBTVEsbUJBQW1CLEdBQUcsU0FBdEJBLG1CQUFzQixDQUFDUCxPQUFELEVBQWE7QUFDdkNMLFlBQVEsQ0FBQztBQUFFSSxVQUFJLEVBQUUsV0FBUjtBQUFxQkMsYUFBTyxFQUFQQTtBQUFyQixLQUFELENBQVI7QUFDRCxHQUZEOztBQUdBLE1BQU1RLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsR0FBTTtBQUM3QmIsWUFBUSxDQUFDO0FBQUVJLFVBQUksRUFBRTtBQUFSLEtBQUQsQ0FBUjtBQUNELEdBRkQ7O0FBR0EsTUFBTVUsZUFBZSxHQUFHLFNBQWxCQSxlQUFrQixDQUFDQyxFQUFELEVBQVE7QUFBQTs7QUFDOUIsMkJBQU9oQixLQUFLLENBQUNQLEtBQWIsaURBQU8sYUFBYXdCLElBQWIsQ0FBa0IsVUFBQ2QsSUFBRDtBQUFBLGFBQVVBLElBQUksQ0FBQ2EsRUFBTCxLQUFZQSxFQUF0QjtBQUFBLEtBQWxCLENBQVA7QUFDRCxHQUZEOztBQUdBLE1BQU1FLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsQ0FBQ0YsRUFBRCxFQUFRO0FBQUE7O0FBQzdCLDRCQUFPaEIsS0FBSyxDQUFDUCxLQUFiLGtEQUFPLGNBQWEwQixJQUFiLENBQWtCLFVBQUNoQixJQUFEO0FBQUEsYUFBVUEsSUFBSSxDQUFDYSxFQUFMLEtBQVlBLEVBQXRCO0FBQUEsS0FBbEIsQ0FBUDtBQUNELEdBRkQ7O0FBR0EsTUFBTUksaUJBQWlCLEdBQUcsU0FBcEJBLGlCQUFvQjtBQUFBLFdBQU1DLHlFQUFtQixDQUFDckIsS0FBSyxDQUFDUCxLQUFQLENBQW5CLENBQWlDNkIsT0FBakMsQ0FBeUMsQ0FBekMsQ0FBTjtBQUFBLEdBQTFCOztBQUNBLE1BQU1DLHNCQUFzQixHQUFHLFNBQXpCQSxzQkFBeUI7QUFBQSxXQUM3QkYseUVBQW1CLENBQUNyQixLQUFLLENBQUNQLEtBQVAsRUFBY08sS0FBSyxDQUFDTCxNQUFwQixDQUFuQixDQUErQzJCLE9BQS9DLENBQXVELENBQXZELENBRDZCO0FBQUEsR0FBL0I7O0FBR0EsTUFBTUUsV0FBVyxHQUFHLFNBQWRBLFdBQWMsR0FBTTtBQUFBOztBQUN4QixRQUFNQyxLQUFLLEdBQUdKLHlFQUFtQixDQUFDckIsS0FBSyxDQUFDUCxLQUFQLENBQWpDO0FBQ0EsUUFBTWlDLFFBQVEsR0FBRzFCLEtBQUssQ0FBQ0wsTUFBTixDQUNmO0FBRGUsTUFFWjhCLEtBQUssR0FBR0UsTUFBTSxrQkFBQzNCLEtBQUssQ0FBQ0wsTUFBUCxrREFBQyxjQUFjaUMsaUJBQWYsQ0FBZixHQUFvRCxHQUZ2QyxHQUdiLENBSEo7QUFJQSxXQUFPRixRQUFRLENBQUNKLE9BQVQsQ0FBaUIsQ0FBakIsQ0FBUDtBQUNELEdBUEQ7O0FBUUEsTUFBTU8sYUFBYSxvQkFBRzdCLEtBQUssQ0FBQ1AsS0FBVCxrREFBRyxjQUFhcUMsTUFBYixDQUNwQixVQUFDQyxHQUFELEVBQU01QixJQUFOO0FBQUEsV0FBZTRCLEdBQUcsR0FBRzVCLElBQUksQ0FBQ0MsUUFBMUI7QUFBQSxHQURvQixFQUVwQixDQUZvQixDQUF0QjtBQUlBLFNBQU87QUFDTEosU0FBSyxFQUFMQSxLQURLO0FBRUw2QixpQkFBYSxFQUFiQSxhQUZLO0FBR0xoQix1QkFBbUIsRUFBbkJBLG1CQUhLO0FBSUxYLGtCQUFjLEVBQWRBLGNBSks7QUFLTEsscUJBQWlCLEVBQWpCQSxpQkFMSztBQU1MQyw0QkFBd0IsRUFBeEJBLHdCQU5LO0FBT0xDLG9CQUFnQixFQUFoQkEsZ0JBUEs7QUFRTE0sbUJBQWUsRUFBZkEsZUFSSztBQVNMRyxrQkFBYyxFQUFkQSxjQVRLO0FBVUxSLHFCQUFpQixFQUFqQkEsaUJBVks7QUFXTGEsMEJBQXNCLEVBQXRCQSxzQkFYSztBQVlMSCxxQkFBaUIsRUFBakJBLGlCQVpLO0FBYUxULGlCQUFhLEVBQWJBLGFBYks7QUFjTEMsdUJBQW1CLEVBQW5CQSxtQkFkSztBQWVMWSxlQUFXLEVBQVhBLFdBZks7QUFnQkxWLG9CQUFnQixFQUFoQkE7QUFoQkssR0FBUDtBQWtCRCxDQXpFRDs7R0FBTWxCLGM7O0FBMkVDLElBQU1vQyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxPQUFrQjtBQUFBOztBQUFBOztBQUFBLE1BQWZDLFFBQWUsUUFBZkEsUUFBZTs7QUFBQSx3QkFrQnhDckMsY0FBYyxFQWxCMEI7QUFBQSxNQUUxQ0ksS0FGMEMsbUJBRTFDQSxLQUYwQztBQUFBLE1BRzFDYSxtQkFIMEMsbUJBRzFDQSxtQkFIMEM7QUFBQSxNQUkxQ2dCLGFBSjBDLG1CQUkxQ0EsYUFKMEM7QUFBQSxNQUsxQzNCLGNBTDBDLG1CQUsxQ0EsY0FMMEM7QUFBQSxNQU0xQ0ssaUJBTjBDLG1CQU0xQ0EsaUJBTjBDO0FBQUEsTUFPMUNDLHdCQVAwQyxtQkFPMUNBLHdCQVAwQztBQUFBLE1BUTFDQyxnQkFSMEMsbUJBUTFDQSxnQkFSMEM7QUFBQSxNQVMxQ00sZUFUMEMsbUJBUzFDQSxlQVQwQztBQUFBLE1BVTFDRyxjQVYwQyxtQkFVMUNBLGNBVjBDO0FBQUEsTUFXMUNSLGlCQVgwQyxtQkFXMUNBLGlCQVgwQztBQUFBLE1BWTFDYSxzQkFaMEMsbUJBWTFDQSxzQkFaMEM7QUFBQSxNQWExQ1osYUFiMEMsbUJBYTFDQSxhQWIwQztBQUFBLE1BYzFDQyxtQkFkMEMsbUJBYzFDQSxtQkFkMEM7QUFBQSxNQWUxQ1EsaUJBZjBDLG1CQWUxQ0EsaUJBZjBDO0FBQUEsTUFnQjFDSSxXQWhCMEMsbUJBZ0IxQ0EsV0FoQjBDO0FBQUEsTUFpQjFDVixnQkFqQjBDLG1CQWlCMUNBLGdCQWpCMEM7O0FBQUEsb0JBbUJkb0Isb0VBQVUsQ0FBQ2xDLEtBQUQsRUFBUWEsbUJBQVIsQ0FuQkk7QUFBQSxNQW1CcENzQixVQW5Cb0MsZUFtQnBDQSxVQW5Cb0M7QUFBQSxNQW1CeEJDLEtBbkJ3QixlQW1CeEJBLEtBbkJ3Qjs7QUFxQjVDLHNCQUVFLHFFQUFDLFdBQUQsQ0FBYSxRQUFiO0FBQ0UsU0FBSyxFQUFFO0FBQ0w1QyxZQUFNLEVBQUVRLEtBQUssQ0FBQ1IsTUFEVDtBQUVMQyxXQUFLLEVBQUVPLEtBQUssQ0FBQ1AsS0FGUjtBQUdMRSxZQUFNLEVBQUVLLEtBQUssQ0FBQ0wsTUFIVDtBQUlMRCxrQkFBWSxFQUFFTSxLQUFLLENBQUNOLFlBSmY7QUFLTDJDLG9CQUFjLG1CQUFFckMsS0FBSyxDQUFDUCxLQUFSLGtEQUFFLGNBQWE2QyxNQUx4QjtBQU1MQyxnQkFBVSxFQUFFVixhQU5QO0FBT0xXLGFBQU8sRUFBRXRDLGNBUEo7QUFRTHVDLGdCQUFVLEVBQUVsQyxpQkFSUDtBQVNMbUMsd0JBQWtCLEVBQUVsQyx3QkFUZjtBQVVMbUMsZUFBUyxFQUFFbEMsZ0JBVk47QUFXTG1DLGNBQVEsRUFBRTdCLGVBWEw7QUFZTDhCLGFBQU8sRUFBRTNCLGNBWko7QUFhTDRCLGdCQUFVLEVBQUVwQyxpQkFiUDtBQWNMcUMsb0JBQWMsRUFBRXhCLHNCQWRYO0FBZUx5Qiw0QkFBc0IsRUFBRTVCLGlCQWZuQjtBQWdCTDZCLGlCQUFXLEVBQUV0QyxhQWhCUjtBQWlCTHVDLGtCQUFZLEVBQUV0QyxtQkFqQlQ7QUFrQkx1Qyx1QkFBaUIsRUFBRTNCLFdBbEJkO0FBbUJMVixzQkFBZ0IsRUFBaEJBO0FBbkJLLEtBRFQ7QUFBQSxjQXVCR21CO0FBdkJIO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FGRjtBQTRCRCxDQWpETTs7SUFBTUQsWTtVQWtCUHBDLGMsRUFDMEJzQyw0RDs7O0tBbkJuQkYsWTtBQW1ETixJQUFNb0IsT0FBTyxHQUFHLFNBQVZBLE9BQVU7QUFBQTs7QUFBQSxTQUFNQyx3REFBVSxDQUFDaEUsV0FBRCxDQUFoQjtBQUFBLENBQWhCOztJQUFNK0QsTyIsImZpbGUiOiIuL3NyYy9jb250ZXh0cy9jYXJ0L3VzZS1jYXJ0LnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VSZWR1Y2VyLCB1c2VDb250ZXh0LCBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVkdWNlciwgY2FydEl0ZW1zVG90YWxQcmljZSB9IGZyb20gJy4vY2FydC5yZWR1Y2VyJztcbmltcG9ydCB7IHVzZVN0b3JhZ2UgfSBmcm9tICd1dGlscy91c2Utc3RvcmFnZSc7XG5jb25zdCBDYXJ0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30gYXMgYW55KTtcbmNvbnN0IElOSVRJQUxfU1RBVEUgPSB7XG4gIGlzT3BlbjogZmFsc2UsXG4gIGl0ZW1zOiBbXSxcbiAgaXNSZXN0YXVyYW50OiBmYWxzZSxcbiAgY291cG9uOiBudWxsLFxufTtcblxuY29uc3QgdXNlQ2FydEFjdGlvbnMgPSAoaW5pdGlhbENhcnQgPSBJTklUSUFMX1NUQVRFKSA9PiB7XG4gIGNvbnN0IFtzdGF0ZSwgZGlzcGF0Y2hdID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQ2FydCk7XG5cbiAgY29uc3QgYWRkSXRlbUhhbmRsZXIgPSAoaXRlbSwgcXVhbnRpdHkgPSAxKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnQUREX0lURU0nLCBwYXlsb2FkOiB7IC4uLml0ZW0sIHF1YW50aXR5IH0gfSk7XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlSXRlbUhhbmRsZXIgPSAoaXRlbSwgcXVhbnRpdHkgPSAxKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnUkVNT1ZFX0lURU0nLCBwYXlsb2FkOiB7IC4uLml0ZW0sIHF1YW50aXR5IH0gfSk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJJdGVtRnJvbUNhcnRIYW5kbGVyID0gKGl0ZW0pID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdDTEVBUl9JVEVNX0ZST01fQ0FSVCcsIHBheWxvYWQ6IGl0ZW0gfSk7XG4gIH07XG5cbiAgY29uc3QgY2xlYXJDYXJ0SGFuZGxlciA9ICgpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdDTEVBUl9DQVJUJyB9KTtcbiAgfTtcbiAgY29uc3QgdG9nZ2xlQ2FydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnVE9HR0xFX0NBUlQnIH0pO1xuICB9O1xuICBjb25zdCBjb3Vwb25IYW5kbGVyID0gKGNvdXBvbikgPT4ge1xuICAgIGRpc3BhdGNoKHsgdHlwZTogJ0FQUExZX0NPVVBPTicsIHBheWxvYWQ6IGNvdXBvbiB9KTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlQ291cG9uSGFuZGxlciA9ICgpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQ09VUE9OJyB9KTtcbiAgfTtcbiAgY29uc3QgcmVoeWRyYXRlTG9jYWxTdGF0ZSA9IChwYXlsb2FkKSA9PiB7XG4gICAgZGlzcGF0Y2goeyB0eXBlOiAnUkVIWURSQVRFJywgcGF5bG9hZCB9KTtcbiAgfTtcbiAgY29uc3QgdG9nZ2xlUmVzdGF1cmFudCA9ICgpID0+IHtcbiAgICBkaXNwYXRjaCh7IHR5cGU6ICdUT0dHTEVfUkVTVEFVUkFOVCcgfSk7XG4gIH07XG4gIGNvbnN0IGlzSW5DYXJ0SGFuZGxlciA9IChpZCkgPT4ge1xuICAgIHJldHVybiBzdGF0ZS5pdGVtcz8uc29tZSgoaXRlbSkgPT4gaXRlbS5pZCA9PT0gaWQpO1xuICB9O1xuICBjb25zdCBnZXRJdGVtSGFuZGxlciA9IChpZCkgPT4ge1xuICAgIHJldHVybiBzdGF0ZS5pdGVtcz8uZmluZCgoaXRlbSkgPT4gaXRlbS5pZCA9PT0gaWQpO1xuICB9O1xuICBjb25zdCBnZXRDYXJ0SXRlbXNQcmljZSA9ICgpID0+IGNhcnRJdGVtc1RvdGFsUHJpY2Uoc3RhdGUuaXRlbXMpLnRvRml4ZWQoMCk7XG4gIGNvbnN0IGdldENhcnRJdGVtc1RvdGFsUHJpY2UgPSAoKSA9PlxuICAgIGNhcnRJdGVtc1RvdGFsUHJpY2Uoc3RhdGUuaXRlbXMsIHN0YXRlLmNvdXBvbikudG9GaXhlZCgwKTtcblxuICBjb25zdCBnZXREaXNjb3VudCA9ICgpID0+IHtcbiAgICBjb25zdCB0b3RhbCA9IGNhcnRJdGVtc1RvdGFsUHJpY2Uoc3RhdGUuaXRlbXMpO1xuICAgIGNvbnN0IGRpc2NvdW50ID0gc3RhdGUuY291cG9uXG4gICAgICAvLz8gKHRvdGFsICogTnVtYmVyKHN0YXRlLmNvdXBvbj8uZGlzY291bnRJblBlcmNlbnQpKSAvIDEwMFxuICAgICAgPyAodG90YWwgKiBOdW1iZXIoc3RhdGUuY291cG9uPy5kaXNjb3VudEluUGVyY2VudCkpIC8gMTAwXG4gICAgICA6IDA7XG4gICAgcmV0dXJuIGRpc2NvdW50LnRvRml4ZWQoMCk7XG4gIH07XG4gIGNvbnN0IGdldEl0ZW1zQ291bnQgPSBzdGF0ZS5pdGVtcz8ucmVkdWNlKFxuICAgIChhY2MsIGl0ZW0pID0+IGFjYyArIGl0ZW0ucXVhbnRpdHksXG4gICAgMFxuICApO1xuICByZXR1cm4ge1xuICAgIHN0YXRlLFxuICAgIGdldEl0ZW1zQ291bnQsXG4gICAgcmVoeWRyYXRlTG9jYWxTdGF0ZSxcbiAgICBhZGRJdGVtSGFuZGxlcixcbiAgICByZW1vdmVJdGVtSGFuZGxlcixcbiAgICBjbGVhckl0ZW1Gcm9tQ2FydEhhbmRsZXIsXG4gICAgY2xlYXJDYXJ0SGFuZGxlcixcbiAgICBpc0luQ2FydEhhbmRsZXIsXG4gICAgZ2V0SXRlbUhhbmRsZXIsXG4gICAgdG9nZ2xlQ2FydEhhbmRsZXIsXG4gICAgZ2V0Q2FydEl0ZW1zVG90YWxQcmljZSxcbiAgICBnZXRDYXJ0SXRlbXNQcmljZSxcbiAgICBjb3Vwb25IYW5kbGVyLFxuICAgIHJlbW92ZUNvdXBvbkhhbmRsZXIsXG4gICAgZ2V0RGlzY291bnQsXG4gICAgdG9nZ2xlUmVzdGF1cmFudCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBDYXJ0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzdGF0ZSxcbiAgICByZWh5ZHJhdGVMb2NhbFN0YXRlLFxuICAgIGdldEl0ZW1zQ291bnQsXG4gICAgYWRkSXRlbUhhbmRsZXIsXG4gICAgcmVtb3ZlSXRlbUhhbmRsZXIsXG4gICAgY2xlYXJJdGVtRnJvbUNhcnRIYW5kbGVyLFxuICAgIGNsZWFyQ2FydEhhbmRsZXIsXG4gICAgaXNJbkNhcnRIYW5kbGVyLFxuICAgIGdldEl0ZW1IYW5kbGVyLFxuICAgIHRvZ2dsZUNhcnRIYW5kbGVyLFxuICAgIGdldENhcnRJdGVtc1RvdGFsUHJpY2UsXG4gICAgY291cG9uSGFuZGxlcixcbiAgICByZW1vdmVDb3Vwb25IYW5kbGVyLFxuICAgIGdldENhcnRJdGVtc1ByaWNlLFxuICAgIGdldERpc2NvdW50LFxuICAgIHRvZ2dsZVJlc3RhdXJhbnQsXG4gIH0gPSB1c2VDYXJ0QWN0aW9ucygpO1xuICBjb25zdCB7IHJlaHlkcmF0ZWQsIGVycm9yIH0gPSB1c2VTdG9yYWdlKHN0YXRlLCByZWh5ZHJhdGVMb2NhbFN0YXRlKTtcbiAgXG4gIHJldHVybiAoXG4gICBcbiAgICA8Q2FydENvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIGlzT3Blbjogc3RhdGUuaXNPcGVuLFxuICAgICAgICBpdGVtczogc3RhdGUuaXRlbXMsXG4gICAgICAgIGNvdXBvbjogc3RhdGUuY291cG9uLFxuICAgICAgICBpc1Jlc3RhdXJhbnQ6IHN0YXRlLmlzUmVzdGF1cmFudCxcbiAgICAgICAgY2FydEl0ZW1zQ291bnQ6IHN0YXRlLml0ZW1zPy5sZW5ndGgsXG4gICAgICAgIGl0ZW1zQ291bnQ6IGdldEl0ZW1zQ291bnQsXG4gICAgICAgIGFkZEl0ZW06IGFkZEl0ZW1IYW5kbGVyLFxuICAgICAgICByZW1vdmVJdGVtOiByZW1vdmVJdGVtSGFuZGxlcixcbiAgICAgICAgcmVtb3ZlSXRlbUZyb21DYXJ0OiBjbGVhckl0ZW1Gcm9tQ2FydEhhbmRsZXIsXG4gICAgICAgIGNsZWFyQ2FydDogY2xlYXJDYXJ0SGFuZGxlcixcbiAgICAgICAgaXNJbkNhcnQ6IGlzSW5DYXJ0SGFuZGxlcixcbiAgICAgICAgZ2V0SXRlbTogZ2V0SXRlbUhhbmRsZXIsXG4gICAgICAgIHRvZ2dsZUNhcnQ6IHRvZ2dsZUNhcnRIYW5kbGVyLFxuICAgICAgICBjYWxjdWxhdGVQcmljZTogZ2V0Q2FydEl0ZW1zVG90YWxQcmljZSxcbiAgICAgICAgY2FsY3VsYXRlU3ViVG90YWxQcmljZTogZ2V0Q2FydEl0ZW1zUHJpY2UsXG4gICAgICAgIGFwcGx5Q291cG9uOiBjb3Vwb25IYW5kbGVyLFxuICAgICAgICByZW1vdmVDb3Vwb246IHJlbW92ZUNvdXBvbkhhbmRsZXIsXG4gICAgICAgIGNhbGN1bGF0ZURpc2NvdW50OiBnZXREaXNjb3VudCxcbiAgICAgICAgdG9nZ2xlUmVzdGF1cmFudCxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQ2FydENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgdXNlQ2FydCA9ICgpID0+IHVzZUNvbnRleHQoQ2FydENvbnRleHQpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/contexts/cart/use-cart.tsx\n");

/***/ }),

/***/ "./src/features/carts/cart-popup.tsx":
/*!*******************************************!*\
  !*** ./src/features/carts/cart-popup.tsx ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_theme_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @styled-system/theme-get */ \"../../node_modules/@styled-system/theme-get/dist/index.esm.js\");\n/* harmony import */ var _redq_reuse_modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @redq/reuse-modal */ \"../../node_modules/@redq/reuse-modal/es/index.js\");\n/* harmony import */ var _cart__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cart */ \"./src/features/carts/cart.tsx\");\n/* harmony import */ var components_cart_popup_cart_popup_button__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! components/cart-popup/cart-popup-button */ \"./src/components/cart-popup/cart-popup-button.tsx\");\n/* harmony import */ var utils_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! utils/constant */ \"./src/utils/constant.ts\");\n/* harmony import */ var _cart_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cart.style */ \"./src/features/carts/cart.style.tsx\");\n/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-intl */ \"../../node_modules/react-intl/lib/index.js\");\n/* harmony import */ var contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! contexts/cart/use-cart */ \"./src/contexts/cart/use-cart.tsx\");\n\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/features/carts/cart-popup.tsx\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\nvar CartPopupStyle = Object(styled_components__WEBPACK_IMPORTED_MODULE_2__[\"createGlobalStyle\"])([\".cartPopup{top:auto !important;left:auto !important;bottom:50px !important;right:50px !important;box-shadow:\", \";transform-origin:bottom right;@media (max-width:580px){max-width:none!important;width:100% !important;bottom:0 !important;left:0!important;background:\", \";overflow:initial !important;transform-origin:bottom center;}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_3__[\"themeGet\"])('shadows.big', '0 21px 36px rgba(0, 0, 0, 0.16)'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_3__[\"themeGet\"])('colors.white', '#ffffff'));\n_c = CartPopupStyle;\n\nvar CartPopUp = function CartPopUp(_ref) {\n  _s();\n\n  var _ref$deviceType = _ref.deviceType,\n      mobile = _ref$deviceType.mobile,\n      tablet = _ref$deviceType.tablet,\n      desktop = _ref$deviceType.desktop;\n\n  var _useCart = Object(contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_10__[\"useCart\"])(),\n      isOpen = _useCart.isOpen,\n      cartItemsCount = _useCart.cartItemsCount,\n      toggleCart = _useCart.toggleCart,\n      calculatePrice = _useCart.calculatePrice;\n\n  var handleModal = function handleModal() {\n    Object(_redq_reuse_modal__WEBPACK_IMPORTED_MODULE_4__[\"openModal\"])({\n      show: true,\n      config: {\n        className: 'cartPopup',\n        width: 'auto',\n        height: 'auto',\n        enableResizing: false,\n        disableDragging: true,\n        transition: {\n          tension: 360,\n          friction: 40\n        }\n      },\n      closeOnClickOutside: true,\n      component: _cart__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n      closeComponent: function closeComponent() {\n        return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"div\", {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 63,\n          columnNumber: 29\n        }, _this);\n      },\n      componentProps: {\n        onCloseBtnClick: _redq_reuse_modal__WEBPACK_IMPORTED_MODULE_4__[\"closeModal\"],\n        scrollbarHeight: 330\n      }\n    });\n  };\n\n  var cartSliderClass = isOpen === true ? 'cartPopupFixed' : '';\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n    children: mobile ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(CartPopupStyle, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 74,\n        columnNumber: 11\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(components_cart_popup_cart_popup_button__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n        className: \"product-cart\",\n        itemCount: cartItemsCount,\n        itemPostfix: cartItemsCount > 1 ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_9__[\"FormattedMessage\"], {\n          id: \"cartItems\",\n          defaultMessage: \"items\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 80,\n          columnNumber: 17\n        }, _this) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_9__[\"FormattedMessage\"], {\n          id: \"cartItem\",\n          defaultMessage: \"item\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 82,\n          columnNumber: 17\n        }, _this),\n        price: calculatePrice(),\n        pricePrefix: \"$\",\n        onClick: handleModal\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 75,\n        columnNumber: 11\n      }, _this)]\n    }, void 0, true) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_8__[\"CartSlidePopup\"], {\n        className: cartSliderClass,\n        children: isOpen && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n          onCloseBtnClick: toggleCart,\n          scrollbarHeight: \"100vh\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 94,\n          columnNumber: 15\n        }, _this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 92,\n        columnNumber: 11\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(components_cart_popup_cart_popup_button__WEBPACK_IMPORTED_MODULE_6__[\"BoxedCartButton\"], {\n        className: \"product-cart\",\n        itemCount: cartItemsCount,\n        itemPostfix: cartItemsCount > 1 ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_9__[\"FormattedMessage\"], {\n          id: \"cartItems\",\n          defaultMessage: \"items\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 103,\n          columnNumber: 17\n        }, _this) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_9__[\"FormattedMessage\"], {\n          id: \"cartItem\",\n          defaultMessage: \"item\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 105,\n          columnNumber: 17\n        }, _this),\n        price: calculatePrice(),\n        pricePrefix: utils_constant__WEBPACK_IMPORTED_MODULE_7__[\"CURRENCY\"],\n        onClick: toggleCart\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 98,\n        columnNumber: 11\n      }, _this)]\n    }, void 0, true)\n  }, void 0, false);\n};\n\n_s(CartPopUp, \"9OfCyKMkiX8EZB7rii64tphcWd8=\", false, function () {\n  return [contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_10__[\"useCart\"]];\n});\n\n_c2 = CartPopUp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (CartPopUp);\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"CartPopupStyle\");\n$RefreshReg$(_c2, \"CartPopUp\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ZlYXR1cmVzL2NhcnRzL2NhcnQtcG9wdXAudHN4PzgxOTAiXSwibmFtZXMiOlsiQ2FydFBvcHVwU3R5bGUiLCJjcmVhdGVHbG9iYWxTdHlsZSIsInRoZW1lR2V0IiwiQ2FydFBvcFVwIiwiZGV2aWNlVHlwZSIsIm1vYmlsZSIsInRhYmxldCIsImRlc2t0b3AiLCJ1c2VDYXJ0IiwiaXNPcGVuIiwiY2FydEl0ZW1zQ291bnQiLCJ0b2dnbGVDYXJ0IiwiY2FsY3VsYXRlUHJpY2UiLCJoYW5kbGVNb2RhbCIsIm9wZW5Nb2RhbCIsInNob3ciLCJjb25maWciLCJjbGFzc05hbWUiLCJ3aWR0aCIsImhlaWdodCIsImVuYWJsZVJlc2l6aW5nIiwiZGlzYWJsZURyYWdnaW5nIiwidHJhbnNpdGlvbiIsInRlbnNpb24iLCJmcmljdGlvbiIsImNsb3NlT25DbGlja091dHNpZGUiLCJjb21wb25lbnQiLCJDYXJ0IiwiY2xvc2VDb21wb25lbnQiLCJjb21wb25lbnRQcm9wcyIsIm9uQ2xvc2VCdG5DbGljayIsImNsb3NlTW9kYWwiLCJzY3JvbGxiYXJIZWlnaHQiLCJjYXJ0U2xpZGVyQ2xhc3MiLCJDVVJSRU5DWSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQSxJQUFNQSxjQUFjLEdBQUdDLDJFQUFILGdWQU1GQyx5RUFBUSxDQUFDLGFBQUQsRUFBZ0IsaUNBQWhCLENBTk4sRUFjQUEseUVBQVEsQ0FBQyxjQUFELEVBQWlCLFNBQWpCLENBZFIsQ0FBcEI7S0FBTUYsYzs7QUE2Qk4sSUFBTUcsU0FBOEIsR0FBRyxTQUFqQ0EsU0FBaUMsT0FFakM7QUFBQTs7QUFBQSw2QkFESkMsVUFDSTtBQUFBLE1BRFVDLE1BQ1YsbUJBRFVBLE1BQ1Y7QUFBQSxNQURrQkMsTUFDbEIsbUJBRGtCQSxNQUNsQjtBQUFBLE1BRDBCQyxPQUMx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ZWF0dXJlcy9jYXJ0cy9jYXJ0LXBvcHVwLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVHbG9iYWxTdHlsZSB9IGZyb20gJ3N0eWxlZC1jb21wb25lbnRzJztcbmltcG9ydCB7IHRoZW1lR2V0IH0gZnJvbSAnQHN0eWxlZC1zeXN0ZW0vdGhlbWUtZ2V0JztcbmltcG9ydCB7IG9wZW5Nb2RhbCwgY2xvc2VNb2RhbCB9IGZyb20gJ0ByZWRxL3JldXNlLW1vZGFsJztcbmltcG9ydCBDYXJ0IGZyb20gJy4vY2FydCc7XG5pbXBvcnQgQ2FydFBvcHVwQnV0dG9uLCB7XG4gIEJveGVkQ2FydEJ1dHRvbixcbn0gZnJvbSAnY29tcG9uZW50cy9jYXJ0LXBvcHVwL2NhcnQtcG9wdXAtYnV0dG9uJztcbmltcG9ydCB7IENVUlJFTkNZIH0gZnJvbSAndXRpbHMvY29uc3RhbnQnO1xuaW1wb3J0IHsgQ2FydFNsaWRlUG9wdXAgfSBmcm9tICcuL2NhcnQuc3R5bGUnO1xuaW1wb3J0IHsgRm9ybWF0dGVkTWVzc2FnZSB9IGZyb20gJ3JlYWN0LWludGwnO1xuaW1wb3J0IHsgdXNlQ2FydCB9IGZyb20gJ2NvbnRleHRzL2NhcnQvdXNlLWNhcnQnO1xuXG5jb25zdCBDYXJ0UG9wdXBTdHlsZSA9IGNyZWF0ZUdsb2JhbFN0eWxlYFxuICAuY2FydFBvcHVwe1xuICAgIHRvcDogYXV0byAhaW1wb3J0YW50O1xuICAgIGxlZnQ6IGF1dG8gIWltcG9ydGFudDtcbiAgICBib3R0b206IDUwcHggIWltcG9ydGFudDtcbiAgICByaWdodDogNTBweCAhaW1wb3J0YW50O1xuICAgIGJveC1zaGFkb3c6ICR7dGhlbWVHZXQoJ3NoYWRvd3MuYmlnJywgJzAgMjFweCAzNnB4IHJnYmEoMCwgMCwgMCwgMC4xNiknKX07XG4gICAgdHJhbnNmb3JtLW9yaWdpbjogYm90dG9tIHJpZ2h0O1xuXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDU4MHB4KSB7XG4gICAgICBtYXgtd2lkdGg6IG5vbmUhaW1wb3J0YW50O1xuICAgICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICAgIGJvdHRvbTogMCAhaW1wb3J0YW50O1xuICAgICAgbGVmdDogMCFpbXBvcnRhbnQ7XG4gICAgICBiYWNrZ3JvdW5kOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbiAgICAgIG92ZXJmbG93OiBpbml0aWFsICFpbXBvcnRhbnQ7XG4gICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBib3R0b20gY2VudGVyO1xuICAgIH1cbiAgfVxuYDtcblxudHlwZSBDYXJ0UHJvcHMgPSB7XG4gIGRldmljZVR5cGU6IHtcbiAgICBtb2JpbGU6IGJvb2xlYW47XG4gICAgdGFibGV0OiBib29sZWFuO1xuICAgIGRlc2t0b3A6IGJvb2xlYW47XG4gIH07XG59O1xuXG5jb25zdCBDYXJ0UG9wVXA6IFJlYWN0LkZDPENhcnRQcm9wcz4gPSAoe1xuICBkZXZpY2VUeXBlOiB7IG1vYmlsZSwgdGFibGV0LCBkZXNrdG9wIH0sXG59KSA9PiB7XG4gIGNvbnN0IHsgaXNPcGVuLCBjYXJ0SXRlbXNDb3VudCwgdG9nZ2xlQ2FydCwgY2FsY3VsYXRlUHJpY2UgfSA9IHVzZUNhcnQoKTtcbiAgY29uc3QgaGFuZGxlTW9kYWwgPSAoKSA9PiB7XG4gICAgb3Blbk1vZGFsKHtcbiAgICAgIHNob3c6IHRydWUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgY2xhc3NOYW1lOiAnY2FydFBvcHVwJyxcbiAgICAgICAgd2lkdGg6ICdhdXRvJyxcbiAgICAgICAgaGVpZ2h0OiAnYXV0bycsXG4gICAgICAgIGVuYWJsZVJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgZGlzYWJsZURyYWdnaW5nOiB0cnVlLFxuICAgICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgICAgdGVuc2lvbjogMzYwLFxuICAgICAgICAgIGZyaWN0aW9uOiA0MCxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICBjbG9zZU9uQ2xpY2tPdXRzaWRlOiB0cnVlLFxuICAgICAgY29tcG9uZW50OiBDYXJ0LFxuICAgICAgY2xvc2VDb21wb25lbnQ6ICgpID0+IDxkaXYgLz4sXG4gICAgICBjb21wb25lbnRQcm9wczogeyBvbkNsb3NlQnRuQ2xpY2s6IGNsb3NlTW9kYWwsIHNjcm9sbGJhckhlaWdodDogMzMwIH0sXG4gICAgfSk7XG4gIH07XG5cbiAgbGV0IGNhcnRTbGlkZXJDbGFzcyA9IGlzT3BlbiA9PT0gdHJ1ZSA/ICdjYXJ0UG9wdXBGaXhlZCcgOiAnJztcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7bW9iaWxlID8gKFxuICAgICAgICA8PlxuICAgICAgICAgIDxDYXJ0UG9wdXBTdHlsZSAvPlxuICAgICAgICAgIDxDYXJ0UG9wdXBCdXR0b25cbiAgICAgICAgICAgIGNsYXNzTmFtZT0ncHJvZHVjdC1jYXJ0J1xuICAgICAgICAgICAgaXRlbUNvdW50PXtjYXJ0SXRlbXNDb3VudH1cbiAgICAgICAgICAgIGl0ZW1Qb3N0Zml4PXtcbiAgICAgICAgICAgICAgY2FydEl0ZW1zQ291bnQgPiAxID8gKFxuICAgICAgICAgICAgICAgIDxGb3JtYXR0ZWRNZXNzYWdlIGlkPSdjYXJ0SXRlbXMnIGRlZmF1bHRNZXNzYWdlPSdpdGVtcycgLz5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8Rm9ybWF0dGVkTWVzc2FnZSBpZD0nY2FydEl0ZW0nIGRlZmF1bHRNZXNzYWdlPSdpdGVtJyAvPlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmljZT17Y2FsY3VsYXRlUHJpY2UoKX1cbiAgICAgICAgICAgIHByaWNlUHJlZml4PSckJ1xuICAgICAgICAgICAgb25DbGljaz17aGFuZGxlTW9kYWx9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC8+XG4gICAgICApIDogKFxuICAgICAgICA8PlxuICAgICAgICAgIDxDYXJ0U2xpZGVQb3B1cCBjbGFzc05hbWU9e2NhcnRTbGlkZXJDbGFzc30+XG4gICAgICAgICAgICB7aXNPcGVuICYmIChcbiAgICAgICAgICAgICAgPENhcnQgb25DbG9zZUJ0bkNsaWNrPXt0b2dnbGVDYXJ0fSBzY3JvbGxiYXJIZWlnaHQ9JzEwMHZoJyAvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L0NhcnRTbGlkZVBvcHVwPlxuXG4gICAgICAgICAgPEJveGVkQ2FydEJ1dHRvblxuICAgICAgICAgICAgY2xhc3NOYW1lPSdwcm9kdWN0LWNhcnQnXG4gICAgICAgICAgICBpdGVtQ291bnQ9e2NhcnRJdGVtc0NvdW50fVxuICAgICAgICAgICAgaXRlbVBvc3RmaXg9e1xuICAgICAgICAgICAgICBjYXJ0SXRlbXNDb3VudCA+IDEgPyAoXG4gICAgICAgICAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2UgaWQ9J2NhcnRJdGVtcycgZGVmYXVsdE1lc3NhZ2U9J2l0ZW1zJyAvPlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxGb3JtYXR0ZWRNZXNzYWdlIGlkPSdjYXJ0SXRlbScgZGVmYXVsdE1lc3NhZ2U9J2l0ZW0nIC8+XG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByaWNlPXtjYWxjdWxhdGVQcmljZSgpfVxuICAgICAgICAgICAgcHJpY2VQcmVmaXg9e0NVUlJFTkNZfVxuICAgICAgICAgICAgb25DbGljaz17dG9nZ2xlQ2FydH1cbiAgICAgICAgICAvPlxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYXJ0UG9wVXA7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/features/carts/cart-popup.tsx\n");

/***/ }),

/***/ "./src/features/carts/cart.style.tsx":
/*!*******************************************!*\
  !*** ./src/features/carts/cart.style.tsx ***!
  \*******************************************/
/*! exports provided: NoProductImg, CartSlidePopup, CartPopupBody, PopupHeader, PopupItemCount, PromoCode, CloseButton, ItemCards, ItemImgWrapper, ItemDetails, ItemTitle, ItemPrice, ItemWeight, TotalPrice, DeleteButton, CheckoutButton, CheckoutButtonWrapper, Title, PriceBox, NoProductMsg, ItemWrapper, CouponBoxWrapper, CouponCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoProductImg\", function() { return NoProductImg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartSlidePopup\", function() { return CartSlidePopup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartPopupBody\", function() { return CartPopupBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PopupHeader\", function() { return PopupHeader; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PopupItemCount\", function() { return PopupItemCount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PromoCode\", function() { return PromoCode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CloseButton\", function() { return CloseButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemCards\", function() { return ItemCards; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemImgWrapper\", function() { return ItemImgWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemDetails\", function() { return ItemDetails; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemTitle\", function() { return ItemTitle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemPrice\", function() { return ItemPrice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemWeight\", function() { return ItemWeight; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TotalPrice\", function() { return TotalPrice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeleteButton\", function() { return DeleteButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CheckoutButton\", function() { return CheckoutButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CheckoutButtonWrapper\", function() { return CheckoutButtonWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Title\", function() { return Title; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PriceBox\", function() { return PriceBox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoProductMsg\", function() { return NoProductMsg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ItemWrapper\", function() { return ItemWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CouponBoxWrapper\", function() { return CouponBoxWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CouponCode\", function() { return CouponCode; });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @styled-system/theme-get */ \"../../node_modules/@styled-system/theme-get/dist/index.esm.js\");\n\n\nvar CartPopupBody = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__CartPopupBody\",\n  componentId: \"sc-1cp3kia-0\"\n})([\"height:auto;width:385px;display:flex;flex-direction:column;border-radius:\", \";background-color:\", \";box-sizing:content-box;@media (max-width:767px){width:100%;}.cart-scrollbar{height:100%;max-height:calc(100vh - 245px);@media (max-width:767px){max-height:330px;}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('radii.base', '6px'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'));\nvar PopupHeader = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__PopupHeader\",\n  componentId: \"sc-1cp3kia-1\"\n})([\"padding:15px 25px;background-color:\", \";display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid \", \";@media (max-width:766px){justify-content:center;}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.gray.500', '#f1f1f1'));\nvar PopupItemCount = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__PopupItemCount\",\n  componentId: \"sc-1cp3kia-2\"\n})([\"display:inline-flex;align-items:center;color:\", \";span{font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";padding-left:10px;@media (max-width:767px){font-size:\", \"px;}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009e7f'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009e7f'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.sm', '13'));\nvar CloseButton = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].button.withConfig({\n  displayName: \"cartstyle__CloseButton\",\n  componentId: \"sc-1cp3kia-3\"\n})([\"width:14px;height:14px;display:inline-flex;align-items:center;justify-content:center;padding:0;border:0;outline:0;flex-shrink:0;cursor:pointer;color:rgba(0,0,0,0.25);transition:all 0.4s ease;background-color:transparent;&:hover{color:\", \";}@media (max-width:767px){position:absolute;top:-45px;background-color:\", \";width:35px;height:35px;border-radius:50%;color:rgba(0,0,0,0.5);}&.fixedCartClose{@media (min-width:991px){display:none;}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.red', '#ea4d4a'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'));\nvar ItemWrapper = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__ItemWrapper\",\n  componentId: \"sc-1cp3kia-4\"\n})([\"width:100%;height:auto;\"]);\nvar ItemCards = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__ItemCards\",\n  componentId: \"sc-1cp3kia-5\"\n})([\"width:100%;padding:15px 25px;display:inline-flex;align-items:center;background-color:\", \";margin-bottom:1px;box-sizing:border-box;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'));\nvar ItemImgWrapper = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__ItemImgWrapper\",\n  componentId: \"sc-1cp3kia-6\"\n})([\"width:60px;height:60px;display:inline-flex;align-items:center;justify-content:center;overflow:hidden;margin-right:15px;flex-shrink:0;img{width:100%;height:100%;object-fit:cover;}\"]);\nvar ItemDetails = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__ItemDetails\",\n  componentId: \"sc-1cp3kia-7\"\n})([\"display:inline-flex;flex-direction:column;width:100%;\"]);\nvar ItemTitle = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cartstyle__ItemTitle\",\n  componentId: \"sc-1cp3kia-8\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";margin-bottom:10px;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.regular', '400'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.bold', '#0D1136'));\nvar ItemPrice = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cartstyle__ItemPrice\",\n  componentId: \"sc-1cp3kia-9\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";margin-bottom:10px;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009e7f'));\nvar ItemWeight = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cartstyle__ItemWeight\",\n  componentId: \"sc-1cp3kia-10\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.sm', '13'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.regular', '400'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.regular', '#77798c'));\nvar TotalPrice = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cartstyle__TotalPrice\",\n  componentId: \"sc-1cp3kia-11\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";flex-shrink:0;margin-left:auto;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.bold', '#0D1136'));\nvar DeleteButton = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].button.withConfig({\n  displayName: \"cartstyle__DeleteButton\",\n  componentId: \"sc-1cp3kia-12\"\n})([\"width:10px;height:10px;display:inline-flex;align-items:center;justify-content:center;padding:0;border:0;outline:0;margin-left:15px;flex-shrink:0;cursor:pointer;color:rgba(0,0,0,0.25);transition:all 0.4s ease;background-color:transparent;&:hover{color:#ea4d4a;}\"]);\nvar PromoCode = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cartstyle__PromoCode\",\n  componentId: \"sc-1cp3kia-13\"\n})([\"margin:20px 0;display:flex;justify-content:center;> button{border:0;outline:0;box-shadow:none;background-color:transparent;display:inline-flex;cursor:pointer;font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";transition:color 0.35s ease;&:hover{color:\", \";}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009e7f'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.hover', '#019376'));\nvar CheckoutButton = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].button.withConfig({\n  displayName: \"cartstyle__CheckoutButton\",\n  componentId: \"sc-1cp3kia-14\"\n})([\"height:48px;width:calc(100% - 30px);display:flex;align-items:center;justify-content:space-between;background-color:\", \";padding:0;border-radius:48px;box-shadow:\", \";border:0;outline:0;cursor:pointer;margin-bottom:15px;margin-left:15px;@media (max-width:767px){height:45px;}> a{width:100%;display:flex;align-items:center;justify-content:space-between;padding-left:30px;}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009e7f'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('shadows.base', '0 3px 6px rgba(0, 0, 0, 0.16)'));\nvar CheckoutButtonWrapper = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__CheckoutButtonWrapper\",\n  componentId: \"sc-1cp3kia-15\"\n})([\"width:100%;display:flex;flex-direction:column;margin-top:auto;\"]);\nvar Title = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].a.withConfig({\n  displayName: \"cartstyle__Title\",\n  componentId: \"sc-1cp3kia-16\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";padding-left:5px;padding-right:10px;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'));\nvar PriceBox = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cartstyle__PriceBox\",\n  componentId: \"sc-1cp3kia-17\"\n})([\"width:auto;height:44px;padding:0 30px;overflow:hidden;border-radius:28px;display:inline-flex;align-items:center;justify-content:center;background-color:\", \";font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";margin-right:2px;@media (max-width:767px){height:41px;}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009e7f'));\nvar NoProductMsg = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].span.withConfig({\n  displayName: \"cartstyle__NoProductMsg\",\n  componentId: \"sc-1cp3kia-18\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";display:block;width:100%;padding:40px 0;text-align:center;\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.regular', '#77798c'));\nvar NoProductImg = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__NoProductImg\",\n  componentId: \"sc-1cp3kia-19\"\n})([\"display:flex;align-items:center;justify-content:center;margin-bottom:20px;margin-top:50px;@media (max-width:580px){margin-top:20px;}svg{width:140px;height:auto;@media (max-width:580px){width:110px;}}\"]);\nvar CouponBoxWrapper = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__CouponBoxWrapper\",\n  componentId: \"sc-1cp3kia-20\"\n})([\"width:100%;padding:0 15px;flex-direction:column;padding-right:22px;\"]);\nvar CouponCode = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].p.withConfig({\n  displayName: \"cartstyle__CouponCode\",\n  componentId: \"sc-1cp3kia-21\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";width:100%;display:flex;justify-content:center;span{font-weight:\", \";color:\", \";margin-left:5px;}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.medium', '500'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.regular', '#77798c'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.bold', '700'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.primary.regular', '#009e7f'));\nvar CartSlidePopup = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"cartstyle__CartSlidePopup\",\n  componentId: \"sc-1cp3kia-22\"\n})([\"width:420px;height:100vh;background-color:\", \";position:fixed;bottom:0;right:-450px;z-index:1010;box-shadow:\", \";transition:all 0.35s ease-in-out;@media (max-width:580px){width:100%;display:none;}@media (min-width:581px){display:block;}&.cartPopupFixed{right:0;}\", \"{height:100%;width:100%;}\", \"{max-height:calc(100vh - 245px);background-color:\", \";}\", \"{border-bottom:1px solid \", \";margin-bottom:0;}@media (max-width:767px){\", \"{justify-content:space-between;}\", \"{top:auto;position:relative;background-color:transparent;}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('shadows.big', '0 21px 36px rgba(0, 0, 0, 0.16)'), CartPopupBody, ItemWrapper, Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'), ItemCards, Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.gray.200', '#f7f7f7'), PopupHeader, CloseButton);\n\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ZlYXR1cmVzL2NhcnRzL2NhcnQuc3R5bGUudHN4PzdlODciXSwibmFtZXMiOlsiQ2FydFBvcHVwQm9keSIsInN0eWxlZCIsImRpdiIsInRoZW1lR2V0IiwiUG9wdXBIZWFkZXIiLCJQb3B1cEl0ZW1Db3VudCIsIkNsb3NlQnV0dG9uIiwiYnV0dG9uIiwiSXRlbVdyYXBwZXIiLCJJdGVtQ2FyZHMiLCJJdGVtSW1nV3JhcHBlciIsIkl0ZW1EZXRhaWxzIiwiSXRlbVRpdGxlIiwic3BhbiIsIkl0ZW1QcmljZSIsIkl0ZW1XZWlnaHQiLCJUb3RhbFByaWNlIiwiRGVsZXRlQnV0dG9uIiwiUHJvbW9Db2RlIiwiQ2hlY2tvdXRCdXR0b24iLCJDaGVja291dEJ1dHRvbldyYXBwZXIiLCJUaXRsZSIsImEiLCJQcmljZUJveCIsIk5vUHJvZHVjdE1zZyIsIk5vUHJvZHVjdEltZyIsIkNvdXBvbkJveFdyYXBwZXIiLCJDb3Vwb25Db2RlIiwicCIsIkNhcnRTbGlkZVBvcHVwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUVBLElBQU1BLGFBQWEsR0FBR0MseURBQU0sQ0FBQ0MsR0FBVjtBQUFBO0FBQUE7QUFBQSxnUkFLQUMseUVBQVEsQ0FBQyxZQUFELEVBQWUsS0FBZixDQUxSLEVBTUdBLHlFQUFRLENBQUMsY0FBRCxFQUFpQixTQUFqQixDQU5YLENBQW5CO0FBdUJBLElBQU1DLFdBQVcsR0FBR0gseURBQU0sQ0FBQ0MsR0FBVjtBQUFBO0FBQUE7QUFBQSw2TEFFS0MseUVBQVEsQ0FBQyxjQUFELEVBQWlCLFNBQWpCLENBRmIsRUFNWUEseUVBQVEsQ0FBQyxpQkFBRCxFQUFvQixTQUFwQixDQU5w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YXJ0LnN0eWxlLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgdGhlbWVHZXQgfSBmcm9tICdAc3R5bGVkLXN5c3RlbS90aGVtZS1nZXQnO1xuXG5jb25zdCBDYXJ0UG9wdXBCb2R5ID0gc3R5bGVkLmRpdmBcbiAgaGVpZ2h0OiBhdXRvO1xuICB3aWR0aDogMzg1cHg7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIGJvcmRlci1yYWRpdXM6ICR7dGhlbWVHZXQoJ3JhZGlpLmJhc2UnLCAnNnB4Jyl9O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbiAgYm94LXNpemluZzogY29udGVudC1ib3g7XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cblxuICAuY2FydC1zY3JvbGxiYXIge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKDEwMHZoIC0gMjQ1cHgpO1xuXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgICBtYXgtaGVpZ2h0OiAzMzBweDtcbiAgICB9XG4gIH1cbmA7XG5cbmNvbnN0IFBvcHVwSGVhZGVyID0gc3R5bGVkLmRpdmBcbiAgcGFkZGluZzogMTVweCAyNXB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgJHt0aGVtZUdldCgnY29sb3JzLmdyYXkuNTAwJywgJyNmMWYxZjEnKX07XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2NnB4KSB7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIH1cbmA7XG5cbmNvbnN0IFBvcHVwSXRlbUNvdW50ID0gc3R5bGVkLmRpdmBcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMucHJpbWFyeS5yZWd1bGFyJywgJyMwMDllN2YnKX07XG5cbiAgc3BhbiB7XG4gICAgZm9udC1mYW1pbHk6ICR7dGhlbWVHZXQoJ2ZvbnRzLmJvZHknLCAnTGF0bycpfTtcbiAgICBmb250LXNpemU6ICR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5iYXNlJywgJzE1Jyl9cHg7XG4gICAgZm9udC13ZWlnaHQ6ICR7dGhlbWVHZXQoJ2ZvbnRXZWlnaHRzLmJvbGQnLCAnNzAwJyl9O1xuICAgIGNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMucHJpbWFyeS5yZWd1bGFyJywgJyMwMDllN2YnKX07XG4gICAgcGFkZGluZy1sZWZ0OiAxMHB4O1xuXG4gICAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgICBmb250LXNpemU6ICR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5zbScsICcxMycpfXB4O1xuICAgIH1cbiAgfVxuYDtcblxuY29uc3QgQ2xvc2VCdXR0b24gPSBzdHlsZWQuYnV0dG9uYFxuICB3aWR0aDogMTRweDtcbiAgaGVpZ2h0OiAxNHB4O1xuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBhZGRpbmc6IDA7XG4gIGJvcmRlcjogMDtcbiAgb3V0bGluZTogMDtcbiAgZmxleC1zaHJpbms6IDA7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gIHRyYW5zaXRpb246IGFsbCAwLjRzIGVhc2U7XG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuXG4gICY6aG92ZXIge1xuICAgIGNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMucmVkJywgJyNlYTRkNGEnKX07XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgdG9wOiAtNDVweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbiAgICB3aWR0aDogMzVweDtcbiAgICBoZWlnaHQ6IDM1cHg7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gIH1cblxuICAmLmZpeGVkQ2FydENsb3NlIHtcbiAgICBAbWVkaWEgKG1pbi13aWR0aDogOTkxcHgpIHtcbiAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuICB9XG5gO1xuXG5jb25zdCBJdGVtV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IGF1dG87XG5gO1xuXG5jb25zdCBJdGVtQ2FyZHMgPSBzdHlsZWQuZGl2YFxuICB3aWR0aDogMTAwJTtcbiAgcGFkZGluZzogMTVweCAyNXB4O1xuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLndoaXRlJywgJyNmZmZmZmYnKX07XG4gIG1hcmdpbi1ib3R0b206IDFweDtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbmA7XG5cbmNvbnN0IEl0ZW1JbWdXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgd2lkdGg6IDYwcHg7XG4gIGhlaWdodDogNjBweDtcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBtYXJnaW4tcmlnaHQ6IDE1cHg7XG4gIGZsZXgtc2hyaW5rOiAwO1xuXG4gIGltZyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIG9iamVjdC1maXQ6IGNvdmVyO1xuICB9XG5gO1xuXG5jb25zdCBJdGVtRGV0YWlscyA9IHN0eWxlZC5kaXZgXG4gIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICB3aWR0aDogMTAwJTtcbmA7XG5cbmNvbnN0IEl0ZW1UaXRsZSA9IHN0eWxlZC5zcGFuYFxuICBmb250LWZhbWlseTogJHt0aGVtZUdldCgnZm9udHMuYm9keScsICdMYXRvJyl9O1xuICBmb250LXNpemU6ICR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5iYXNlJywgJzE1Jyl9cHg7XG4gIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5yZWd1bGFyJywgJzQwMCcpfTtcbiAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy50ZXh0LmJvbGQnLCAnIzBEMTEzNicpfTtcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcbmA7XG5cbmNvbnN0IEl0ZW1QcmljZSA9IHN0eWxlZC5zcGFuYFxuICBmb250LWZhbWlseTogJHt0aGVtZUdldCgnZm9udHMuYm9keScsICdMYXRvJyl9O1xuICBmb250LXNpemU6ICR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5iYXNlJywgJzE1Jyl9cHg7XG4gIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy5wcmltYXJ5LnJlZ3VsYXInLCAnIzAwOWU3ZicpfTtcbiAgbWFyZ2luLWJvdHRvbTogMTBweDtcbmA7XG5cbmNvbnN0IEl0ZW1XZWlnaHQgPSBzdHlsZWQuc3BhbmBcbiAgZm9udC1mYW1pbHk6ICR7dGhlbWVHZXQoJ2ZvbnRzLmJvZHknLCAnTGF0bycpfTtcbiAgZm9udC1zaXplOiAke3RoZW1lR2V0KCdmb250U2l6ZXMuc20nLCAnMTMnKX1weDtcbiAgZm9udC13ZWlnaHQ6ICR7dGhlbWVHZXQoJ2ZvbnRXZWlnaHRzLnJlZ3VsYXInLCAnNDAwJyl9O1xuICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnRleHQucmVndWxhcicsICcjNzc3OThjJyl9O1xuYDtcblxuY29uc3QgVG90YWxQcmljZSA9IHN0eWxlZC5zcGFuYFxuICBmb250LWZhbWlseTogJHt0aGVtZUdldCgnZm9udHMuYm9keScsICdMYXRvJyl9O1xuICBmb250LXNpemU6ICR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5iYXNlJywgJzE1Jyl9cHg7XG4gIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy50ZXh0LmJvbGQnLCAnIzBEMTEzNicpfTtcbiAgZmxleC1zaHJpbms6IDA7XG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xuYDtcblxuY29uc3QgRGVsZXRlQnV0dG9uID0gc3R5bGVkLmJ1dHRvbmBcbiAgd2lkdGg6IDEwcHg7XG4gIGhlaWdodDogMTBweDtcbiAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICBwYWRkaW5nOiAwO1xuICBib3JkZXI6IDA7XG4gIG91dGxpbmU6IDA7XG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xuICBmbGV4LXNocmluazogMDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjI1KTtcbiAgdHJhbnNpdGlvbjogYWxsIDAuNHMgZWFzZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG5cbiAgJjpob3ZlciB7XG4gICAgY29sb3I6ICNlYTRkNGE7XG4gIH1cbmA7XG5cbmNvbnN0IFByb21vQ29kZSA9IHN0eWxlZC5zcGFuYFxuICBtYXJnaW46IDIwcHggMDtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cbiAgPiBidXR0b24ge1xuICAgIGJvcmRlcjogMDtcbiAgICBvdXRsaW5lOiAwO1xuICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIGZvbnQtZmFtaWx5OiAke3RoZW1lR2V0KCdmb250cy5ib2R5JywgJ0xhdG8nKX07XG4gICAgZm9udC1zaXplOiAke3RoZW1lR2V0KCdmb250U2l6ZXMuYmFzZScsICcxNScpfXB4O1xuICAgIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnByaW1hcnkucmVndWxhcicsICcjMDA5ZTdmJyl9O1xuICAgIHRyYW5zaXRpb246IGNvbG9yIDAuMzVzIGVhc2U7XG4gICAgJjpob3ZlciB7XG4gICAgICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnByaW1hcnkuaG92ZXInLCAnIzAxOTM3NicpfTtcbiAgICB9XG4gIH1cbmA7XG5cbmNvbnN0IENoZWNrb3V0QnV0dG9uID0gc3R5bGVkLmJ1dHRvbmBcbiAgaGVpZ2h0OiA0OHB4O1xuICB3aWR0aDogY2FsYygxMDAlIC0gMzBweCk7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnByaW1hcnkucmVndWxhcicsICcjMDA5ZTdmJyl9O1xuICBwYWRkaW5nOiAwO1xuICBib3JkZXItcmFkaXVzOiA0OHB4O1xuICBib3gtc2hhZG93OiAke3RoZW1lR2V0KCdzaGFkb3dzLmJhc2UnLCAnMCAzcHggNnB4IHJnYmEoMCwgMCwgMCwgMC4xNiknKX07XG4gIGJvcmRlcjogMDtcbiAgb3V0bGluZTogMDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICAvKiBtYXJnaW4tdG9wOiBhdXRvOyAqL1xuICBtYXJnaW4tYm90dG9tOiAxNXB4O1xuICBtYXJnaW4tbGVmdDogMTVweDtcblxuICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICBoZWlnaHQ6IDQ1cHg7XG4gIH1cblxuICA+IGEge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgcGFkZGluZy1sZWZ0OiAzMHB4O1xuICB9XG5gO1xuXG5jb25zdCBDaGVja291dEJ1dHRvbldyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICB3aWR0aDogMTAwJTtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgbWFyZ2luLXRvcDogYXV0bztcbmA7XG5cbmNvbnN0IFRpdGxlID0gc3R5bGVkLmFgXG4gIGZvbnQtZmFtaWx5OiAke3RoZW1lR2V0KCdmb250cy5ib2R5JywgJ0xhdG8nKX07XG4gIGZvbnQtc2l6ZTogJHt0aGVtZUdldCgnZm9udFNpemVzLmJhc2UnLCAnMTUnKX1weDtcbiAgZm9udC13ZWlnaHQ6ICR7dGhlbWVHZXQoJ2ZvbnRXZWlnaHRzLmJvbGQnLCAnNzAwJyl9O1xuICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLndoaXRlJywgJyNmZmZmZmYnKX07XG4gIHBhZGRpbmctbGVmdDogNXB4O1xuICBwYWRkaW5nLXJpZ2h0OiAxMHB4O1xuYDtcblxuY29uc3QgUHJpY2VCb3ggPSBzdHlsZWQuc3BhbmBcbiAgd2lkdGg6IGF1dG87XG4gIGhlaWdodDogNDRweDtcbiAgcGFkZGluZzogMCAzMHB4O1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICBib3JkZXItcmFkaXVzOiAyOHB4O1xuICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy53aGl0ZScsICcjZmZmZmZmJyl9O1xuICBmb250LWZhbWlseTogJHt0aGVtZUdldCgnZm9udHMuYm9keScsICdMYXRvJyl9O1xuICBmb250LXNpemU6ICR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5iYXNlJywgJzE1Jyl9cHg7XG4gIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy5wcmltYXJ5LnJlZ3VsYXInLCAnIzAwOWU3ZicpfTtcbiAgbWFyZ2luLXJpZ2h0OiAycHg7XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDc2N3B4KSB7XG4gICAgaGVpZ2h0OiA0MXB4O1xuICB9XG5gO1xuXG5jb25zdCBOb1Byb2R1Y3RNc2cgPSBzdHlsZWQuc3BhbmBcbiAgZm9udC1mYW1pbHk6ICR7dGhlbWVHZXQoJ2ZvbnRzLmJvZHknLCAnTGF0bycpfTtcbiAgZm9udC1zaXplOiAke3RoZW1lR2V0KCdmb250U2l6ZXMuYmFzZScsICcxNScpfXB4O1xuICBmb250LXdlaWdodDogJHt0aGVtZUdldCgnZm9udFdlaWdodHMuYm9sZCcsICc3MDAnKX07XG4gIGNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMudGV4dC5yZWd1bGFyJywgJyM3Nzc5OGMnKX07XG4gIGRpc3BsYXk6IGJsb2NrO1xuICB3aWR0aDogMTAwJTtcbiAgcGFkZGluZzogNDBweCAwO1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG5gO1xuXG5leHBvcnQgY29uc3QgTm9Qcm9kdWN0SW1nID0gc3R5bGVkLmRpdmBcbiAgZGlzcGxheTogZmxleDtcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XG4gIG1hcmdpbi10b3A6IDUwcHg7XG5cbiAgQG1lZGlhIChtYXgtd2lkdGg6IDU4MHB4KSB7XG4gICAgbWFyZ2luLXRvcDogMjBweDtcbiAgfVxuXG4gIHN2ZyB7XG4gICAgd2lkdGg6IDE0MHB4O1xuICAgIGhlaWdodDogYXV0bztcblxuICAgIEBtZWRpYSAobWF4LXdpZHRoOiA1ODBweCkge1xuICAgICAgd2lkdGg6IDExMHB4O1xuICAgIH1cbiAgfVxuYDtcblxuY29uc3QgQ291cG9uQm94V3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gIHdpZHRoOiAxMDAlO1xuICBwYWRkaW5nOiAwIDE1cHg7XG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIHBhZGRpbmctcmlnaHQ6IDIycHg7XG5gO1xuXG5jb25zdCBDb3Vwb25Db2RlID0gc3R5bGVkLnBgXG4gIGZvbnQtZmFtaWx5OiAke3RoZW1lR2V0KCdmb250cy5ib2R5JywgJ0xhdG8nKX07XG4gIGZvbnQtc2l6ZTogJHt0aGVtZUdldCgnZm9udFNpemVzLmJhc2UnLCAnMTUnKX1weDtcbiAgZm9udC13ZWlnaHQ6ICR7dGhlbWVHZXQoJ2ZvbnRXZWlnaHRzLm1lZGl1bScsICc1MDAnKX07XG4gIGNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMudGV4dC5yZWd1bGFyJywgJyM3Nzc5OGMnKX07XG5cbiAgd2lkdGg6IDEwMCU7XG4gIGRpc3BsYXk6IGZsZXg7XG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuXG4gIHNwYW4ge1xuICAgIGZvbnQtd2VpZ2h0OiAke3RoZW1lR2V0KCdmb250V2VpZ2h0cy5ib2xkJywgJzcwMCcpfTtcbiAgICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnByaW1hcnkucmVndWxhcicsICcjMDA5ZTdmJyl9O1xuICAgIG1hcmdpbi1sZWZ0OiA1cHg7XG4gIH1cbmA7XG5cbmNvbnN0IENhcnRTbGlkZVBvcHVwID0gc3R5bGVkLmRpdmBcbiAgd2lkdGg6IDQyMHB4O1xuICBoZWlnaHQ6IDEwMHZoO1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbiAgcG9zaXRpb246IGZpeGVkO1xuICBib3R0b206IDA7XG4gIHJpZ2h0OiAtNDUwcHg7XG4gIHotaW5kZXg6IDEwMTA7XG4gIGJveC1zaGFkb3c6ICR7dGhlbWVHZXQoJ3NoYWRvd3MuYmlnJywgJzAgMjFweCAzNnB4IHJnYmEoMCwgMCwgMCwgMC4xNiknKX07XG4gIHRyYW5zaXRpb246IGFsbCAwLjM1cyBlYXNlLWluLW91dDtcblxuICBAbWVkaWEgKG1heC13aWR0aDogNTgwcHgpIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG5cbiAgQG1lZGlhIChtaW4td2lkdGg6IDU4MXB4KSB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gIH1cblxuICAmLmNhcnRQb3B1cEZpeGVkIHtcbiAgICByaWdodDogMDtcbiAgfVxuXG4gICR7Q2FydFBvcHVwQm9keX0ge1xuICAgIGhlaWdodDogMTAwJTtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuXG4gICR7SXRlbVdyYXBwZXJ9IHtcbiAgICAvKiBoZWlnaHQ6IGNhbGMoMTAwdmggLSAyNDBweCk7ICovXG4gICAgbWF4LWhlaWdodDogY2FsYygxMDB2aCAtIDI0NXB4KTtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lR2V0KCdjb2xvcnMud2hpdGUnLCAnI2ZmZmZmZicpfTtcbiAgfVxuXG4gICR7SXRlbUNhcmRzfSB7XG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICR7dGhlbWVHZXQoJ2NvbG9ycy5ncmF5LjIwMCcsICcjZjdmN2Y3Jyl9O1xuICAgIG1hcmdpbi1ib3R0b206IDA7XG4gIH1cblxuICBAbWVkaWEgKG1heC13aWR0aDogNzY3cHgpIHtcbiAgICAke1BvcHVwSGVhZGVyfSB7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgfVxuXG4gICAgJHtDbG9zZUJ1dHRvbn0ge1xuICAgICAgdG9wOiBhdXRvO1xuICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgfVxuICB9XG5gO1xuXG5leHBvcnQge1xuICBDYXJ0U2xpZGVQb3B1cCxcbiAgQ2FydFBvcHVwQm9keSxcbiAgUG9wdXBIZWFkZXIsXG4gIFBvcHVwSXRlbUNvdW50LFxuICBQcm9tb0NvZGUsXG4gIENsb3NlQnV0dG9uLFxuICBJdGVtQ2FyZHMsXG4gIEl0ZW1JbWdXcmFwcGVyLFxuICBJdGVtRGV0YWlscyxcbiAgSXRlbVRpdGxlLFxuICBJdGVtUHJpY2UsXG4gIEl0ZW1XZWlnaHQsXG4gIFRvdGFsUHJpY2UsXG4gIERlbGV0ZUJ1dHRvbixcbiAgQ2hlY2tvdXRCdXR0b24sXG4gIENoZWNrb3V0QnV0dG9uV3JhcHBlcixcbiAgVGl0bGUsXG4gIFByaWNlQm94LFxuICBOb1Byb2R1Y3RNc2csXG4gIEl0ZW1XcmFwcGVyLFxuICBDb3Vwb25Cb3hXcmFwcGVyLFxuICBDb3Vwb25Db2RlLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/features/carts/cart.style.tsx\n");

/***/ }),

/***/ "./src/features/carts/cart.tsx":
/*!*************************************!*\
  !*** ./src/features/carts/cart.tsx ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/link */ \"../../node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _cart_style__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cart.style */ \"./src/features/carts/cart.style.tsx\");\n/* harmony import */ var assets_icons_CloseIcon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! assets/icons/CloseIcon */ \"./src/assets/icons/CloseIcon.tsx\");\n/* harmony import */ var assets_icons_ShoppingBagLarge__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! assets/icons/ShoppingBagLarge */ \"./src/assets/icons/ShoppingBagLarge.tsx\");\n/* harmony import */ var assets_icons_NoCartBag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! assets/icons/NoCartBag */ \"./src/assets/icons/NoCartBag.tsx\");\n/* harmony import */ var utils_constant__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! utils/constant */ \"./src/utils/constant.ts\");\n/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-intl */ \"../../node_modules/react-intl/lib/index.js\");\n/* harmony import */ var contexts_language_language_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! contexts/language/language.provider */ \"./src/contexts/language/language.provider.tsx\");\n/* harmony import */ var components_scrollbar_scrollbar__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! components/scrollbar/scrollbar */ \"./src/components/scrollbar/scrollbar.tsx\");\n/* harmony import */ var contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! contexts/cart/use-cart */ \"./src/contexts/cart/use-cart.tsx\");\n/* harmony import */ var components_cart_item_cart_item__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! components/cart-item/cart-item */ \"./src/components/cart-item/cart-item.tsx\");\n/* harmony import */ var features_coupon_coupon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! features/coupon/coupon */ \"./src/features/coupon/coupon.tsx\");\n\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/features/carts/cart.tsx\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar Cart = function Cart(_ref) {\n  _s();\n\n  var style = _ref.style,\n      className = _ref.className,\n      onCloseBtnClick = _ref.onCloseBtnClick,\n      scrollbarHeight = _ref.scrollbarHeight;\n\n  var _useCart = Object(contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_11__[\"useCart\"])(),\n      items = _useCart.items,\n      coupon = _useCart.coupon,\n      addItem = _useCart.addItem,\n      removeItem = _useCart.removeItem,\n      removeItemFromCart = _useCart.removeItemFromCart,\n      cartItemsCount = _useCart.cartItemsCount,\n      calculatePrice = _useCart.calculatePrice;\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(false),\n      hasCoupon = _useState[0],\n      setCoupon = _useState[1];\n\n  var _useLocale = Object(contexts_language_language_provider__WEBPACK_IMPORTED_MODULE_9__[\"useLocale\"])(),\n      isRtl = _useLocale.isRtl;\n\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"CartPopupBody\"], {\n    className: className,\n    style: style,\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"PopupHeader\"], {\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"PopupItemCount\"], {\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_ShoppingBagLarge__WEBPACK_IMPORTED_MODULE_5__[\"ShoppingBagLarge\"], {\n          width: \"19px\",\n          height: \"24px\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 68,\n          columnNumber: 11\n        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"span\", {\n          children: [cartItemsCount, \"\\xA0\", cartItemsCount > 1 ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_8__[\"FormattedMessage\"], {\n            id: \"cartItems\",\n            defaultMessage: \"items\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 73,\n            columnNumber: 15\n          }, _this) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_8__[\"FormattedMessage\"], {\n            id: \"cartItem\",\n            defaultMessage: \"item\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 75,\n            columnNumber: 15\n          }, _this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 69,\n          columnNumber: 11\n        }, _this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"CloseButton\"], {\n        onClick: onCloseBtnClick,\n        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_CloseIcon__WEBPACK_IMPORTED_MODULE_4__[\"CloseIcon\"], {}, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 81,\n          columnNumber: 11\n        }, _this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 80,\n        columnNumber: 9\n      }, _this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(components_scrollbar_scrollbar__WEBPACK_IMPORTED_MODULE_10__[\"Scrollbar\"], {\n      className: \"cart-scrollbar\",\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"ItemWrapper\"], {\n        className: \"items-wrapper\",\n        children: !!cartItemsCount ? items.map(function (item) {\n          return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(components_cart_item_cart_item__WEBPACK_IMPORTED_MODULE_12__[\"CartItem\"], {\n            onIncrement: function onIncrement() {\n              return addItem(item);\n            },\n            onDecrement: function onDecrement() {\n              return removeItem(item);\n            },\n            onRemove: function onRemove() {\n              return removeItemFromCart(item);\n            },\n            data: item\n          }, \"cartItem-\".concat(item.id), false, {\n            fileName: _jsxFileName,\n            lineNumber: 89,\n            columnNumber: 15\n          }, _this);\n        }) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"NoProductImg\"], {\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(assets_icons_NoCartBag__WEBPACK_IMPORTED_MODULE_6__[\"NoCartBag\"], {}, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 100,\n              columnNumber: 17\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 99,\n            columnNumber: 15\n          }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"NoProductMsg\"], {\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_8__[\"FormattedMessage\"], {\n              id: \"noProductFound\",\n              defaultMessage: \"No products found\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 103,\n              columnNumber: 17\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 102,\n            columnNumber: 15\n          }, _this)]\n        }, void 0, true)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 86,\n        columnNumber: 9\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 7\n    }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"CheckoutButtonWrapper\"], {\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"PromoCode\"], {\n        children: !(coupon !== null && coupon !== void 0 && coupon.discountInPercent) ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n          children: !hasCoupon ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"button\", {\n            onClick: function onClick() {\n              return setCoupon(function (prev) {\n                return !prev;\n              });\n            },\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_8__[\"FormattedMessage\"], {\n              id: \"specialCode\",\n              defaultMessage: \"Have a special code?\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 119,\n              columnNumber: 19\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 118,\n            columnNumber: 17\n          }, _this) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"CouponBoxWrapper\"], {\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(features_coupon_coupon__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n              disabled: !items.length,\n              style: {\n                boxShadow: '0 3px 6px rgba(0, 0, 0, 0.06)'\n              }\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 126,\n              columnNumber: 19\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 125,\n            columnNumber: 17\n          }, _this)\n        }, void 0, false) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"CouponCode\"], {\n          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_8__[\"FormattedMessage\"], {\n            id: \"couponApplied\",\n            defaultMessage: \"Coupon Applied\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 137,\n            columnNumber: 15\n          }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"span\", {\n            children: coupon.code\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 141,\n            columnNumber: 15\n          }, _this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 136,\n          columnNumber: 13\n        }, _this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 114,\n        columnNumber: 9\n      }, _this), cartItemsCount !== 0 ? /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(next_link__WEBPACK_IMPORTED_MODULE_2___default.a, {\n        href: \"/checkout\",\n        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"CheckoutButton\"], {\n          onClick: onCloseBtnClick,\n          children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n            children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"Title\"], {\n              children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_8__[\"FormattedMessage\"], {\n                id: \"nav.checkout\",\n                defaultMessage: \"Checkout\"\n              }, void 0, false, {\n                fileName: _jsxFileName,\n                lineNumber: 151,\n                columnNumber: 19\n              }, _this)\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 150,\n              columnNumber: 17\n            }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"PriceBox\"], {\n              children: [utils_constant__WEBPACK_IMPORTED_MODULE_7__[\"CURRENCY\"], calculatePrice()]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 156,\n              columnNumber: 17\n            }, _this)]\n          }, void 0, true)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 148,\n          columnNumber: 13\n        }, _this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 147,\n        columnNumber: 11\n      }, _this) : /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"CheckoutButton\"], {\n        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n          children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"Title\"], {\n            children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_8__[\"FormattedMessage\"], {\n              id: \"nav.checkout\",\n              defaultMessage: \"Checkout\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 167,\n              columnNumber: 17\n            }, _this)\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 166,\n            columnNumber: 15\n          }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_cart_style__WEBPACK_IMPORTED_MODULE_3__[\"PriceBox\"], {\n            children: [utils_constant__WEBPACK_IMPORTED_MODULE_7__[\"CURRENCY\"], calculatePrice()]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 169,\n            columnNumber: 15\n          }, _this)]\n        }, void 0, true)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 164,\n        columnNumber: 11\n      }, _this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 7\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 65,\n    columnNumber: 5\n  }, _this);\n};\n\n_s(Cart, \"Da20TR0BUuAbTd/JOMrvPIMKr6E=\", false, function () {\n  return [contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_11__[\"useCart\"], contexts_language_language_provider__WEBPACK_IMPORTED_MODULE_9__[\"useLocale\"]];\n});\n\n_c = Cart;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Cart);\n\nvar _c;\n\n$RefreshReg$(_c, \"Cart\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ZlYXR1cmVzL2NhcnRzL2NhcnQudHN4PzAyNmIiXSwibmFtZXMiOlsiQ2FydCIsInN0eWxlIiwiY2xhc3NOYW1lIiwib25DbG9zZUJ0bkNsaWNrIiwic2Nyb2xsYmFySGVpZ2h0IiwidXNlQ2FydCIsIml0ZW1zIiwiY291cG9uIiwiYWRkSXRlbSIsInJlbW92ZUl0ZW0iLCJyZW1vdmVJdGVtRnJvbUNhcnQiLCJjYXJ0SXRlbXNDb3VudCIsImNhbGN1bGF0ZVByaWNlIiwidXNlU3RhdGUiLCJoYXNDb3Vwb24iLCJzZXRDb3Vwb24iLCJ1c2VMb2NhbGUiLCJpc1J0bCIsIm1hcCIsIml0ZW0iLCJpZCIsImRpc2NvdW50SW5QZXJjZW50IiwicHJldiIsImxlbmd0aCIsImJveFNoYWRvdyIsImNvZGUiLCJDVVJSRU5DWSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFpQkEsSUFBTUEsSUFBNkIsR0FBRyxTQUFoQ0EsSUFBZ0MsT0FLaEM7QUFBQTs7QUFBQSxNQUpKQyxLQUlJLFFBSkpBLEtBSUk7QUFBQSxNQUhKQyxTQUdJLFFBSEpBLFNBR0k7QUFBQSxNQUZKQyxlQUVJLFFBRkpBLGVBRUk7QUFBQSxNQURKQyxlQUNJLFFBREpBLGVBQ0k7O0FBQUEsaUJBU0FDLHVFQUFPLEVBVFA7QUFBQSxNQUVGQyxLQUZFLFlBRUZBLEtBRkU7QUFBQSxNQUdGQyxNQUhFLFlBR0ZBLE1BSEU7QUFBQSxNQUlGQyxPQUpFLFlBSUZBLE9BSkU7QUFBQSxNQUtGQyxVQUxFLFlBS0ZBLFVBTEU7QUFBQSxNQU1GQyxrQkFORSxZQU1GQSxrQkFORTtBQUFBLE1BT0ZDLGNBUEUsWUFPRkEsY0FQRTtBQUFBLE1BUUZDLGNBUkUsWUFRRkEsY0FSRTs7QUFBQSxrQkFVMkJDLHNEQUFRLENBQUMsS0FBRCxD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QixnQkFBRSxFQUFDLGNBQXJCO0FBQW9DLDRCQUFjLEVBQUM7QUFBbkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQURGO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBREYsZUFJRSxxRUFBQyxvREFBRDtBQUFBLHVCQUNHYyx1REFESCxFQUVHZCxjQUFjLEVBRmpCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFKRjtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQW5ESjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFoREY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBREY7QUFtSEQsQ0FySUQ7O0dBQU1aLEk7VUFjQUssK0QsRUFFY1csNkU7OztLQWhCZGhCLEk7QUF1SVNBLG1FQUFmIiwiZmlsZSI6Ii4vc3JjL2ZlYXR1cmVzL2NhcnRzL2NhcnQudHN4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IExpbmsgZnJvbSAnbmV4dC9saW5rJztcbmltcG9ydCB7XG4gIENhcnRQb3B1cEJvZHksXG4gIFBvcHVwSGVhZGVyLFxuICBQb3B1cEl0ZW1Db3VudCxcbiAgQ2xvc2VCdXR0b24sXG4gIFByb21vQ29kZSxcbiAgQ2hlY2tvdXRCdXR0b25XcmFwcGVyLFxuICBDaGVja291dEJ1dHRvbixcbiAgVGl0bGUsXG4gIFByaWNlQm94LFxuICBOb1Byb2R1Y3RNc2csXG4gIE5vUHJvZHVjdEltZyxcbiAgSXRlbVdyYXBwZXIsXG4gIENvdXBvbkJveFdyYXBwZXIsXG4gIENvdXBvbkNvZGUsXG59IGZyb20gJy4vY2FydC5zdHlsZSc7XG5pbXBvcnQgeyBDbG9zZUljb24gfSBmcm9tICdhc3NldHMvaWNvbnMvQ2xvc2VJY29uJztcbmltcG9ydCB7IFNob3BwaW5nQmFnTGFyZ2UgfSBmcm9tICdhc3NldHMvaWNvbnMvU2hvcHBpbmdCYWdMYXJnZSc7XG5pbXBvcnQgeyBOb0NhcnRCYWcgfSBmcm9tICdhc3NldHMvaWNvbnMvTm9DYXJ0QmFnJztcbmltcG9ydCB7IENVUlJFTkNZIH0gZnJvbSAndXRpbHMvY29uc3RhbnQnO1xuaW1wb3J0IHsgRm9ybWF0dGVkTWVzc2FnZSB9IGZyb20gJ3JlYWN0LWludGwnO1xuaW1wb3J0IHsgdXNlTG9jYWxlIH0gZnJvbSAnY29udGV4dHMvbGFuZ3VhZ2UvbGFuZ3VhZ2UucHJvdmlkZXInO1xuXG5pbXBvcnQgeyBTY3JvbGxiYXIgfSBmcm9tICdjb21wb25lbnRzL3Njcm9sbGJhci9zY3JvbGxiYXInO1xuaW1wb3J0IHsgdXNlQ2FydCB9IGZyb20gJ2NvbnRleHRzL2NhcnQvdXNlLWNhcnQnO1xuaW1wb3J0IHsgQ2FydEl0ZW0gfSBmcm9tICdjb21wb25lbnRzL2NhcnQtaXRlbS9jYXJ0LWl0ZW0nO1xuaW1wb3J0IENvdXBvbiBmcm9tICdmZWF0dXJlcy9jb3Vwb24vY291cG9uJztcblxuXG5cblxuXG5cblxuXG5cbnR5cGUgQ2FydFByb3BzVHlwZSA9IHtcbiAgc3R5bGU/OiBhbnk7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgc2Nyb2xsYmFySGVpZ2h0Pzogc3RyaW5nO1xuICBvbkNsb3NlQnRuQ2xpY2s/OiAoZTogYW55KSA9PiB2b2lkO1xufTtcblxuY29uc3QgQ2FydDogUmVhY3QuRkM8Q2FydFByb3BzVHlwZT4gPSAoe1xuICBzdHlsZSxcbiAgY2xhc3NOYW1lLFxuICBvbkNsb3NlQnRuQ2xpY2ssXG4gIHNjcm9sbGJhckhlaWdodCxcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGl0ZW1zLFxuICAgIGNvdXBvbixcbiAgICBhZGRJdGVtLFxuICAgIHJlbW92ZUl0ZW0sXG4gICAgcmVtb3ZlSXRlbUZyb21DYXJ0LFxuICAgIGNhcnRJdGVtc0NvdW50LFxuICAgIGNhbGN1bGF0ZVByaWNlLFxuICB9ID0gdXNlQ2FydCgpO1xuICBjb25zdCBbaGFzQ291cG9uLCBzZXRDb3Vwb25dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCB7IGlzUnRsIH0gPSB1c2VMb2NhbGUoKTtcblxuICByZXR1cm4gKFxuICAgIDxDYXJ0UG9wdXBCb2R5IGNsYXNzTmFtZT17Y2xhc3NOYW1lfSBzdHlsZT17c3R5bGV9PlxuICAgICAgPFBvcHVwSGVhZGVyPlxuICAgICAgICA8UG9wdXBJdGVtQ291bnQ+XG4gICAgICAgICAgPFNob3BwaW5nQmFnTGFyZ2Ugd2lkdGg9JzE5cHgnIGhlaWdodD0nMjRweCcgLz5cbiAgICAgICAgICA8c3Bhbj5cbiAgICAgICAgICAgIHtjYXJ0SXRlbXNDb3VudH1cbiAgICAgICAgICAgICZuYnNwO1xuICAgICAgICAgICAge2NhcnRJdGVtc0NvdW50ID4gMSA/IChcbiAgICAgICAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2UgaWQ9J2NhcnRJdGVtcycgZGVmYXVsdE1lc3NhZ2U9J2l0ZW1zJyAvPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2UgaWQ9J2NhcnRJdGVtJyBkZWZhdWx0TWVzc2FnZT0naXRlbScgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L1BvcHVwSXRlbUNvdW50PlxuXG4gICAgICAgIDxDbG9zZUJ1dHRvbiBvbkNsaWNrPXtvbkNsb3NlQnRuQ2xpY2t9PlxuICAgICAgICAgIDxDbG9zZUljb24gLz5cbiAgICAgICAgPC9DbG9zZUJ1dHRvbj5cbiAgICAgIDwvUG9wdXBIZWFkZXI+XG5cbiAgICAgIDxTY3JvbGxiYXIgY2xhc3NOYW1lPSdjYXJ0LXNjcm9sbGJhcic+XG4gICAgICAgIDxJdGVtV3JhcHBlciBjbGFzc05hbWU9J2l0ZW1zLXdyYXBwZXInPlxuICAgICAgICAgIHshIWNhcnRJdGVtc0NvdW50ID8gKFxuICAgICAgICAgICAgaXRlbXMubWFwKChpdGVtKSA9PiAoXG4gICAgICAgICAgICAgIDxDYXJ0SXRlbVxuICAgICAgICAgICAgICAgIGtleT17YGNhcnRJdGVtLSR7aXRlbS5pZH1gfVxuICAgICAgICAgICAgICAgIG9uSW5jcmVtZW50PXsoKSA9PiBhZGRJdGVtKGl0ZW0pfVxuICAgICAgICAgICAgICAgIG9uRGVjcmVtZW50PXsoKSA9PiByZW1vdmVJdGVtKGl0ZW0pfVxuICAgICAgICAgICAgICAgIG9uUmVtb3ZlPXsoKSA9PiByZW1vdmVJdGVtRnJvbUNhcnQoaXRlbSl9XG4gICAgICAgICAgICAgICAgZGF0YT17aXRlbX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpXG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgIDxOb1Byb2R1Y3RJbWc+XG4gICAgICAgICAgICAgICAgPE5vQ2FydEJhZyAvPlxuICAgICAgICAgICAgICA8L05vUHJvZHVjdEltZz5cbiAgICAgICAgICAgICAgPE5vUHJvZHVjdE1zZz5cbiAgICAgICAgICAgICAgICA8Rm9ybWF0dGVkTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgaWQ9J25vUHJvZHVjdEZvdW5kJ1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdE1lc3NhZ2U9J05vIHByb2R1Y3RzIGZvdW5kJ1xuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvTm9Qcm9kdWN0TXNnPlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9JdGVtV3JhcHBlcj5cbiAgICAgIDwvU2Nyb2xsYmFyPlxuXG4gICAgICA8Q2hlY2tvdXRCdXR0b25XcmFwcGVyPlxuICAgICAgICA8UHJvbW9Db2RlPlxuICAgICAgICAgIHshY291cG9uPy5kaXNjb3VudEluUGVyY2VudCA/IChcbiAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgIHshaGFzQ291cG9uID8gKFxuICAgICAgICAgICAgICAgIDxidXR0b24gb25DbGljaz17KCkgPT4gc2V0Q291cG9uKChwcmV2KSA9PiAhcHJldil9PlxuICAgICAgICAgICAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWQ9J3NwZWNpYWxDb2RlJ1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TWVzc2FnZT0nSGF2ZSBhIHNwZWNpYWwgY29kZT8nXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxDb3Vwb25Cb3hXcmFwcGVyPlxuICAgICAgICAgICAgICAgICAgPENvdXBvblxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZD17IWl0ZW1zLmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICBib3hTaGFkb3c6ICcwIDNweCA2cHggcmdiYSgwLCAwLCAwLCAwLjA2KScsXG4gICAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvQ291cG9uQm94V3JhcHBlcj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvPlxuICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICA8Q291cG9uQ29kZT5cbiAgICAgICAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2VcbiAgICAgICAgICAgICAgICBpZD0nY291cG9uQXBwbGllZCdcbiAgICAgICAgICAgICAgICBkZWZhdWx0TWVzc2FnZT0nQ291cG9uIEFwcGxpZWQnXG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDxzcGFuPntjb3Vwb24uY29kZX08L3NwYW4+XG4gICAgICAgICAgICA8L0NvdXBvbkNvZGU+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9Qcm9tb0NvZGU+XG5cbiAgICAgICAge2NhcnRJdGVtc0NvdW50ICE9PSAwID8gKFxuICAgICAgICAgIDxMaW5rIGhyZWY9Jy9jaGVja291dCc+XG4gICAgICAgICAgICA8Q2hlY2tvdXRCdXR0b24gb25DbGljaz17b25DbG9zZUJ0bkNsaWNrfT5cbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8VGl0bGU+XG4gICAgICAgICAgICAgICAgICA8Rm9ybWF0dGVkTWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBpZD0nbmF2LmNoZWNrb3V0J1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TWVzc2FnZT0nQ2hlY2tvdXQnXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvVGl0bGU+XG4gICAgICAgICAgICAgICAgPFByaWNlQm94PlxuICAgICAgICAgICAgICAgICAge0NVUlJFTkNZfVxuICAgICAgICAgICAgICAgICAge2NhbGN1bGF0ZVByaWNlKCl9XG4gICAgICAgICAgICAgICAgPC9QcmljZUJveD5cbiAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICA8L0NoZWNrb3V0QnV0dG9uPlxuICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8Q2hlY2tvdXRCdXR0b24+XG4gICAgICAgICAgICA8PlxuICAgICAgICAgICAgICA8VGl0bGU+XG4gICAgICAgICAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2UgaWQ9J25hdi5jaGVja291dCcgZGVmYXVsdE1lc3NhZ2U9J0NoZWNrb3V0JyAvPlxuICAgICAgICAgICAgICA8L1RpdGxlPlxuICAgICAgICAgICAgICA8UHJpY2VCb3g+XG4gICAgICAgICAgICAgICAge0NVUlJFTkNZfVxuICAgICAgICAgICAgICAgIHtjYWxjdWxhdGVQcmljZSgpfVxuICAgICAgICAgICAgICA8L1ByaWNlQm94PlxuICAgICAgICAgICAgPC8+XG4gICAgICAgICAgPC9DaGVja291dEJ1dHRvbj5cbiAgICAgICAgKX1cbiAgICAgIDwvQ2hlY2tvdXRCdXR0b25XcmFwcGVyPlxuICAgIDwvQ2FydFBvcHVwQm9keT5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENhcnQ7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/features/carts/cart.tsx\n");

/***/ }),

/***/ "./src/features/coupon/coupon.style.tsx":
/*!**********************************************!*\
  !*** ./src/features/coupon/coupon.style.tsx ***!
  \**********************************************/
/*! exports provided: CouponBoxWrapper, Error */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CouponBoxWrapper\", function() { return CouponBoxWrapper; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Error\", function() { return Error; });\n/* harmony import */ var styled_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! styled-components */ \"./node_modules/styled-components/dist/styled-components.browser.esm.js\");\n/* harmony import */ var _styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @styled-system/theme-get */ \"../../node_modules/@styled-system/theme-get/dist/index.esm.js\");\n\n\nvar CouponBoxWrapper = styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"].div.withConfig({\n  displayName: \"couponstyle__CouponBoxWrapper\",\n  componentId: \"sc-2yxgz5-0\"\n})([\"&.boxedCoupon{display:flex;flex-direction:row;align-items:center;width:100%;height:50px;padding-right:5px;border-radius:\", \";background-color:\", \";overflow:hidden;border:1px solid \", \";}input{height:100%;flex-grow:1;font-size:calc(\", \"px - 1px);color:\", \";border:none;border-radius:0;padding:0 20px;background-color:transparent;margin-right:0;&:focus{outline:0;}&::-webkit-input-placeholder{font-size:calc(\", \"px - 1px);color:\", \";}&:-moz-placeholder{font-size:calc(\", \"px - 1px);color:\", \";}&::-moz-placeholder{font-size:calc(\", \"px - 1px);color:\", \";}&:-ms-input-placeholder{font-size:calc(\", \"px - 1px);color:\", \";}}&.normalCoupon{width:100%;display:flex;align-items:center;input{width:50%;height:48px;margin-right:20px;border:1px solid \", \" !important;background-color:\", \";flex-grow:unset;border-radius:\", \";@media (max-width:600px){width:100%;}}button{height:48px;}}\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('radii.base', '6px'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.white', '#ffffff'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.gray.600', '#ededed'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.regular', '#77798C'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.label', '#767676'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.label', '#767676'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.label', '#767676'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.text.label', '#767676'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.lightDarkColor', '#e6e6e6'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.lightColor', '#f7f7f7'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('radii.base', '6px'));\nvar Error = Object(styled_components__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('span').withConfig({\n  displayName: \"couponstyle__Error\",\n  componentId: \"sc-2yxgz5-1\"\n})([\"font-family:\", \";font-size:\", \"px;font-weight:\", \";color:\", \";padding-top:10px;display:flex;justify-content:center;position:\", \";left:\", \";bottom:\", \";\"], Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fonts.body', 'Lato'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontSizes.base', '15'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('fontWeights.regular', '400'), Object(_styled_system_theme_get__WEBPACK_IMPORTED_MODULE_1__[\"themeGet\"])('colors.secondary.hover', '#FF282F'), function (props) {\n  return props.errorMsgFixed === true ? 'absolute' : 'relative';\n}, function (props) {\n  return props.errorMsgFixed === true ? '20px' : 'auto';\n}, function (props) {\n  return props.errorMsgFixed === true ? '-25px' : 'auto';\n});\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ZlYXR1cmVzL2NvdXBvbi9jb3Vwb24uc3R5bGUudHN4PzU3YzEiXSwibmFtZXMiOlsiQ291cG9uQm94V3JhcHBlciIsInN0eWxlZCIsImRpdiIsInRoZW1lR2V0IiwiRXJyb3IiLCJwcm9wcyIsImVycm9yTXNnRml4ZWQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBRU8sSUFBTUEsZ0JBQWdCLEdBQUdDLHlEQUFNLENBQUNDLEdBQVY7QUFBQTtBQUFBO0FBQUEsaTNCQVFSQyx5RUFBUSxDQUFDLFlBQUQsRUFBZSxLQUFmLENBUkEsRUFTTEEseUVBQVEsQ0FBQyxjQUFELEVBQWlCLFNBQWpCLENBVEgsRUFXTEEseUVBQVEsQ0FBQyxpQkFBRCxFQUFvQixTQUFwQixDQVhILEVBaUJQQSx5RUFBUSxDQUFDLGdCQUFELEVBQW1CLElBQW5CLENBakJELEVBa0JoQkEseUVBQVEsQ0FBQyxxQkFBRCxFQUF3QixTQUF4QixDQWxCUSxFQThCTEEseUVBQVEsQ0FBQyxnQkFBRCxFQUFtQixJQUFuQixDQTlCSCxFQStCZEEseUVBQVEsQ0FBQyxtQkFBRCxFQUFzQixTQUF0QixDQS9CTSxFQW1DTEEseUVBQVEsQ0FBQyxnQkFBRCxFQUFtQixJQUFuQixDQW5DSCxFQW9DZEEseUVBQVEsQ0FBQyxtQkFBRCxFQUFzQixTQUF0QixDQXBDTSxFQXdDTEEseUVBQVEsQ0FBQyxnQkFBRCxFQUFtQixJQUFuQixDQXhDSCxFQXlDZEEseUVBQVEsQ0FBQyxtQkFBRCxFQUFzQixTQUF0QixDQXpDTSxFQTRDTEEseUVBQVEsQ0FBQyxnQkFBRCxFQUFtQixJQUFuQixDQTVDSCxFQTZDZEEseUVBQVEsQ0FBQyxtQkFBRCxFQUFzQixTQUF0QixDQTdDTSxFQTBESEEseUVBQVEsQ0FBQyx1QkFBRCxFQUEwQixTQUExQixDQTFETCxFQTJESEEseUVBQVEsQ0FBQyxtQkFBRCxFQUFzQixTQUF0QixDQTNETCxFQTZETkEseUVBQVEsQ0FBQyxZQUFELEVBQWUsS0FBZixDQTdERixDQUF0QjtBQThFQSxJQUFNQyxLQUFLLEdBQUdILGlFQUFNLENBQUMsTUFBRCxDQUFUO0FBQUE7QUFBQTtBQUFBLGdLQUNERSx5RUFBUSxDQUFDLFlBQUQsRUFBZSxNQUFmLENBRFAsRUFFSEEseUVBQVEsQ0FBQyxnQkFBRCxFQUFtQixJQUFuQixDQUZMLEVBR0RBLHlFQUFRLENBQUMscUJBQUQsRUFBd0IsS0FBeEIsQ0FIUCxFQUlQQSx5RUFBUSxDQUFDLHdCQUFELEVBQTJCLFNBQTNCLENBSkQsRUFRSixVQUFDRSxLQUFEO0FBQUEsU0FDVkEsS0FBSyxDQUFDQyxhQUFOLEtBQXdCLElBQXhCLEdBQStCLFVBQS9CLEdBQTRDLFVBRGxDO0FBQUEsQ0FSSSxFQVVSLFVBQUNELEtBQUQ7QUFBQSxTQUFZQSxLQUFLLENBQUNDLGFBQU4sS0FBd0IsSUFBeEIsR0FBK0IsTUFBL0IsR0FBd0MsTUFBcEQ7QUFBQSxDQVZRLEVBV04sVUFBQ0QsS0FBRDtBQUFBLFNBQVlBLEtBQUssQ0FBQ0MsYUFBTixLQUF3QixJQUF4QixHQUErQixPQUEvQixHQUF5QyxNQUFyRDtBQUFBLENBWE0sQ0FBWCIsImZpbGUiOiIuL3NyYy9mZWF0dXJlcy9jb3Vwb24vY291cG9uLnN0eWxlLnRzeC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSAnc3R5bGVkLWNvbXBvbmVudHMnO1xuaW1wb3J0IHsgdGhlbWVHZXQgfSBmcm9tICdAc3R5bGVkLXN5c3RlbS90aGVtZS1nZXQnO1xuXG5leHBvcnQgY29uc3QgQ291cG9uQm94V3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gICYuYm94ZWRDb3Vwb24ge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogNTBweDtcbiAgICBwYWRkaW5nLXJpZ2h0OiA1cHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHt0aGVtZUdldCgncmFkaWkuYmFzZScsICc2cHgnKX07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLndoaXRlJywgJyNmZmZmZmYnKX07XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lR2V0KCdjb2xvcnMuZ3JheS42MDAnLCAnI2VkZWRlZCcpfTtcbiAgfVxuXG4gIGlucHV0IHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gICAgZmxleC1ncm93OiAxO1xuICAgIGZvbnQtc2l6ZTogY2FsYygke3RoZW1lR2V0KCdmb250U2l6ZXMuYmFzZScsICcxNScpfXB4IC0gMXB4KTtcbiAgICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnRleHQucmVndWxhcicsICcjNzc3OThDJyl9O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3JkZXItcmFkaXVzOiAwO1xuICAgIHBhZGRpbmc6IDAgMjBweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBtYXJnaW4tcmlnaHQ6IDA7XG5cbiAgICAmOmZvY3VzIHtcbiAgICAgIG91dGxpbmU6IDA7XG4gICAgfVxuXG4gICAgJjo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgICBmb250LXNpemU6IGNhbGMoJHt0aGVtZUdldCgnZm9udFNpemVzLmJhc2UnLCAnMTUnKX1weCAtIDFweCk7XG4gICAgICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnRleHQubGFiZWwnLCAnIzc2NzY3NicpfTtcbiAgICB9XG5cbiAgICAmOi1tb3otcGxhY2Vob2xkZXIge1xuICAgICAgZm9udC1zaXplOiBjYWxjKCR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5iYXNlJywgJzE1Jyl9cHggLSAxcHgpO1xuICAgICAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy50ZXh0LmxhYmVsJywgJyM3Njc2NzYnKX07XG4gICAgfVxuXG4gICAgJjo6LW1vei1wbGFjZWhvbGRlciB7XG4gICAgICBmb250LXNpemU6IGNhbGMoJHt0aGVtZUdldCgnZm9udFNpemVzLmJhc2UnLCAnMTUnKX1weCAtIDFweCk7XG4gICAgICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnRleHQubGFiZWwnLCAnIzc2NzY3NicpfTtcbiAgICB9XG4gICAgJjotbXMtaW5wdXQtcGxhY2Vob2xkZXIge1xuICAgICAgZm9udC1zaXplOiBjYWxjKCR7dGhlbWVHZXQoJ2ZvbnRTaXplcy5iYXNlJywgJzE1Jyl9cHggLSAxcHgpO1xuICAgICAgY29sb3I6ICR7dGhlbWVHZXQoJ2NvbG9ycy50ZXh0LmxhYmVsJywgJyM3Njc2NzYnKX07XG4gICAgfVxuICB9XG5cbiAgJi5ub3JtYWxDb3Vwb24ge1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgIGlucHV0IHtcbiAgICAgIHdpZHRoOiA1MCU7XG4gICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICBtYXJnaW4tcmlnaHQ6IDIwcHg7XG4gICAgICBib3JkZXI6IDFweCBzb2xpZCAke3RoZW1lR2V0KCdjb2xvcnMubGlnaHREYXJrQ29sb3InLCAnI2U2ZTZlNicpfSAhaW1wb3J0YW50O1xuICAgICAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLmxpZ2h0Q29sb3InLCAnI2Y3ZjdmNycpfTtcbiAgICAgIGZsZXgtZ3JvdzogdW5zZXQ7XG4gICAgICBib3JkZXItcmFkaXVzOiAke3RoZW1lR2V0KCdyYWRpaS5iYXNlJywgJzZweCcpfTtcblxuICAgICAgQG1lZGlhIChtYXgtd2lkdGg6IDYwMHB4KSB7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGJ1dHRvbiB7XG4gICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgfVxuICB9XG5gO1xuXG50eXBlIEVycm9yTXNnUHJvcHMgPSB7XG4gIGVycm9yTXNnRml4ZWQ/OiBib29sZWFuO1xufTtcblxuZXhwb3J0IGNvbnN0IEVycm9yID0gc3R5bGVkKCdzcGFuJyk8RXJyb3JNc2dQcm9wcz5gXG4gIGZvbnQtZmFtaWx5OiAke3RoZW1lR2V0KCdmb250cy5ib2R5JywgJ0xhdG8nKX07XG4gIGZvbnQtc2l6ZTogJHt0aGVtZUdldCgnZm9udFNpemVzLmJhc2UnLCAnMTUnKX1weDtcbiAgZm9udC13ZWlnaHQ6ICR7dGhlbWVHZXQoJ2ZvbnRXZWlnaHRzLnJlZ3VsYXInLCAnNDAwJyl9O1xuICBjb2xvcjogJHt0aGVtZUdldCgnY29sb3JzLnNlY29uZGFyeS5ob3ZlcicsICcjRkYyODJGJyl9O1xuICBwYWRkaW5nLXRvcDogMTBweDtcbiAgZGlzcGxheTogZmxleDtcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIHBvc2l0aW9uOiAkeyhwcm9wcykgPT5cbiAgICBwcm9wcy5lcnJvck1zZ0ZpeGVkID09PSB0cnVlID8gJ2Fic29sdXRlJyA6ICdyZWxhdGl2ZSd9O1xuICBsZWZ0OiAkeyhwcm9wcykgPT4gKHByb3BzLmVycm9yTXNnRml4ZWQgPT09IHRydWUgPyAnMjBweCcgOiAnYXV0bycpfTtcbiAgYm90dG9tOiAkeyhwcm9wcykgPT4gKHByb3BzLmVycm9yTXNnRml4ZWQgPT09IHRydWUgPyAnLTI1cHgnIDogJ2F1dG8nKX07XG5gO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/features/coupon/coupon.style.tsx\n");

/***/ }),

/***/ "./src/features/coupon/coupon.tsx":
/*!****************************************!*\
  !*** ./src/features/coupon/coupon.tsx ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/regenerator */ \"../../node_modules/next/node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var react_intl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! react-intl */ \"../../node_modules/react-intl/lib/index.js\");\n/* harmony import */ var _coupon_style__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coupon.style */ \"./src/features/coupon/coupon.style.tsx\");\n/* harmony import */ var components_forms_input__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! components/forms/input */ \"./src/components/forms/input.tsx\");\n/* harmony import */ var components_button_button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! components/button/button */ \"./src/components/button/button.tsx\");\n/* harmony import */ var contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! contexts/cart/use-cart */ \"./src/contexts/cart/use-cart.tsx\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @apollo/client */ \"../../node_modules/@apollo/client/index.js\");\n/* harmony import */ var graphql_mutation_coupon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! graphql/mutation/coupon */ \"./src/graphql/mutation/coupon.ts\");\n\n\n\n\n\n\n\n\nvar _jsxFileName = \"/Users/alejandrosandoval/space/world_eserp/web/packages/shop-restaurant/src/features/coupon/coupon.tsx\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\n\n\n\n\n\n\n\nvar Coupon = function Coupon(_ref) {\n  _s();\n\n  var disabled = _ref.disabled,\n      className = _ref.className,\n      style = _ref.style,\n      _ref$errorMsgFixed = _ref.errorMsgFixed,\n      errorMsgFixed = _ref$errorMsgFixed === void 0 ? false : _ref$errorMsgFixed,\n      props = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(_ref, [\"disabled\", \"className\", \"style\", \"errorMsgFixed\"]);\n\n  var intl = Object(react_intl__WEBPACK_IMPORTED_MODULE_7__[\"useIntl\"])();\n\n  var _useCart = Object(contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_11__[\"useCart\"])(),\n      applyCoupon = _useCart.applyCoupon;\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_6__[\"useState\"])(''),\n      code = _useState[0],\n      setCode = _useState[1];\n\n  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_6__[\"useState\"])(null),\n      error = _useState2[0],\n      setError = _useState2[1];\n\n  var _useMutation = Object(_apollo_client__WEBPACK_IMPORTED_MODULE_12__[\"useMutation\"])(graphql_mutation_coupon__WEBPACK_IMPORTED_MODULE_13__[\"APPLY_COUPON\"]),\n      _useMutation2 = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(_useMutation, 1),\n      appliedCoupon = _useMutation2[0];\n\n  var handleApplyCoupon = /*#__PURE__*/function () {\n    var _ref2 = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_3__[\"default\"])( /*#__PURE__*/_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.mark(function _callee() {\n      var _yield$appliedCoupon, data;\n\n      return _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_2___default.a.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return appliedCoupon({\n                variables: {\n                  code: code\n                }\n              });\n\n            case 2:\n              _yield$appliedCoupon = _context.sent;\n              data = _yield$appliedCoupon.data;\n\n              if (data.applyCoupon && data.applyCoupon.discountInPercent) {\n                setError('');\n                applyCoupon(data.applyCoupon);\n                setCode('');\n              } else {\n                setError('Invalid Coupon');\n              }\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function handleApplyCoupon() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var handleOnChange = function handleOnChange(e) {\n    setCode(e.currentTarget.value);\n  };\n\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"Fragment\"], {\n    children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_coupon_style__WEBPACK_IMPORTED_MODULE_8__[\"CouponBoxWrapper\"], {\n      className: className ? className : 'boxedCoupon',\n      style: style,\n      children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(components_forms_input__WEBPACK_IMPORTED_MODULE_9__[\"Input\"], _objectSpread({\n        onChange: handleOnChange,\n        value: code,\n        placeholder: intl.formatMessage({\n          id: 'couponPlaceholder',\n          defaultMessage: 'Ingresar Cupn Aqu'\n        })\n      }, props), void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 51,\n        columnNumber: 9\n      }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(components_button_button__WEBPACK_IMPORTED_MODULE_10__[\"Button\"], {\n        type: \"button\",\n        onClick: handleApplyCoupon,\n        disabled: disabled,\n        padding: \"0 30px\",\n        children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_7__[\"FormattedMessage\"], {\n          id: \"voucherApply\",\n          defaultMessage: \"Apply\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 66,\n          columnNumber: 11\n        }, _this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 60,\n        columnNumber: 9\n      }, _this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 47,\n      columnNumber: 7\n    }, _this), error && /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_coupon_style__WEBPACK_IMPORTED_MODULE_8__[\"Error\"], {\n      errorMsgFixed: errorMsgFixed,\n      children: /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_intl__WEBPACK_IMPORTED_MODULE_7__[\"FormattedMessage\"], {\n        id: \"couponError\",\n        defaultMessage: error\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 71,\n        columnNumber: 11\n      }, _this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 9\n    }, _this)]\n  }, void 0, true);\n};\n\n_s(Coupon, \"K/eaDyWCiOHJCcfGf1R0+A2frLc=\", false, function () {\n  return [react_intl__WEBPACK_IMPORTED_MODULE_7__[\"useIntl\"], contexts_cart_use_cart__WEBPACK_IMPORTED_MODULE_11__[\"useCart\"], _apollo_client__WEBPACK_IMPORTED_MODULE_12__[\"useMutation\"]];\n});\n\n_c = Coupon;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Coupon);\n\nvar _c;\n\n$RefreshReg$(_c, \"Coupon\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2ZlYXR1cmVzL2NvdXBvbi9jb3Vwb24udHN4P2YxNTciXSwibmFtZXMiOlsiQ291cG9uIiwiZGlzYWJsZWQiLCJjbGFzc05hbWUiLCJzdHlsZSIsImVycm9yTXNnRml4ZWQiLCJwcm9wcyIsImludGwiLCJ1c2VJbnRsIiwidXNlQ2FydCIsImFwcGx5Q291cG9uIiwidXNlU3RhdGUiLCJjb2RlIiwic2V0Q29kZSIsImVycm9yIiwic2V0RXJyb3IiLCJ1c2VNdXRhdGlvbiIsIkFQUExZX0NPVVBPTiIsImFwcGxpZWRDb3Vwb24iLCJoYW5kbGVBcHBseUNvdXBvbiIsInZhcmlhYmxlcyIsImRhdGEiLCJkaXNjb3VudEluUGVyY2VudCIsImhhbmRsZU9uQ2hhbmdlIiwiZSIsImN1cnJlbnRUYXJnZXQiLCJ2YWx1ZSIsImZvcm1hdE1lc3NhZ2UiLCJpZCIsImRlZmF1bHRNZXNzYWdlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFTQSxJQUFNQSxNQUE2QixHQUFHLFNBQWhDQSxNQUFnQyxPQU1oQztBQUFBOztBQUFBLE1BTEpDLFFBS0ksUUFMSkEsUUFLSTtBQUFBLE1BSkpDLFNBSUksUUFKSkEsU0FJSTtBQUFBLE1BSEpDLEtBR0ksUUFISkEsS0FHSTtBQUFBLGdDQUZKQyxhQUVJO0FBQUEsTUFGSkEsYUFFSSxtQ0FGWSxLQUVaO0FBQUEsTUFEREMsS0FDQzs7QUFDSixNQUFNQyxJQUFJLEdBQUdDLDBEQUFPLEVBQXBCOztBQURJLGlCQUVvQkMsdUVBQU8sRUFGM0I7QUFBQSxNQUVJQyxXQUZKLFlBRUlBLFdBRko7O0FBQUEsa0JBR29CQyxzREFBUSxDQUFDLEVBQUQsQ0FINUI7QUFBQSxNQUdHQyxJQUhIO0FBQUEsTUFHU0MsT0FIVDs7QUFBQSxtQkFJc0JGLHNEQUFRLENBQUMsSUFBRCxDQUo5QjtBQUFBLE1BSUdHLEtBSkg7QUFBQSxNQUlVQyxRQUpWOztBQUFBLHFCQUtvQkMsbUVBQVcsQ0FBQ0MscUVBQUQsQ0FML0I7QUFBQTtBQUFBLE1BS0dDLGFBTEg7O0FBT0osTUFBTUMsaUJBQWlCO0FBQUEsMlZBQUc7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJBQ0lELGFBQWEsQ0FBQztBQUN4Q0UseUJBQVMsRUFBRTtBQUFFUixzQkFBSSxFQUFKQTtBQUFGO0FBRDZCLGVBQUQsQ0FEakI7O0FBQUE7QUFBQTtBQUNoQlMsa0JBRGdCLHdCQUNoQkEsSUFEZ0I7O0FBSXhCLGtCQUFJQSxJQUFJLENBQUNYLFdBQUwsSUFBb0JXLElBQUksQ0FBQ1gsV0FBTCxDQUFpQlksaUJBQXpDLEVBQTREO0FBQzFEUCx3QkFBUSxDQUFDLEVBQUQsQ0FBUjtBQUNBTCwyQkFBVyxDQUFDVyxJQUFJLENBQUNYLFdBQU4sQ0FBWDtBQUNBRyx1QkFBTyxDQUFDLEVBQUQsQ0FBUDtBQUNELGVBSkQsTUFJTztBQUNMRSx3QkFBUSxDQUFDLGdCQUFELENBQVI7QUFDRDs7QUFWdUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FBSDs7QUFBQSxvQkFBakJJLGlCQUFpQjtBQUFBO0FBQUE7QUFBQSxLQUF2Qjs7QUFZQSxNQUFNSSxjQUEwRCxHQUFHLFNBQTdEQSxjQUE2RCxDQUFDQyxDQUFELEVBQU87QUFDeEVYLFdBQU8sQ0FBQ1csQ0FBQyxDQUFDQyxhQUFGLENBQWdCQyxLQUFqQixDQUFQO0FBQ0QsR0FGRDs7QUFHQSxzQkFDRTtBQUFBLDRCQUNFLHFFQUFDLDhEQUFEO0FBQ0UsZUFBUyxFQUFFdkIsU0FBUyxHQUFHQSxTQUFILEdBQWUsYUFEckM7QUFFRSxXQUFLLEVBQUVDLEtBRlQ7QUFBQSw4QkFJRSxxRUFBQyw0REFBRDtBQUNFLGdCQUFRLEVBQUVtQixjQURaO0FBRUUsYUFBSyxFQUFFWCxJQUZUO0FBR0UsbUJBQVcsRUFBRUwsSUFBSSxDQUFDb0IsYUFBTCxDQUFtQjtBQUM5QkMsWUFBRSxFQUFFLG1CQUQwQjtBQUU5QkMsd0JBQWMsRUFBRTtBQUZjLFNBQW5CO0FBSGYsU0FPTXZCLEtBUE47QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUpGLGVBYUUscUVBQUMsZ0VBQUQ7QUFDRSxZQUFJLEVBQUMsUUFEUDtBQUVFLGVBQU8sRUFBRWEsaUJBRlg7QUFHRSxnQkFBUSxFQUFFakIsUUFIWjtBQUlFLGVBQU8sRUFBQyxRQUpWO0FBQUEsK0JBTUUscUVBQUMsMkRBQUQ7QUFBa0IsWUFBRSxFQUFDLGNBQXJCO0FBQW9DLHdCQUFjLEVBQUM7QUFBbkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQU5GO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFiRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFERixFQXVCR1ksS0FBSyxpQkFDSixxRUFBQyxtREFBRDtBQUFPLG1CQUFhLEVBQUVULGFBQXRCO0FBQUEsNkJBQ0UscUVBQUMsMkRBQUQ7QUFBa0IsVUFBRSxFQUFDLGFBQXJCO0FBQW1DLHNCQUFjLEVBQUVTO0FBQW5EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFERjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBeEJKO0FBQUEsa0JBREY7QUErQkQsQ0EzREQ7O0dBQU1iLE07VUFPU08sa0QsRUFDV0MsK0QsRUFHQU8sMkQ7OztLQVhwQmYsTTtBQTZEU0EscUVBQWYiLCJmaWxlIjoiLi9zcmMvZmVhdHVyZXMvY291cG9uL2NvdXBvbi50c3guanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBGb3JtYXR0ZWRNZXNzYWdlLCB1c2VJbnRsIH0gZnJvbSAncmVhY3QtaW50bCc7XG5pbXBvcnQgeyBDb3Vwb25Cb3hXcmFwcGVyLCBFcnJvciB9IGZyb20gJy4vY291cG9uLnN0eWxlJztcbmltcG9ydCB7IElucHV0IH0gZnJvbSAnY29tcG9uZW50cy9mb3Jtcy9pbnB1dCc7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tICdjb21wb25lbnRzL2J1dHRvbi9idXR0b24nO1xuaW1wb3J0IHsgdXNlQ2FydCB9IGZyb20gJ2NvbnRleHRzL2NhcnQvdXNlLWNhcnQnO1xuaW1wb3J0IHsgdXNlTXV0YXRpb24gfSBmcm9tICdAYXBvbGxvL2NsaWVudCc7XG5pbXBvcnQgeyBBUFBMWV9DT1VQT04gfSBmcm9tICdncmFwaHFsL211dGF0aW9uL2NvdXBvbic7XG5cbnR5cGUgQ291cG9uUHJvcHMgPSB7XG4gIGRpc2FibGVkPzogYW55O1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHN0eWxlPzogYW55O1xuICBlcnJvck1zZ0ZpeGVkPzogYm9vbGVhbjtcbn07XG5cbmNvbnN0IENvdXBvbjogUmVhY3QuRkM8Q291cG9uUHJvcHM+ID0gKHtcbiAgZGlzYWJsZWQsXG4gIGNsYXNzTmFtZSxcbiAgc3R5bGUsXG4gIGVycm9yTXNnRml4ZWQgPSBmYWxzZSxcbiAgLi4ucHJvcHNcbn0pID0+IHtcbiAgY29uc3QgaW50bCA9IHVzZUludGwoKTtcbiAgY29uc3QgeyBhcHBseUNvdXBvbiB9ID0gdXNlQ2FydCgpO1xuICBjb25zdCBbY29kZSwgc2V0Q29kZV0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFthcHBsaWVkQ291cG9uXSA9IHVzZU11dGF0aW9uKEFQUExZX0NPVVBPTik7XG5cbiAgY29uc3QgaGFuZGxlQXBwbHlDb3Vwb24gPSBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhIH06IGFueSA9IGF3YWl0IGFwcGxpZWRDb3Vwb24oe1xuICAgICAgdmFyaWFibGVzOiB7IGNvZGUgfSxcbiAgICB9KTtcbiAgICBpZiAoZGF0YS5hcHBseUNvdXBvbiAmJiBkYXRhLmFwcGx5Q291cG9uLmRpc2NvdW50SW5QZXJjZW50KSB7XG4gICAgICBzZXRFcnJvcignJyk7XG4gICAgICBhcHBseUNvdXBvbihkYXRhLmFwcGx5Q291cG9uKTtcbiAgICAgIHNldENvZGUoJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRFcnJvcignSW52YWxpZCBDb3Vwb24nKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZU9uQ2hhbmdlOiBSZWFjdC5DaGFuZ2VFdmVudEhhbmRsZXI8SFRNTElucHV0RWxlbWVudD4gPSAoZSkgPT4ge1xuICAgIHNldENvZGUoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKTtcbiAgfTtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPENvdXBvbkJveFdyYXBwZXJcbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWUgPyBjbGFzc05hbWUgOiAnYm94ZWRDb3Vwb24nfVxuICAgICAgICBzdHlsZT17c3R5bGV9XG4gICAgICA+XG4gICAgICAgIDxJbnB1dFxuICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVPbkNoYW5nZX1cbiAgICAgICAgICB2YWx1ZT17Y29kZX1cbiAgICAgICAgICBwbGFjZWhvbGRlcj17aW50bC5mb3JtYXRNZXNzYWdlKHtcbiAgICAgICAgICAgIGlkOiAnY291cG9uUGxhY2Vob2xkZXInLFxuICAgICAgICAgICAgZGVmYXVsdE1lc3NhZ2U6ICdJbmdyZXNhciBDdXDDs24gQXF1w60nLFxuICAgICAgICAgIH0pfVxuICAgICAgICAgIHsuLi5wcm9wc31cbiAgICAgICAgLz5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIHR5cGU9J2J1dHRvbidcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVBcHBseUNvdXBvbn1cbiAgICAgICAgICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gICAgICAgICAgcGFkZGluZz0nMCAzMHB4J1xuICAgICAgICA+XG4gICAgICAgICAgPEZvcm1hdHRlZE1lc3NhZ2UgaWQ9J3ZvdWNoZXJBcHBseScgZGVmYXVsdE1lc3NhZ2U9J0FwcGx5JyAvPlxuICAgICAgICA8L0J1dHRvbj5cbiAgICAgIDwvQ291cG9uQm94V3JhcHBlcj5cbiAgICAgIHtlcnJvciAmJiAoXG4gICAgICAgIDxFcnJvciBlcnJvck1zZ0ZpeGVkPXtlcnJvck1zZ0ZpeGVkfT5cbiAgICAgICAgICA8Rm9ybWF0dGVkTWVzc2FnZSBpZD0nY291cG9uRXJyb3InIGRlZmF1bHRNZXNzYWdlPXtlcnJvcn0gLz5cbiAgICAgICAgPC9FcnJvcj5cbiAgICAgICl9XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDb3Vwb247XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/features/coupon/coupon.tsx\n");

/***/ }),

/***/ "./src/graphql/mutation/coupon.ts":
/*!****************************************!*\
  !*** ./src/graphql/mutation/coupon.ts ***!
  \****************************************/
/*! exports provided: APPLY_COUPON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"APPLY_COUPON\", function() { return APPLY_COUPON; });\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @apollo/client */ \"../../node_modules/@apollo/client/index.js\");\n\n\nfunction _templateObject() {\n  var data = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_taggedTemplateLiteral__WEBPACK_IMPORTED_MODULE_0__[\"default\"])([\"\\n  mutation applyCoupon($code: String!) {\\n    applyCoupon(code: $code) {\\n      id\\n      code\\n      discountInPercent\\n    }\\n  }\\n\"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\n\nvar APPLY_COUPON = Object(_apollo_client__WEBPACK_IMPORTED_MODULE_1__[\"gql\"])(_templateObject());\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2dyYXBocWwvbXV0YXRpb24vY291cG9uLnRzPzlkZjQiXSwibmFtZXMiOlsiQVBQTFlfQ09VUE9OIiwiZ3FsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFFTyxJQUFNQSxZQUFZLEdBQUdDLDBEQUFILG1CQUFsQiIsImZpbGUiOiIuL3NyYy9ncmFwaHFsL211dGF0aW9uL2NvdXBvbi50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdxbCB9IGZyb20gJ0BhcG9sbG8vY2xpZW50JztcblxuZXhwb3J0IGNvbnN0IEFQUExZX0NPVVBPTiA9IGdxbGBcbiAgbXV0YXRpb24gYXBwbHlDb3Vwb24oJGNvZGU6IFN0cmluZyEpIHtcbiAgICBhcHBseUNvdXBvbihjb2RlOiAkY29kZSkge1xuICAgICAgaWRcbiAgICAgIGNvZGVcbiAgICAgIGRpc2NvdW50SW5QZXJjZW50XG4gICAgfVxuICB9XG5gO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/graphql/mutation/coupon.ts\n");

/***/ }),

/***/ "./src/utils/constant.ts":
/*!*******************************!*\
  !*** ./src/utils/constant.ts ***!
  \*******************************/
/*! exports provided: CURRENCY */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CURRENCY\", function() { return CURRENCY; });\n/************ CONSTANTS ***********/\nvar CURRENCY = '$';\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL2NvbnN0YW50LnRzPzdmZmMiXSwibmFtZXMiOlsiQ1VSUkVOQ1kiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNPLElBQU1BLFFBQVEsR0FBRyxHQUFqQiIsImZpbGUiOiIuL3NyYy91dGlscy9jb25zdGFudC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKiogQ09OU1RBTlRTICoqKioqKioqKioqL1xuZXhwb3J0IGNvbnN0IENVUlJFTkNZID0gJyQnO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/utils/constant.ts\n");

/***/ }),

/***/ "./src/utils/use-storage.ts":
/*!**********************************!*\
  !*** ./src/utils/use-storage.ts ***!
  \**********************************/
/*! exports provided: useStorage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useStorage\", function() { return useStorage; });\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/regenerator */ \"../../node_modules/next/node_modules/@babel/runtime/regenerator/index.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! /Users/alejandrosandoval/space/world_eserp/web/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty */ \"../../node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var localforage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! localforage */ \"../../node_modules/localforage/dist/localforage.js\");\n/* harmony import */ var localforage__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(localforage__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\n\nvar isObjectLiked = function isObjectLiked(value) {\n  return value.constructor.name === 'Array' || value.constructor.name === 'Object';\n};\n\nvar rehydrate = function rehydrate(value, defaultValue) {\n  if (!value) return defaultValue; // if (value === 'false') str = false;\n  // if (value === 'true') str = true;\n  // if (!isObjectLiked(value)) {\n  //   return value;\n  // }\n\n  try {\n    var parse = JSON.parse(value);\n    return parse;\n  } catch (err) {\n    return defaultValue;\n  }\n};\n\nvar hydrate = function hydrate(value) {\n  if (!isObjectLiked(value)) {\n    return value;\n  }\n\n  return JSON.stringify(value);\n};\n\nvar createMigration = function createMigration(opts, data) {\n  return new Promise(function (resolve, reject) {\n    var key = \"\".concat(opts.key, \"-version\");\n    localforage__WEBPACK_IMPORTED_MODULE_4___default.a.getItem(key, function (err, version) {\n      if (version !== opts.version) {\n        data = opts.migrate(data);\n        localforage__WEBPACK_IMPORTED_MODULE_4___default.a.setItem(opts.key, rehydrate(data), function (err) {\n          if (err) return reject(err);\n          localforage__WEBPACK_IMPORTED_MODULE_4___default.a.setItem(key, opts.version, function (err) {\n            if (err) return reject(err);\n            return resolve(data);\n          });\n        });\n      } else {\n        resolve(data);\n      }\n    });\n  });\n};\n\nvar config = {\n  key: '@session',\n  version: 1,\n  migrate: function migrate(state) {\n    return _objectSpread({}, state);\n  }\n};\nvar useStorage = function useStorage(state, setState) {\n  _s();\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_3__[\"useState\"])(false),\n      rehydrated = _useState[0],\n      setRehydrated = _useState[1];\n\n  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_3__[\"useState\"])(null),\n      error = _useState2[0],\n      setError = _useState2[1];\n\n  Object(react__WEBPACK_IMPORTED_MODULE_3__[\"useEffect\"])(function () {\n    function init() {\n      return _init.apply(this, arguments);\n    }\n\n    function _init() {\n      _init = Object(_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__[\"default\"])( /*#__PURE__*/_Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {\n        return _Users_alejandrosandoval_space_world_eserp_web_node_modules_next_node_modules_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return localforage__WEBPACK_IMPORTED_MODULE_4___default.a.getItem(config.key, function (err, value) {\n                  if (err) {\n                    setRehydrated(true);\n                    return setError(err);\n                  } // Migrate persisted data\n\n\n                  var restoredValue = rehydrate(value);\n\n                  if (typeof config.migrate === 'function') {\n                    createMigration(config, restoredValue).then(function (data) {\n                      return setState(data);\n                    }).then(function () {\n                      return setRehydrated(true);\n                    });\n                  } else {\n                    setState(restoredValue);\n                    setRehydrated(true);\n                  }\n                });\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n      return _init.apply(this, arguments);\n    }\n\n    init();\n  }, []);\n  Object(react__WEBPACK_IMPORTED_MODULE_3__[\"useEffect\"])(function () {\n    // if (isNil(state) || isEmpty(state)) {\n    //   localForage.removeItem(config.key);\n    // }\n    localforage__WEBPACK_IMPORTED_MODULE_4___default.a.setItem(config.key, hydrate(state));\n  }, [state]);\n  return {\n    rehydrated: rehydrated,\n    error: error\n  };\n};\n\n_s(useStorage, \"9DNzL48X4yDoK1QiDj4VAlT7VRE=\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"../../node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3VzZS1zdG9yYWdlLnRzPzg5MjQiXSwibmFtZXMiOlsiaXNPYmplY3RMaWtlZCIsInZhbHVlIiwiY29uc3RydWN0b3IiLCJuYW1lIiwicmVoeWRyYXRlIiwiZGVmYXVsdFZhbHVlIiwicGFyc2UiLCJKU09OIiwiZXJyIiwiaHlkcmF0ZSIsInN0cmluZ2lmeSIsImNyZWF0ZU1pZ3JhdGlvbiIsIm9wdHMiLCJkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJrZXkiLCJsb2NhbEZvcmFnZSIsImdldEl0ZW0iLCJ2ZXJzaW9uIiwibWlncmF0ZSIsInNldEl0ZW0iLCJjb25maWciLCJzdGF0ZSIsInVzZVN0b3JhZ2UiLCJzZXRTdGF0ZSIsInVzZVN0YXRlIiwicmVoeWRyYXRlZCIsInNldFJlaHlkcmF0ZWQiLCJlcnJvciIsInNldEVycm9yIiwidXNlRWZmZWN0IiwiaW5pdCIsInJlc3RvcmVkVmFsdWUiLCJ0aGVuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBQ0EsSUFBTUEsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFDQyxLQUFEO0FBQUEsU0FDcEJBLEtBQUssQ0FBQ0MsV0FBTixDQUFrQkMsSUFBbEIsS0FBMkIsT0FBM0IsSUFBc0NGLEtBQUssQ0FBQ0MsV0FBTixDQUFrQkMsSUFBbEIsS0FBMkIsUUFEN0M7QUFBQSxDQUF0Qjs7QUFHQSxJQUFNQyxTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFDSCxLQUFELEVBQWFJLFlBQWIsRUFBb0M7QUFDcEQsTUFBSSxDQUFDSixLQUFMLEVBQVksT0FBT0ksWUFBUCxDQUR3QyxDQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQUk7QUFDRixRQUFNQyxLQUFLLEdBQUdDLElBQUksQ0FBQ0QsS0FBTCxDQUFXTCxLQUFYLENBQWQ7QUFDQSxXQUFPSyxLQUFQO0FBQ0QsR0FIRCxDQUdFLE9BQU9FLEdBQVAsRUFBWTtBQUNaLFdBQU9ILFlBQVA7QUFDRDtBQUNGLENBYkQ7O0FBZUEsSUFBTUksT0FBTyxHQUFHLFNBQVZBLE9BQVUsQ0FBQ1IsS0FBRCxFQUFXO0FBQ3pCLE1BQUksQ0FBQ0QsYUFBYSxDQUFDQyxLQUFELENBQWxCLEVBQTJCO0FBQ3pCLFdBQU9BLEtBQVA7QUFDRDs7QUFDRCxTQUFPTSxJQUFJLENBQUNHLFNBQUwsQ0FBZVQsS0FBZixDQUFQO0FBQ0QsQ0FMRDs7QUFNQSxJQUFNVSxlQUFlLEdBQUcsU0FBbEJBLGVBQWtCLENBQUNDLElBQUQsRUFBT0MsSUFBUCxFQUFnQjtBQUN0QyxTQUFPLElBQUlDLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVDLE1BQVYsRUFBcUI7QUFDdEMsUUFBTUMsR0FBRyxhQUFNTCxJQUFJLENBQUNLLEdBQVgsYUFBVDtBQUNBQyxzREFBVyxDQUFDQyxPQUFaLENBQW9CRixHQUFwQixFQUF5QixVQUFDVCxHQUFELEVBQU1ZLE9BQU4sRUFBa0I7QUFDekMsVUFBSUEsT0FBTyxLQUFLUixJQUFJLENBQUNRLE9BQXJCLEVBQThCO0FBQzVCUCxZQUFJLEdBQUdELElBQUksQ0FBQ1MsT0FBTCxDQUFhUixJQUFiLENBQVA7QUFDQUssMERBQVcsQ0FBQ0ksT0FBWixDQUFvQlYsSUFBSSxDQUFDSyxHQUF6QixFQUE4QmIsU0FBUyxDQUFDUyxJQUFELENBQXZDLEVBQStDLFVBQUNMLEdBQUQsRUFBUztBQUN0RCxjQUFJQSxHQUFKLEVBQVMsT0FBT1EsTUFBTSxDQUFDUixHQUFELENBQWI7QUFDVFUsNERBQVcsQ0FBQ0ksT0FBWixDQUFvQkwsR0FBcEIsRUFBeUJMLElBQUksQ0FBQ1EsT0FBOUIsRUFBdUMsVUFBQ1osR0FBRCxFQUFTO0FBQzlDLGdCQUFJQSxHQUFKLEVBQVMsT0FBT1EsTUFBTSxDQUFDUixHQUFELENBQWI7QUFDVCxtQkFBT08sT0FBTyxDQUFDRixJQUFELENBQWQ7QUFDRCxXQUhEO0FBSUQsU0FORDtBQU9ELE9BVEQsTUFTTztBQUNMRSxlQUFPLENBQUNGLElBQUQsQ0FBUDtBQUNEO0FBQ0YsS0FiRDtBQWNELEdBaEJNLENBQVA7QUFpQkQsQ0FsQkQ7O0FBb0JBLElBQU1VLE1BQU0sR0FBRztBQUNiTixLQUFHLEVBQUUsVUFEUTtBQUViRyxTQUFPLEVBQUUsQ0FGSTtBQUdiQyxTQUFPLEVBQUUsaUJBQUNHLEtBQUQsRUFBVztBQUNsQiw2QkFBWUEsS0FBWjtBQUNEO0FBTFksQ0FBZjtBQVFPLElBQU1DLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQUNELEtBQUQsRUFBUUUsUUFBUixFQUFxQjtBQUFBOztBQUFBLGtCQUNUQyxzREFBUSxDQUFDLEtBQUQsQ0FEQztBQUFBLE1BQ3RDQyxVQURzQztBQUFBLE1BQzFCQyxhQUQwQjs7QUFBQSxtQkFFbkJGLHNEQUFRLENBQUMsSUFBRCxDQUZXO0FBQUEsTUFFdENHLEtBRnNDO0FBQUEsTUFFL0JDLFFBRitCOztBQUk3Q0MseURBQVMsQ0FBQyxZQUFNO0FBQUEsYUFDQ0MsSUFERDtBQUFBO0FBQUE7O0FBQUE7QUFBQSx5VkFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSx1QkFDUWYsa0RBQVcsQ0FBQ0MsT0FBWixDQUFvQkksTUFBTSxDQUFDTixHQUEzQixFQUFnQyxVQUFDVCxHQUFELEVBQU1QLEtBQU4sRUFBZ0I7QUFDcEQsc0JBQUlPLEdBQUosRUFBUztBQUNQcUIsaUNBQWEsQ0FBQyxJQUFELENBQWI7QUFDQSwyQkFBT0UsUUFBUSxDQUFDdkIsR0FBRCxDQUFmO0FBQ0QsbUJBSm1ELENBS3BEOzs7QUFDQSxzQkFBTTBCLGFBQWEsR0FBRzlCLFNBQVMsQ0FBQ0gsS0FBRCxDQUEvQjs7QUFDQSxzQkFBSSxPQUFPc0IsTUFBTSxDQUFDRixPQUFkLEtBQTBCLFVBQTlCLEVBQTBDO0FBQ3hDVixtQ0FBZSxDQUFDWSxNQUFELEVBQVNXLGFBQVQsQ0FBZixDQUNHQyxJQURILENBQ1EsVUFBQ3RCLElBQUQ7QUFBQSw2QkFBVWEsUUFBUSxDQUFDYixJQUFELENBQWxCO0FBQUEscUJBRFIsRUFFR3NCLElBRkgsQ0FFUTtBQUFBLDZCQUFNTixhQUFhLENBQUMsSUFBRCxDQUFuQjtBQUFBLHFCQUZSO0FBR0QsbUJBSkQsTUFJTztBQUNMSCw0QkFBUSxDQUFDUSxhQUFELENBQVI7QUFDQUwsaUNBQWEsQ0FBQyxJQUFELENBQWI7QUFDRDtBQUNGLGlCQWZLLENBRFI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsT0FEYztBQUFBO0FBQUE7O0FBbUJkSSxRQUFJO0FBQ0wsR0FwQlEsRUFvQk4sRUFwQk0sQ0FBVDtBQXNCQUQseURBQVMsQ0FBQyxZQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0FkLHNEQUFXLENBQUNJLE9BQVosQ0FBb0JDLE1BQU0sQ0FBQ04sR0FBM0IsRUFBZ0NSLE9BQU8sQ0FBQ2UsS0FBRCxDQUF2QztBQUNELEdBTFEsRUFLTixDQUFDQSxLQUFELENBTE0sQ0FBVDtBQU9BLFNBQU87QUFDTEksY0FBVSxFQUFWQSxVQURLO0FBRUxFLFNBQUssRUFBTEE7QUFGSyxHQUFQO0FBSUQsQ0FyQ007O0dBQU1MLFUiLCJmaWxlIjoiLi9zcmMvdXRpbHMvdXNlLXN0b3JhZ2UudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGxvY2FsRm9yYWdlIGZyb20gJ2xvY2FsZm9yYWdlJztcbmNvbnN0IGlzT2JqZWN0TGlrZWQgPSAodmFsdWUpID0+XG4gIHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheScgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCc7XG5cbmNvbnN0IHJlaHlkcmF0ZSA9ICh2YWx1ZTogYW55LCBkZWZhdWx0VmFsdWU/OiBhbnkpID0+IHtcbiAgaWYgKCF2YWx1ZSkgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgLy8gaWYgKHZhbHVlID09PSAnZmFsc2UnKSBzdHIgPSBmYWxzZTtcbiAgLy8gaWYgKHZhbHVlID09PSAndHJ1ZScpIHN0ciA9IHRydWU7XG4gIC8vIGlmICghaXNPYmplY3RMaWtlZCh2YWx1ZSkpIHtcbiAgLy8gICByZXR1cm4gdmFsdWU7XG4gIC8vIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZSA9IEpTT04ucGFyc2UodmFsdWUpO1xuICAgIHJldHVybiBwYXJzZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgfVxufTtcblxuY29uc3QgaHlkcmF0ZSA9ICh2YWx1ZSkgPT4ge1xuICBpZiAoIWlzT2JqZWN0TGlrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59O1xuY29uc3QgY3JlYXRlTWlncmF0aW9uID0gKG9wdHMsIGRhdGEpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBrZXkgPSBgJHtvcHRzLmtleX0tdmVyc2lvbmA7XG4gICAgbG9jYWxGb3JhZ2UuZ2V0SXRlbShrZXksIChlcnIsIHZlcnNpb24pID0+IHtcbiAgICAgIGlmICh2ZXJzaW9uICE9PSBvcHRzLnZlcnNpb24pIHtcbiAgICAgICAgZGF0YSA9IG9wdHMubWlncmF0ZShkYXRhKTtcbiAgICAgICAgbG9jYWxGb3JhZ2Uuc2V0SXRlbShvcHRzLmtleSwgcmVoeWRyYXRlKGRhdGEpLCAoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgIGxvY2FsRm9yYWdlLnNldEl0ZW0oa2V5LCBvcHRzLnZlcnNpb24sIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY29uc3QgY29uZmlnID0ge1xuICBrZXk6ICdAc2Vzc2lvbicsXG4gIHZlcnNpb246IDEsXG4gIG1pZ3JhdGU6IChzdGF0ZSkgPT4ge1xuICAgIHJldHVybiB7IC4uLnN0YXRlIH07XG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgdXNlU3RvcmFnZSA9IChzdGF0ZSwgc2V0U3RhdGUpID0+IHtcbiAgY29uc3QgW3JlaHlkcmF0ZWQsIHNldFJlaHlkcmF0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKG51bGwpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIGF3YWl0IGxvY2FsRm9yYWdlLmdldEl0ZW0oY29uZmlnLmtleSwgKGVyciwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHNldFJlaHlkcmF0ZWQodHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHNldEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWlncmF0ZSBwZXJzaXN0ZWQgZGF0YVxuICAgICAgICBjb25zdCByZXN0b3JlZFZhbHVlID0gcmVoeWRyYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcubWlncmF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNyZWF0ZU1pZ3JhdGlvbihjb25maWcsIHJlc3RvcmVkVmFsdWUpXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4gc2V0U3RhdGUoZGF0YSkpXG4gICAgICAgICAgICAudGhlbigoKSA9PiBzZXRSZWh5ZHJhdGVkKHRydWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRTdGF0ZShyZXN0b3JlZFZhbHVlKTtcbiAgICAgICAgICBzZXRSZWh5ZHJhdGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaW5pdCgpO1xuICB9LCBbXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBpZiAoaXNOaWwoc3RhdGUpIHx8IGlzRW1wdHkoc3RhdGUpKSB7XG4gICAgLy8gICBsb2NhbEZvcmFnZS5yZW1vdmVJdGVtKGNvbmZpZy5rZXkpO1xuICAgIC8vIH1cbiAgICBsb2NhbEZvcmFnZS5zZXRJdGVtKGNvbmZpZy5rZXksIGh5ZHJhdGUoc3RhdGUpKTtcbiAgfSwgW3N0YXRlXSk7XG5cbiAgcmV0dXJuIHtcbiAgICByZWh5ZHJhdGVkLFxuICAgIGVycm9yLFxuICB9O1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/utils/use-storage.ts\n");

/***/ })

}]);